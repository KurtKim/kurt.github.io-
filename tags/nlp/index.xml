<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NLP on K2H Blog</title><link>https://kurtkim.github.io/tags/nlp/</link><description>Recent content in NLP on K2H Blog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Thu, 04 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://kurtkim.github.io/tags/nlp/index.xml" rel="self" type="application/rss+xml"/><item><title>ALBERT</title><link>https://kurtkim.github.io/p/albert/</link><pubDate>Thu, 04 Jan 2024 00:00:00 +0000</pubDate><guid>https://kurtkim.github.io/p/albert/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>자연어 표현을 사전 학습할 때 모델 크기를 늘리면 종종 성능이 향상되지만, GPU/TPU 메모리 한계와 학습 시간이 길어지는 문제가 있다. 이를 해결하기 위해, BERT의 메모리 소비를 줄이고 훈련 속도를 높이는 두 가지 기법을 제시하였다. 이 기법은 원래의 BERT보다 훨씬 더 잘 확장되는 모델을 만들며, 문장 간 일관성을 모델링하는 self-supervised loss를 사용하여 다문장 입력 작업에 도움이 된다. 결과적으로, BERT-large보다 parameter가 적은 ALBERT 모델은 GLUE, RACE, SQuAD benchmark에서 state-of-the-art를 달성하였다.&lt;/p>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>Full network pre-training는 언어 학습에서 중요한 돌파구를 이끌어내었다. 이를 통해 학습 데이터가 제한된 NLP 작업들이 큰 도움을 받았다. 중국의 영어 시험을 위한 RACE 테스트에서 기계 성능은 초기 44.1%에서 최근에는 83.2%로 상승하였다. 이 연구를 통해 성능은 더욱 향상되어 89.4%에 이르렀다. 이는 주로 고성능 사전 학습 언어 표현 능력의 발전 덕분이다.&lt;/p>
&lt;p>이러한 개선사항들은 큰 네트워크가 state-of-the-art를 달성하는 데 중요함을 보여준다. 이제는 큰 모델을 사전 학습하고 작은 모델로 축소하는 것이 일반적인 방법이다. 그래서 이 연구에서는 &amp;ldquo;더 나은 NLP 모델을 가지는 것이 큰 모델을 가지는 것만큼 쉬운 것인지&amp;quot;라는 질문을 던지게 된다.&lt;/p>
&lt;p>이 질문에 대한 장애물은 사용 가능한 하드웨어의 메모리 제한이다. 현재의 state-of-the-art 모델들은 종종 수백만 개 또는 심지어 수십억 개의 parameter를 가지고 있어, 모델을 확장하려고 할 때 이러한 제한에 쉽게 부딪히게 된다. 또한, parameter 수에 비례하는 통신 오버헤드로 인해 분산 훈련시 훈련 속도가 크게 저하될 수 있다.&lt;/p>
&lt;p>이 논문에서는 매개변수가 더 적은 ALBERT 구조를 설계하여 이 문제들을 모두 해결하였다.&lt;/p>
&lt;p>ALBERT는 사전 학습된 모델 확장의 주요 장애물을 제거하는 두 가지 parameter 축소 기법을 사용한다. 첫 번째는 큰 어휘 임베딩 행렬을 작은 행렬로 분해하는 것, 두 번째는 네트워크 깊이에 따른 parameter 증가를 방지하는 것이다. 이 두 기법은 BERT의 매개변수 수를 크게 줄이고, BERT-large와 유사한 ALBERT 구성은 매개변수가 18배 더 적고, 약 1.7배 더 빠르게 훈련될 수 있게 한다. 이 기법들은 훈련을 안정화시키고 일반화에 도움을 주는 정규화 역할도 한다.&lt;/p>
&lt;p>ALBERT의 성능을 더욱 향상시키기 위해, sentence-order prediction(SOP)을 위한 self-supervised loss도 도입하였다. SOP는 주로 문장 간의 일관성에 초점을 맞추고 있으며, 원래 BERT에서 제안된 다음 next sentence prediction(NSP) loss의 비효율성을 해결하도록 설계되었다.&lt;/p>
&lt;p>그 결과, BERT-large보다 parameter는 더 적지만 성능은 훨씬 뛰어난 더 큰 ALBERT 구성으로 확장할 수 있었다. 그리고 자연 언어 이해를 위한 잘 알려진 GLUE, SQuAD, RACE 벤치마크에서 state-of-the-art를 달성하였다.&lt;/p>
&lt;h2 id="related-work">Related Work&lt;/h2>
&lt;h3 id="scaling-up-representation-learning-for-natural-language">Scaling up Representation Learning for Natural Language&lt;/h3>
&lt;p>자연 언어의 표현 학습은 다양한 NLP 작업에 유용하며 널리 채택되어왔다. 최근 가장 큰 변화는 단어 임베딩의 사전 학습에서, 전체 네트워크의 사전 학습 후 작업 특정 미세 조정으로 전환되었다는 것이다. 이러한 연구에서는 더 큰 모델 크기가 성능을 향상시키는 것이 종종 보여졌다. 하지만, 모델 크기와 계산 비용 문제로 인해 hidden size 는 1024에서 멈추게 되었다.&lt;/p>
&lt;p>큰 모델로 실험하는 것은 계산적 제약, 특히 GPU/TPU 메모리 제한 때문에 어렵다. 이 문제를 해결하기 위한 여러 방법이 제안되었는데, 그 중에는 gradient checkpointing과 각 layer의 activation 재구성 방법이 있다. 이런 방법들은 속도비용으로 메모리 사용량을 줄인다. 반면에, parameter reduction techniques는 메모리 사용을 줄이면서 훈련 속도를 높인다.&lt;/p>
&lt;h3 id="cross-layer-parameter-sharing">Cross-Layer Parameter Sharing&lt;/h3>
&lt;p>cross-layer parameter sharing의 아이디어는 이전에 Transformer 아키텍처에서 제안되었다. 하지만 이전 연구는 표준 인코더-디코더 작업에 초점을 맞추어져있었다. Dehghani et al. (2018)은 cross-layer parameter sharing를 가진 네트워크가 언어 모델링에서 더 나은 성능을 낸다고 보여주었다. 최근에는, Bai et al. (2019)이 Transformer 네트워크를 위한 Deep Equilibrium Model을 제안하였다. Hao et al. (2019)은 parameter-sharing transformer와 standard transformer를 결합하여 parameter 수를 늘렸다.&lt;/p>
&lt;h3 id="sentence-ordering-objectives">Sentence Ordering Objectives&lt;/h3>
&lt;p>ALBERT는 두 연속된 텍스트 세그먼트의 순서를 예측하는 사전 학습 loss를 사용한다. 이는 담화의 일관성에 관련된 다른 사전 학습 목표와 유사하다. 대부분의 효과적인 목표는 매우 단순하며, 이웃하는 문장의 단어를 예측하는 것에 기반한다. loss는 두 연속된 문장의 순서를 결정하기 위해 학습된 문장 임베딩과 가장 관련이 있다. 하지만, loss는 문장이 아닌 텍스트 세그먼트에 적용된다. BERT는 한 쌍에서 두 번째 세그먼트가 다른 문서의 세그먼트와 바뀌었는지 예측하는 loss을 사용하고, 이는 NSP가 더 도전적인 사전 학습 작업이며 특정 downstream task에 더 유용하다는 것을 보여준다.&lt;/p>
&lt;h2 id="the-elements-of-albert">The Elements of ALBERT&lt;/h2>
&lt;p>ALBERT의 설계 결정사항을 제시하고, BERT 아키텍처와 비교한다.&lt;/p>
&lt;h3 id="model-architecture-choices">Model Architecture Choices&lt;/h3>
&lt;p>ALBERT 아키텍처는 Transformer 인코더를 GELU 비선형성과 함께 사용하는 BERT와 유사하다. vocabulary embedding size는 $E$, encoder layer의 수는 $L$, hidden size는 $H$로 표기하며, feed-forward/ﬁlter size는 $4H$, attention head의 수는 $H/64$로 설정한다.&lt;/p>
&lt;p>ALBERT는 이러한 BERT의 설계에 대해 세 가지 주요한 개선점을 제시한다.&lt;/p>
&lt;h4 id="factorized-embedding-parameterization">Factorized embedding parameterization.&lt;/h4>
&lt;p>BERT, XLNet, RoBERTa 등의 모델에서는 WordPiece 임베딩 크기($E$)와 히든 레이어 크기($H$)가 같게 설정이 되었다. 이러한 결정은 모델링과 실용적인 측면에서 최적이 아닌 것으로 판단된다.&lt;/p>
&lt;p>모델링 측면에서 보면, WordPiece 임베딩은 문맥에 독립적인 표현을, 히든 레이어 임베딩은 문맥에 의존적인 표현을 학습한다. BERT와 같은 표현의 힘은 문맥을 이용한 학습에서 나온다는 것이 확인되었다. 따라서 WordPiece 임베딩 크기 $E$와 히든 레이어 크기 $H$를 분리하면, 모델링 요구사항에 따라 총 모델 parameter를 더 효율적으로 사용할 수 있다. 이는 실질적으로 $H$가 $E$보다 훨씬 커야 한다는 것을 의미한다.&lt;/p>
&lt;p>실용적으로 보면, 자연어 처리에서는 대체로 어휘 크기($V$)가 큰 편이다. 만약 $E$와 $H$가 같다면, $H$를 증가시키는 것은 임베딩 행렬의 크기를 증가시키게 되고, 이로 인해 parameter가 수십억 개가 되어버릴 수 있다. 더욱이, 이런 parameter들은 훈련 도중에는 대부분 희소하게만 업데이트된다.&lt;/p>
&lt;p>ALBERT에서는 임베딩 파라미터를 두 개의 작은 행렬로 분해한다. one-hot vector를 $H$ 크기의 hidden space로 투영하는 대신, 먼저 $E$ 크기의 lower dimensional embedding space로 투영한 후 hidden space으로 투영한다. 이 방식을 통해 임베딩 파라미터를 $O(V \times H)$에서 $O(V \times E \times E \times H)$로 줄일 수 있다. 이 parameter 축소는 $H$가 $E$보다 훨씬 클 때 중요하며, 모든 워드피스에 대해 같은 $E$를 사용하게 된다.&lt;/p>
&lt;h4 id="cross-layer-parameter-sharing-1">Cross-layer parameter sharing&lt;/h4>
&lt;p>ALBERT에서는 parameter 효율성을 향상시키는 방법으로 cross-layer parameter sharing를 제안한다. 여기에는 레이어 간에 feed-forward network (FFN) parameter만 공유하거나, attention parameter만 공유하는 등 여러 가지 방법이 있다. 그러나 ALBERT의 기본 설정은 모든 레이어 간에 모든 parameter를 공유하는 것이다. 이 설정은 특별히 명시되지 않는 한 모든 실험에서 사용된다.&lt;/p>
&lt;p>Universal Transformer와 Deep Equilibrium Models에서도 Transformer 네트워크에 대해 유사한 전략들이 탐구되었다. Universal Transformer가 일반 Transformer를 능가한다고 보여주었고, Deep Equilibrium Models가 특정 레이어의 입력과 출력 임베딩이 동일하게 유지되는 균형점에 도달함을 보여주었다. 반면 이 논문의 측정 결과에서는 임베딩들이 수렴하기보다는 진동하고 있다는 것을 보여준다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/albert/images/figure1.png"
width="996"
height="326"
srcset="https://kurtkim.github.io/p/albert/images/figure1_hu0f8a585023b11c0ac06fe233d6d0fe1e_63214_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/albert/images/figure1_hu0f8a585023b11c0ac06fe233d6d0fe1e_63214_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="305"
data-flex-basis="733px"
>&lt;/p>
&lt;p>ALBERT에서 레이어 간의 전환이 BERT보다 훨씬 부드럽다는 것을 관찰할 수 있다. 이는 parameter sharing이 network의 parameter를 안정화하는데 영향을 미친다는 것을 보여주며, 24개의 레이어 후에도 두 메트릭 모두 0으로 수렴하지 않는다.&lt;/p>
&lt;h4 id="inter-sentence-coherence-loss">Inter-sentence coherence loss&lt;/h4>
&lt;p>BERT는 masked language modeling(MLM) loss 외에도 next-sentence prediction(NSP) 이라는 추가적인 loss을 사용한다. NSP는 두 세그먼트가 원문에서 연속으로 나타나는지 예측하는 binary classiﬁcation loss이다. 이 목표는 문장 쌍 간의 관계에 대한 추론을 요구하는 자연어 추론과 같은 downstream task의 성능을 향상시키기 위해 설계되었다. 그러나 이후 연구에서는 NSP의 영향이 불안정하다고 판단하여 제거하기로 하였고, 이 결정은 여러 작업에서 downstream task 성능의 향상으로 지지받았다.&lt;/p>
&lt;p>NSP의 비효율성 뒤에 있는 주요 이유는 MLM과 비교했을 때 작업의 난이도가 부족하다는 것으로, NSP는 주제 예측과 일관성 예측을 하나의 작업에서 혼동시킨다. 그러나 주제 예측은 일관성 예측보다 학습하기 쉽고, MLM 손실을 사용하여 학습하는 것과 더 많이 겹친다.&lt;/p>
&lt;p>이 연구에서는 문장 간 모델링이 중요하다고 주장고 있으며, ALBERT에서는 주로 일관성에 기반한 sentence-order prediction(SOP) loss을 사용한다. SOP 손실은 모델이 담화 수준의 일관성에 대한 더 세밀한 구분을 학습하도록 만든다. NSP는 SOP 작업을 전혀 해결할 수 없지만, SOP는 NSP 작업을 어느 정도 해결할 수 있다. 결과적으로, ALBERT 모델은 다문장 인코딩 작업에 대한 성능을 일관되게 향상시킬 수 있었다.&lt;/p>
&lt;h3 id="model-setup">Model setup&lt;/h3>
&lt;p>&lt;img src="https://kurtkim.github.io/p/albert/images/table1.png"
width="930"
height="224"
srcset="https://kurtkim.github.io/p/albert/images/table1_hu954e7bc0017b0f79a93e8e01016d57c1_47227_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/albert/images/table1_hu954e7bc0017b0f79a93e8e01016d57c1_47227_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="415"
data-flex-basis="996px"
>&lt;/p>
&lt;p>ALBERT 모델은 설계 선택 때문에 BERT 모델보다 parameter 크기가 훨씬 작다. 예를 들어, ALBERT-large는 BERT-large보다 parameter가 약 18배 작다. 이런 parameter 효율성 향상은 ALBERT의 설계 선택에서 가장 중요한 장점이다.&lt;/p>
&lt;h2 id="experimental-results">Experimental Results&lt;/h2>
&lt;h3 id="experimental-setup">Experimental Setup&lt;/h3>
&lt;p>의미 있는 비교를 위해, BERT 설정을 따라서 사전 훈련 기본 모델에 대해 Book Corpus와 영문 Wikipedia를 사용한다. 이 두 말뭉치는 압축되지 않은 텍스트로 약 16GB를 구성한다. 입력은 $[CLS] x_1 [SEP] x_2 [SEP]$ 와 같은 포멧이며, 최대 512 길이로 제한한다. 그리고 10%의 확률로 512보다 짧은 입력 시퀀스를 무작위로 생성한다. BERT와 같이, 30,000의 어휘 크기를 가지며, XLNet처럼 SentencePiece를 사용하여 토큰화한다.&lt;/p>
&lt;p>각 n-gram 마스크의 길이를 무작위로 선택하여 n-gram 마스킹을 사용해 MLM 목표를 위한 마스크된 입력을 생성한다. 길이 n에 대한 확률은 다음과 같이 주어진다:&lt;/p>
&lt;p>$$p(n) = {{1/n}\over{\sum_{k=1}^{N}1/k}} $$&lt;/p>
&lt;p>n-gram의 최대 길이는 3으로 설정하며, 이는 MLM 목표가 최대 3-gram 단어로 구성될 수 있음을 의미한다. 모든 모델 업데이트는 배치 크기 4096과 학습률 0.00176의 $L_{AMB}$ optimizer를 사용하며, 모든 모델은 125,000 step 동안 학습된다. 훈련은 Cloud TPU V3에서 이루어졌으며, 사용된 TPU의 수는 모델 크기에 따라 64에서 512까지 다양했다. 이 실험 설정은 우리가 만든 모든 BERT 버전과 ALBERT 모델에 사용되었다.&lt;/p>
&lt;h2 id="evaluation-benchmarks">Evaluation Benchmarks&lt;/h2>
&lt;h3 id="intrinsic-evalutation">Intrinsic Evalutation&lt;/h3>
&lt;p>학습 상황을 확인하기 위해, SQuAD와 RACE의 개발 세트를 기반으로 개발 세트를 만들었다. MLM과 문장 분류 작업의 정확도를 보고한다. 이 세트는 모델의 수렴 상태를 확인하는데만 사용되며, 모델 선택과 같은 방식으로 downstream evaluation의 성능에 영향을 주지 않는다.&lt;/p>
&lt;h3 id="downstream-evaluation">Downstream Evaluation&lt;/h3>
&lt;p>GLUE benchmark, SQuAD의 두 버전, 그리고 RACE dataset이라는 세 가지 benchmark에서 평가한다. 작업 리더보드를 기반으로 한 최종 비교를 위해 테스트 세트 결과도 측정하며, 개발 세트에서 큰 분산을 가진 GLUE 데이터셋에 대해서는 5회 실행의 중앙값을 측정한다.&lt;/p>
&lt;h3 id="overall-comparison-between-bert-and-albert">Overall Comparison between BERT and ALBERT&lt;/h3>
&lt;p>&lt;img src="https://kurtkim.github.io/p/albert/images/table2.png"
width="1076"
height="218"
srcset="https://kurtkim.github.io/p/albert/images/table2_hu0550922691de2726c6d77f6571f8fd40_66118_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/albert/images/table2_hu0550922691de2726c6d77f6571f8fd40_66118_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="493"
data-flex-basis="1184px"
>&lt;/p>
&lt;p>ALBERT의 디자인 선택사항 중 parameter 효율성 향상이 가장 중요한 장점으로, BERT-large의 parameter의 70%만으로도 ALBERT-xxlarge는 여러 downstream task에서 상당한 개선을 보이고 있다.&lt;/p>
&lt;p>동일한 훈련 구성 하에서, ALBERT 모델들은 BERT 모델들에 비해 더 높은 데이터 처리량을 보인다. BERT-large를 기준으로 할 때, ALBERT-large는 데이터를 처리하는 데 약 1.7배 더 빠르고, 큰 구조 때문에 ALBERT-xxlarge는 약 3배 더 느리다.&lt;/p>
&lt;p>마지막으로, ALBERT의 각 디자인 선택사항이 얼마나 기여하는지 파악하기 위한 ablation experiments을 수행한다.&lt;/p>
&lt;h3 id="factorized-embedding-parameterization-1">Factorized Embedding Parameterization&lt;/h3>
&lt;p>&lt;img src="https://kurtkim.github.io/p/albert/images/table3.png"
width="988"
height="276"
srcset="https://kurtkim.github.io/p/albert/images/table3_hucd20cde220454690378f9647dd10e4ac_76243_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/albert/images/table3_hucd20cde220454690378f9647dd10e4ac_76243_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="357"
data-flex-basis="859px"
>&lt;/p>
&lt;p>BERT 스타일의 비공유 상태에서는 더 큰 임베딩 크기가 약간 더 나은 성능을 보이지만, ALBERT 스타일의 모든 공유 상태에서는 크기 128의 임베딩이 최적으로 보인다. 이 결과를 바탕으로, 모든 추후 설정에서 임베딩 크기 128을 사용하게 된다.&lt;/p>
&lt;h3 id="cross-layer-parameter-sharing-2">Cross-layer parameter sharing&lt;/h3>
&lt;p>&lt;img src="https://kurtkim.github.io/p/albert/images/table4.png"
width="1098"
height="268"
srcset="https://kurtkim.github.io/p/albert/images/table4_hue899a8f796d1baa9493d7bb4c90587fa_87546_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/albert/images/table4_hue899a8f796d1baa9493d7bb4c90587fa_87546_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="409"
data-flex-basis="983px"
>&lt;/p>
&lt;p>all-shared strategy인 ALBERT 스타일은 성능을 떨어뜨리지만, 임베딩 크기가 128일 때는 768일 때보다 저하가 덜 하다다. 성능 저하는 주로 FFN layer parameter sharing으로 인해 발생하며, attention parameter sharing은 성능 저하를 일으키지 않는다.&lt;/p>
&lt;p>다른 레이어 간의 parameter sharing 전략도 가능하지만, 그룹 크기를 줄이면 전체 parameter 수가 크게 증가한다. 따라서 all-shared strategy을 기본으로 선택하였다.&lt;/p>
&lt;h3 id="sentence-order-prediction-sop">Sentence order prediction (SOP)&lt;/h3>
&lt;p>세 가지 실험 조건인 &amp;rsquo;none&amp;rsquo; (XLNet 및 RoBERTa 스타일), NSP (BERT 스타일), SOP (ALBERT 스타일)에 대한 추가 문장 간 손실을 ALBERTbase 설정을 사용하여 비교하였다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/albert/images/table5.png"
width="996"
height="172"
srcset="https://kurtkim.github.io/p/albert/images/table5_hua005ba83d01af37e02a3f1140a802c9b_45348_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/albert/images/table5_hua005ba83d01af37e02a3f1140a802c9b_45348_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="579"
data-flex-basis="1389px"
>&lt;/p>
&lt;p>NSP loss가 SOP 작업에 판별력을 제공하지 못하며, 주제 전환만 모델링하는 것으로 나타났다. 반면에, SOP loss는 NSP 작업을 상대적으로 잘 처리하며, SOP 작업에 대해서는 더욱 더 잘 처리했다. 더욱이, SOP loss는 여러 문장 인코딩 작업에 대한 downstream task 성능을 일관되게 향상시키는 것으로 나타났으며, 이는 평균 점수 향상이 약 1%라는 것을 의미한다.&lt;/p>
&lt;h3 id="what-if-we-train-for-the-same-amount-of-time">What if we train for the same amount of time?&lt;/h3>
&lt;p>BERT-large의 데이터 처리량은 ALBERT-xxlarge에 비해 약 3.17배 높다. 따라서 같은 학습 시간 동안 모델을 학습시키는 비교를 수행하였다. 400k 학습 단계 후의 BERT-large 모델 (학습 34시간 후)과 ALBERT-xxlarge 모델을 125k 학습 단계 동안 학습하는 데 필요한 시간 (학습 32시간)을 비교한다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/albert/images/table6.png"
width="1020"
height="110"
srcset="https://kurtkim.github.io/p/albert/images/table6_hu127742eb5feda8aabb3dd35e8f8960ea_33902_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/albert/images/table6_hu127742eb5feda8aabb3dd35e8f8960ea_33902_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="927"
data-flex-basis="2225px"
>&lt;/p>
&lt;p>ALBERT-xxlarge는 BERT-large보다 훨씬 더 우수하며, 평균적으로 +1.5% 더 좋고, RACE에서는 최대 +5.2%까지 차이가 난다.&lt;/p>
&lt;h3 id="additional-training-data-and-dropout-effects">Additional training data and dropout effects&lt;/h3>
&lt;p>XLNet과 RoBERTa가 모두 사용한 추가 데이터의 영향을 비교한다. 추가 데이터 없을 때와 있을 때의 개발 세트 MLM 정확도를 비교하며, 추가 데이터를 사용할 때 중요한 향상을 보여준다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/albert/images/table7.png"
width="892"
height="112"
srcset="https://kurtkim.github.io/p/albert/images/table7_hu202f86a529c8ffba927ae35007b9bd74_29608_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/albert/images/table7_hu202f86a529c8ffba927ae35007b9bd74_29608_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="796"
data-flex-basis="1911px"
>&lt;/p>
&lt;p>또한, SQuAD benchmark를 제외한 downstream task에서 성능 개선을 관찰했다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/albert/images/figure2.png"
width="976"
height="366"
srcset="https://kurtkim.github.io/p/albert/images/figure2_hu17e79b127f9b0f6927cb1047fa6dded1_79374_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/albert/images/figure2_hu17e79b127f9b0f6927cb1047fa6dded1_79374_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="266"
data-flex-basis="640px"
>&lt;/p>
&lt;p>1M step까지 학습한 후에도, 가장 큰 모델들은 훈련 데이터에 과적합되지 않았다. 그래서 드롭아웃을 제거하여 모델의 용량을 늘려서 실험을 계속 하였으며, 드롭아웃을 제거하면 MLM 정확도가 크게 향상된다는 것이 확인되었다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/albert/images/table8.png"
width="844"
height="104"
srcset="https://kurtkim.github.io/p/albert/images/table8_hu25729e745a9229874603262353045868_27844_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/albert/images/table8_hu25729e745a9229874603262353045868_27844_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="811"
data-flex-basis="1947px"
>&lt;/p>
&lt;p>ALBERT-xxlarge의 중간 평가에서도 드롭아웃 제거가 downstream task에 도움이 된다는 것이 확인되었다. 이는, 드롭아웃이 큰 Transformer 기반 모델의 성능을 해칠 수 있다는 것을 보여준다. 그러나, ALBERT의 기본 네트워크 구조는 Transformer의 특수한 경우로, 이 현상이 다른 Transformer 기반 아키텍처에서도 나타나는지 여부를 확인하기 위해 추가 실험이 필요하다.&lt;/p>
&lt;h3 id="current-state-of-the-art-on-nlu-tasks">Current State-of-the-art on NLU Tasks&lt;/h3>
&lt;p>단일 모델과 앙상블에 대해 미세조정을 수행하고 state-of-the-art 결과를 비교한다. 모든 설정에서 단일 작업 미세조정만 수행하며, 개발 세트에서는 5번의 실행 결과 중 중앙값을 비교한다.&lt;/p>
&lt;p>최종 앙상블 모델에 기여하는 체크포인트는 개발 세트 성능에 따라 선택되며, 체크포인트의 수는 작업에 따라 6에서 17까지 다르다. GLUE와 RACE benchmark의 경우, 다른 학습 단계에서 미세조정된 후보 모델들의 예측을 평균화한다. SQuAD의 경우, 여러 확률을 가진 범위의 예측 점수와 &amp;ldquo;응답할 수 없는&amp;rdquo; 결정의 점수를 평균화한다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/albert/images/table9.png"
width="1058"
height="404"
srcset="https://kurtkim.github.io/p/albert/images/table9_hu05cc00972c3874e11ae4c4727ea46cf0_113821_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/albert/images/table9_hu05cc00972c3874e11ae4c4727ea46cf0_113821_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="261"
data-flex-basis="628px"
>&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/albert/images/table10.png"
width="1080"
height="462"
srcset="https://kurtkim.github.io/p/albert/images/table10_hu60fbbc83e296937a66cc096bdc5ee8b2_118871_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/albert/images/table10_hu60fbbc83e296937a66cc096bdc5ee8b2_118871_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="233"
data-flex-basis="561px"
>&lt;/p>
&lt;p>단일 모델과 앙상블 모델 모두 ALBERT가 모든 벤치마크에서 상당히 향상된 성능을 보여준다. GLUE 점수는 89.4, SQuAD 2.0 테스트 F1 점수는 92.2, RACE 테스트 정확도는 89.4에 달하며, 이는 BERT, XLNet, RoBERTa, 그리고 DCMI+ 등에 비해 큰 향상을 보여준다. 또한, 단일 모델은 86.5%의 정확도를 달성하여, state-of-the-art 앙상블 모델보다 2.4% 더 높다.&lt;/p>
&lt;h2 id="discussion">Discussion&lt;/h2>
&lt;p>ALBERT-xxlarge는 BERT-large보다 parameter가 적지만 더 좋은 성능을 보인다. 하지만, 큰 구조 때문에 계산 비용이 더 많이 들어간다. 따라서, 다음 단계는 sparse attention와 block attention 등의 방법을 통해 ALBERT의 학습과 추론 속도를 높이는 것이다. 어려운 예제 채굴과 더 효율적인 언어 모델링 훈련 등 별개의 연구 방향이 추가적인 표현력을 제공할 수 있다. 또한, 문장 순서 예측이 더 나은 언어 표현을 이끌어내는 좋은 학습 작업이지만, 추가적인 표현력을 만들어낼 수 있는 현재 자기 self-supervised loss에 포착되지 않은 다른 차원이 있을 수 있다는 가설이 있다.&lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>&lt;a class="link" href="https://arxiv.org/pdf/1909.11942.pdf" target="_blank" rel="noopener"
>Paper&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/google-research/ALBERT" target="_blank" rel="noopener"
>Code&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>RoBERTa</title><link>https://kurtkim.github.io/p/roberta/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://kurtkim.github.io/p/roberta/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>언어 모델의 사전 학습은 큰 성능 향상을 가져왔지만, 다른 접근법 간의 비교는 어렵다. 학습 과정은 비용이 많이 들며, hyperparameter 선택이 결과에 큰 영향을 미친다. 이 연구는 BERT 학습을 재현하고, 핵심 hyperparameter와 학습 데이터 크기의 영향을 측정하는데, 이를 통해 BERT가 undertrained 상태였으며, 그 이후의 모든 모델의 성능을 맞추거나 능가할 수 있다는 것을 발견했다. RoBERTa는 여러 테스트에서 state-of-the-art를 달성하였고, 이는 이전에 간과된 설계의 중요성을 보여준다.&lt;/p>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>이 연구는 BERT의 사전 학습 방법을 재현하고, 그 효과를 평가했다. 연구 결과 BERT는 상당히 학습이 부족했으며, 이를 개선하기 위한 새로운 학습 방법 RoBERTa를 제안했다. RoBERTa는 더 큰 배치와 더 많은 데이터에서 모델을 더 오래 학습시키고, 다음 문장 예측 목표를 제거하며, 더 긴 시퀀스에서 학습시키고, 학습 데이터에 적용되는 마스킹 패턴을 동적으로 변경한다. 이 개선된 학습 방법은 GLUE와 SQuAD에서 BERT의 성능을 뛰어넘었다. 또한, 새로운 데이터셋인 CCN EWS를 사용하고, 사전 학습에 더 많은 데이터를 사용하면 성능이 더욱 향상된다는 것을 확인하였다.&lt;/p>
&lt;h2 id="background">Background&lt;/h2>
&lt;p>BERT의 사전 학습 방식과 실험적으로 검토할 학습 선택 사항에 대해 간단히 소개한다.&lt;/p>
&lt;h3 id="setup">Setup&lt;/h3>
&lt;p>BERT는 두 개의 토큰 시퀀스인 $x_1, &amp;hellip;, x_N$과 $y_1, &amp;hellip;, y_M$을 연결하여 입력으로 사용한다. 이 두 세그먼트는 특별한 토큰들로 구분되어 BERT에 하나의 입력 시퀀스로 제공된다:&lt;/p>
&lt;p>$$ [CLS], x_1, &amp;hellip;, x_N, [SEP], y_1, &amp;hellip;, y_M, [EOS]. $$&lt;/p>
&lt;p>$M$과 $N$은 $M + N &amp;lt; T$라는 제약하에 있으며, 여기서 $T$는 최대 시퀀스 길이를 제어하는 parameter이다. 모델은 대량의 레이블이 없는 텍스트 말뭉치로 사전 학습된 후, 최종 목표 레이블 데이터를 사용하여 미세 조정된다.&lt;/p>
&lt;h3 id="architecture">Architecture&lt;/h3>
&lt;p>사전 학습 동안, BERT는 masked language modeling과 next sentence prediction 두 가지 작업을 사용한다.&lt;/p>
&lt;h4 id="masked-language-model-mlm">Masked Language Model (MLM)&lt;/h4>
&lt;p>입력 시퀀스의 토큰 중 무작위로 선택된 일부가 특별한 토큰 [MASK]로 대체된다. masked language modeling 목표는 마스크된 토큰을 예측하는 것이다. 입력 토큰의 15%가 선택되어 대체되며, 이 중 80%는 [MASK]로, 10%는 그대로 두고, 나머지 10%는 임의의 어휘 토큰으로 대체된다. 이 과정은 학습 기간 동안 한 번만 수행되지만, 실제로는 데이터가 복제되어 모든 학습 문장에 동일한 마스크가 적용되지 않는다.&lt;/p>
&lt;h4 id="next-sentence-prediction-nsp">Next Sentence Prediction (NSP)&lt;/h4>
&lt;p>NSP(Next Sentence Prediction)는 원문에서 두 세그먼트가 이어지는지 예측하는 방법이다. 긍정 예시는 연속된 문장을, 부정 예시는 다른 문서의 세그먼트를 사용해 만든다. NSP 목표는 문장 쌍 간의 관계를 파악하는 자연어 추론 등의 downstream task에서 성능을 향상시키기 위해 설계되었다.&lt;/p>
&lt;h3 id="optimization">Optimization&lt;/h3>
&lt;p>BERT는 Adam 최적화를 사용하며, learning rate는 처음 10,000 step 동안 서서히 높아진 후 선형적으로 감소한다. 모든 레이어와 attention weights에 대해 0.1의 dropout을 사용하고, GELU 활성화 함수를 활용한다. 모델은 1,000,000 업데이트 동안 사전 학습되며, 최대 512 토큰의 256 시퀀스를 포함하는 미니배치를 사용한다.&lt;/p>
&lt;h3 id="data">Data&lt;/h3>
&lt;p>BERT는 총 16GB의 압축되지 않은 텍스트인 BOOK CORPUS와 영어 WIKIPEDIA 조합으로 학습된다.&lt;/p>
&lt;h2 id="experimental-setup">Experimental Setup&lt;/h2>
&lt;p>BERT의 복제 연구에 대한 실험적 설정을 설명한다.&lt;/p>
&lt;h3 id="implementation">Implementation&lt;/h3>
&lt;p>FAIRSEQ에서 BERT를 재구현하고, 대부분의 원래 BERT 최적화 hyperparameter를 따랐다. 하지만 peak learning rate과 warmup step 수는 각 설정에 따라 별도로 조정했다. 또한, Adam epsilon 항에 따라 학습이 매우 민감하며, 이를 조정하여 성능을 개선했다.&lt;/p>
&lt;h3 id="data-1">Data&lt;/h3>
&lt;p>BERT 스타일의 사전 학습은 대량의 텍스트에 크게 의존하며, 데이터 크기를 늘릴수록 최종 작업 성능이 향상될 수 있다. 이 연구에서는, 가능한 많은 데이터를 수집하여 실험을 진행하고, 각 비교에 적절한 데이터의 전체적인 품질과 양을 맞출 수 있도록 했다. 압축되지 않은 텍스트로 총 160GB를 넘는 다양한 크기와 도메인의 5개의 영어 말뭉치를 사용하였다:&lt;/p>
&lt;ul>
&lt;li>BOOK CORPUS와 영어 WIKIPEDIA. BERT를 학습시키는데 사용된 원래 데이터이다. (16GB).&lt;/li>
&lt;li>CC-N EWS, CommonCrawl News dataset의 영어 부분에서 수집한 것. 이 데이터는 2016년 9월부터 2019년 2월까지 크롤링된 6300만 개의 영어 뉴스 기사를 포함하고 있다. (필터링 후 76GB).&lt;/li>
&lt;li>OPEN WEB TEXT, WebText 코퍼스의 오픈 소스 재현, 텍스트는 Reddit에서 최소 세 번 이상의 추천을 받은 URL에서 추출된 웹 콘텐츠이다. (38GB)&lt;/li>
&lt;li>STORIES, Winograd 스키마의 스토리 같은 스타일을 맞추기 위해 필터링된 CommonCrawl 데이터의 부분 집합을 포함하고 있다. (31GB).&lt;/li>
&lt;/ul>
&lt;h3 id="evaluation">Evaluation&lt;/h3>
&lt;p>다음 세 가지 benchmark를 사용하여 사전 학습된 모델을 평가한다.&lt;/p>
&lt;h4 id="glue">GLUE&lt;/h4>
&lt;p>GLUE 벤치마크는 자연어 이해 시스템을 평가하기 위한 9개의 dataset 모음이다. 이는 단문 분류 또는 문장 쌍 분류 작업으로 구성되며, 참가자들은 제출 서버와 리더보드를 통해 자신의 시스템을 평가하고 비교할 수 있다.&lt;/p>
&lt;p>학습 데이터에서 사전 학습된 모델을 미세 조정하여 개발 세트에서 결과를 보고하였으며, 이 절차는 원래의 BERT 논문을 따른다.&lt;/p>
&lt;h4 id="squad">SQuAD&lt;/h4>
&lt;p>Stanford Question Answering Dataset(SQuAD)는 문맥과 질문을 제공하며, 작업은 문맥에서 관련 부분을 추출하여 질문에 답한다. SQuAD는 V1.1과 V2.0 두 버전이 있으며, V2.0 버전은 제공된 문맥에서 답하지 않는 질문도 포함하여 작업이 더 도전적이다.&lt;/p>
&lt;p>SQuAD V1.1에서는 BERT와 같은 방법으로 범위를 예측하며, SQuAD V2.0에서는 추가적인 이진 분류기를 사용하여 질문이 답변 가능한지를 예측한다. 이는 분류와 span loss terms를 합산하여 훈련되며, 평가 시 답변 가능으로 분류된 쌍에만 범위 인덱스를 예측한다.&lt;/p>
&lt;h4 id="race">RACE&lt;/h4>
&lt;p>ReAding Comprehension from Examinations(RACE)은 28,000개 이상의 지문과 100,000개 가까운 질문을 포함한 대규모 독해 dataset이다. 이 dataset은 중국의 중고등학생들을 대상으로 한 영어 시험에서 수집되었다. RACE에서는 각 지문에 대해 여러 질문을 풀고, 네 가지 선택지 중 정답을 고르는 작업을 수행한ㄴ다. RACE는 다른 dataset에 비해 긴 문맥을 가지고 있으며, 대부분의 질문에서 추론 능력을 요구한다.&lt;/p>
&lt;h2 id="training-procedure-analysis">Training Procedure Analysis&lt;/h2>
&lt;p>BERT 모델을 성공적으로 사전 학습하기 위해 중요한 선택 사항들을 탐색하고 정량화한다. $BERT_{BASE}$와 동일한 구성 (L = 12, H = 768, A = 12, 110M params)으로 BERT 모델을 학습한다.&lt;/p>
&lt;h3 id="static-vs-dynamic-masking">Static vs. Dynamic Masking&lt;/h3>
&lt;p>BERT는 무작위로 토큰을 마스킹하고 예측한다. 각 학습 인스턴스에서 동일한 마스크를 계속 사용하는 것을 피하기 위해, 학습 데이터를 10번 복제하여 각 시퀀스가 40회의 학습 동안 다양하게 마스킹될 수 있게 했다. 이를 모델에 시퀀스를 제공할 때마다 새로운 마스킹 패턴을 생성하는 동적 마스킹과 비교하였다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/roberta/images/table1.png"
width="590"
height="260"
srcset="https://kurtkim.github.io/p/roberta/images/table1_huefe28a59b1c5340118d249d8656f3095_34810_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/roberta/images/table1_huefe28a59b1c5340118d249d8656f3095_34810_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="226"
data-flex-basis="544px"
>&lt;/p>
&lt;p>재구현에서 정적 마스킹은 원래 BERT와 유사한 성능을 보였고, 동적 마스킹은 정적 마스킹과 비슷하거나 약간 더 좋은 성능을 보여주었다. 이 결과와 동적 마스킹의 효율성을 고려하여, 이 후 실험에서는 동적 마스킹을 사용하였다.&lt;/p>
&lt;h3 id="model-input-format-and-next-sentence-prediction">Model Input Format and Next Sentence Prediction&lt;/h3>
&lt;p>원래 BERT 사전 학습에서는 모델이 두 개의 연결된 문서 세그먼트를 관찰하며, 이들은 같은 문서에서 연속적으로 추출되거나 다른 문서에서 추출된다. 모델은 Next Sentence Prediction(NSP) loss를 통해 관찰한 문서 세그먼트가 같은 문서에서 왔는지, 다른 문서에서 왔는지 예측하도록 훈련된다.&lt;/p>
&lt;p>NSP loss의 중요성은 원래 BERT 모델 훈련에서 중요한 요소로 가정되었으며, NSP를 제거하면 성능이 저하되는 것이 관찰되었다. 그러나 최근의 일부 연구에서는 NSP loss의 필요성에 의문을 제기하였다. 이러한 차이점을 더 잘 이해하기 위해, 다양한 훈련 형식을 비교하고 있다.&lt;/p>
&lt;ul>
&lt;li>SEGMENT - PAIR + NSP: BERT의 원래 입력 형식을 따르며 NSP loss를 포함한다. 각 입력은 여러 자연스러운 문장을 포함한 세그먼트 쌍이 있으며, 총 길이는 512 토큰 이하여야 한다.&lt;/li>
&lt;li>SENTENCE - PAIR + NSP: 각 입력은 하나의 문서의 연속적인 부분 또는 별개의 문서에서 추출된 자연스러운 문장 쌍을 포함한다. 이러한 입력은 512 토큰보다 훨씬 짧으므로, 총 토큰 수가 SEGMENT - PAIR + NSP와 비슷하게 유지되도록 배치 크기를 늘린다. NSP loss는 유지된다.&lt;/li>
&lt;li>FULL - SENTENCES: 각 입력은 하나 이상의 문서에서 연속적으로 샘플링된 문장으로 채워져 있으며, 총 길이는 최대 512 토큰이다. 문서가 끝나면 다음 문서에서 샘플링을 시작하고, 문서 사이에는 추가 구분자 토큰을 넣는다. NSP loss는 제거된다.&lt;/li>
&lt;li>DOC - SENTENCES: 입력은 FULL - SENTENCES와 유사하게 구성된다. 문서 끝 부분에서 샘플링된 입력은 512 토큰보다 짧을 수 있어, 이런 경우에는 배치 크기를 동적으로 늘려 FULL SENTENCES와 같은 총 토큰 수를 유지한다. NSP loss는 제거한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://kurtkim.github.io/p/roberta/images/table2.png"
width="854"
height="448"
srcset="https://kurtkim.github.io/p/roberta/images/table2_hu68613bddb48bed701794d1b66c589053_103697_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/roberta/images/table2_hu68613bddb48bed701794d1b66c589053_103697_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="190"
data-flex-basis="457px"
>&lt;/p>
&lt;p>원래의 SEGMENT - PAIR 입력 형식과 SENTENCE - PAIR 형식을 비교했으며, 둘 다 NSP loss를 유지하되 후자는 단일 문장을 사용한다. 개별 문장 사용은 모델이 장거리 의존성을 학습하지 못함으로써 성능을 저하시킨다는 것을 발견하였다.&lt;/p>
&lt;p>NSP loss 없이 훈련과 단일 문서의 텍스트 블록을 사용한 학습(DOC - SENTENCES)을 비교했을 때, 이 설정이 $BERT_{BASE}$ 결과를 능가하며, NSP loss를 제거하면 downstream task 성능이 향상된다는 것을 발견하였다.&lt;/p>
&lt;p>마지막으로, 단일 문서의 시퀀스(DOC - SENTENCES)가 여러 문서의 시퀀스(FULL - SENTENCES)보다 약간 더 나은 성능을 보이지만, DOC - SENTENCES 형식은 배치 크기가 변동적이므로, 나머지 실험에서는 FULL SENTENCES를 사용하였다.&lt;/p>
&lt;h3 id="training-with-large-batches">Training with large batches&lt;/h3>
&lt;p>Neural Machine Translation의 이전 연구에 따르면, earning rate가 적절하게 증가할 때 아주 큰 mini-batches를 사용한 학습은 최적화 속도와 성능 모두를 개선시킬 수 있다는 것이 증명되었다. 최근의 연구는 BERT 또한 큰 배치 학습에 적합하다는 것이 밝혀졌다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/roberta/images/table3.png"
width="604"
height="194"
srcset="https://kurtkim.github.io/p/roberta/images/table3_hubaf80ecf6afab50cb0332dd70f744a28_32896_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/roberta/images/table3_hubaf80ecf6afab50cb0332dd70f744a28_32896_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="311"
data-flex-basis="747px"
>&lt;/p>
&lt;p>배치 크기를 증가시키면서 $BERT_{BASE}$의 Perplexity와 성능을 비교하였고, 큰 배치로 훈련하면 마스크 언어 모델링 목표의 Perplexity와 정확도가 향상된다는 것을 관찰했다. 또한, 큰 배치는 분산 데이터 병렬 훈련을 통해 더 쉽게 병렬화할 수 있다.&lt;/p>
&lt;h3 id="text-encoding">Text Encoding&lt;/h3>
&lt;p>Byte-Pair Encoding(BPE)는 자연어 말뭉치의 큰 어휘를 처리하기 위해 문자와 단어 수준 표현의 중간 형태를 사용한다. BPE는 훈련 말뭉치의 통계 분석을 통해 추출된 subword unit를 사용한다. byte를 사용한 BPE는, Unknown 토큰 없이도, 50K units의 서브워드 사전으로 학습을 진행할 수 있다.&lt;/p>
&lt;p>기존의 BERT는 character level의 BPE를 사용했다. RoBERTa는 추가 전처리나 토크나이징 없이 larger byte-level BPE로 학습을 진행한다.&lt;/p>
&lt;p>Byte level BPE는 몇 개의 태스크에서 성능이 떨어진다는 단점이 있지만, 성능 하락폭이 크지 않고 universal 인코딩의 장점이 있다고 판단하여 본 연구에서 Byte level BPE를 적용하였다.&lt;/p>
&lt;h2 id="roberta">RoBERTa&lt;/h2>
&lt;p>BERT 사전 학습 절차를 수정하여 end-task 성능을 향상시키는 방안을 제안한다. 이를 모두 합쳐서 그 효과를 평가한 결과, RoBERTa라는 새로운 설정이 만들어졌다. RoBERTa는 동적 마스킹, NSP loss 없는 전체 문장, 큰 미니 배치, 더 큰 바이트 수준 BPE를 사용하여 학습된다.&lt;/p>
&lt;p>또한, 사전 학습에 사용된 데이터와 데이터를 통한 학습 통과 횟수라는 두 가지 중요한 요소를 조사했다. 이를 검증하기 위해 $BERT_{LARGE}$ 아키텍처를 따라 RoBERTa를 훈련시켰고, BOOK CORPUS와 WIKIPEDIA dataset을 사용하여 100K 단계 동안 사전 학습 하였다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/roberta/images/table4.png"
width="1034"
height="498"
srcset="https://kurtkim.github.io/p/roberta/images/table4_hu5396c4466a3949f8b298043e563fba53_107966_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/roberta/images/table4_hu5396c4466a3949f8b298043e563fba53_107966_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="207"
data-flex-basis="498px"
>&lt;/p>
&lt;p>RoBERTa는 원래의 $BERT_{LARGE}$ 결과에 비해 크게 향상된 성능을 보여준다. 추가로, 다양한 데이터셋을 결합하여 훈련시킨 결과, 모든 downstream task에서 성능이 더욱 개선되었다.&lt;/p>
&lt;p>또한, 사전 학습 단계를 100K에서 300K, 그리고 500K로 늘렸을 때, downstream task 성능에서 상당한 향상을 보여주었다. 이렇게 학습된 모델들은 대부분의 작업에서 $XLNet_{LARGE}$를 능가하였다.&lt;/p>
&lt;p>마지막으로, GLUE, SQuaD, 그리고 RACE라는 세 가지 다른 benchmark에서 최적의 RoBERTa 모델을 평가하였다. 이는 모든 다섯 가지 dataset에 대해 500K 단계로 훈련된 RoBERTa를 기준으로 한 것이다.&lt;/p>
&lt;h3 id="glue-results">GLUE Results&lt;/h3>
&lt;p>GLUE에 대해 두 가지 미세 조정 설정을 고려했다. 첫 번째는 각 GLUE 작업에 대해 RoBERTa를 별도로 미세조정 했으며, 각 작업에 대한 중간 개발 세트 결과를 앙상블 없이 측정했다. 두 번째는 GLUE 리더보드를 통해 RoBERTa를 다른 모델과 비교했다. 단일 작업 미세 조정에만 의존하였다. 특히, RTE, STS, 그리고 MRPC에서는 MNLI 단일 작업 모델에서 시작하여 미세 조정 하는 것이 도움이 되었다. 각 작업에 대해 5에서 7개의 모델을 앙상블하였다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/roberta/images/table5.png"
width="1216"
height="434"
srcset="https://kurtkim.github.io/p/roberta/images/table5_huadd96c22cf129e9e57bfc748b9ec272f_127632_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/roberta/images/table5_huadd96c22cf129e9e57bfc748b9ec272f_127632_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="280"
data-flex-basis="672px"
>&lt;/p>
&lt;p>RoBERTa가 GLUE 작업 개발 세트 9개 모두에서 state-of-the-art를 달성하였다. $BERT_{LARGE}$와 동일한 구조를 사용하면서도, $BERT_{LARGE}$와 $XLNet_{LARGE}$를 능가하였다. 이는 모델 구조와 사전학습 목표 이외의 요인들이 중요할 수 있다는 점을 시사한다.&lt;/p>
&lt;p>앙상블 설정에서는, RoBERTa를 GLUE 리더보드에 제출하여 9개 작업 중 4개에서 state-of-the-art를 달성하였고, 가장 높은 평균 점수를 얻었다. 이는 RoBERTa가 다중 작업 미세 조정에 의존하지 않는다는 점에서 특히 주목할만하다.&lt;/p>
&lt;h3 id="squad-results">SQuAD Results&lt;/h3>
&lt;p>SQuAD에 대해 과거의 복잡한 접근법 대신 단순한 방법을 채택하였다. BERT와 XLNet이 추가 QA 데이터셋을 훈련 데이터에 포함시킨 반면, 이 연구에서는 제공된 SQuAD 훈련 데이터만으로 RoBERTa를 미세조정 하였다. 모든 레이어에 대해 동일한 learning rate를 사용하였다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/roberta/images/table6.png"
width="578"
height="432"
srcset="https://kurtkim.github.io/p/roberta/images/table6_hu481d86a4cd9c9a51bdc3b68dcd698e3f_79878_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/roberta/images/table6_hu481d86a4cd9c9a51bdc3b68dcd698e3f_79878_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="321px"
>&lt;/p>
&lt;p>RoBERTa는 SQuAD v1.1 개발 세트에서 XLNet과 동일한 성능을 보여주며, SQuAD v2.0에서는 XLNet을 약간 상회하는 새로운 state-of-the-art를 달성하였다.&lt;/p>
&lt;p>RoBERTa를 공개 SQuAD 2.0 리더보드에 제출했고, 추가적인 학습 데이터를 사용하지 않았음에도 불구하고, 단일 모델 제출 중 거의 모든 시스템을 능가하는 성과를 보여주었다. 데이터 증강에 의존하지 않는 시스템 중에서는 가장 높은 점수를 받았다.&lt;/p>
&lt;h3 id="race-results">RACE Results&lt;/h3>
&lt;p>RACE에서는 텍스트, 관련 질문, 네 개의 후보 답변이 제공되며, 시스템은 정답을 분류해야 한다. RoBERTa를 이 작업에 맞게 수정했으며, 각 후보 답변을 해당 질문과 텍스트에 연결하여 처리하였다. 전체 길이가 512 토큰을 초과하지 않도록 조정했다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/roberta/images/table7.png"
width="560"
height="248"
srcset="https://kurtkim.github.io/p/roberta/images/table7_hu659b09db86c53974d5e6a7a79677b569_44262_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/roberta/images/table7_hu659b09db86c53974d5e6a7a79677b569_44262_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="225"
data-flex-basis="541px"
>&lt;/p>
&lt;p>RACE 테스트 세트에서의 결과는 RoBERTa가 중학교와 고등학교 환경 모두에서 state-of-the-art를 달성하였다.&lt;/p>
&lt;h2 id="related-work">Related Work&lt;/h2>
&lt;p>다양한 사전 학습 방법들은 언어 모델링, 기계 번역, 마스킹된 언어 모델링 등의 목표를 가지고 설계되었다. 최근 연구에서는 마스킹된 언어 모델 목표를 사용해 사전 학습하고, 각 작업에 대해 모델을 미세 조정하는 방법을 사용하였다. 그러나 새로운 방법들은 다중 작업 미세 조정, 엔티티 임베딩 통합, 범위 예측, 자동회귀 사전 학습의 변형 등을 통해 성능을 향상시켰다. 일반적으로, 더 큰 모델을 더 많은 데이터로 훈련함으로써 성능이 향상되었다.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>BERT 모델을 사전 학습시키는데 있어 다양한 디자인 결정을 신중하게 평가했다. 모델을 더 오래 훈련하고, 더 큰 배치로 더 많은 데이터를 사용하며, 다음 문장 예측 목표를 제거하고, 더 긴 시퀀스를 훈련하며, 훈련 데이터에 적용된 마스킹 패턴을 동적으로 변경하면 성능이 크게 향상됨을 발견했다. 이러한 개선된 사전 학습 절차를 RoBERTa라 부르며, GLUE, RACE, SQuAD에서 state-of-the-art를 달성하였다.&lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>&lt;a class="link" href="https://arxiv.org/pdf/1907.11692.pdf" target="_blank" rel="noopener"
>Paper&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/facebookresearch/fairseq" target="_blank" rel="noopener"
>Code&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>GPT-2</title><link>https://kurtkim.github.io/p/gpt-2/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://kurtkim.github.io/p/gpt-2/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>언어 모델은 웹페이지로 구성된 새로운 데이터셋인 &amp;lsquo;WebText&amp;rsquo;으로 학습 함으로써, 질문 응답, 기계 번역 등의 작업을 명시적인 지도 없이 배우기 시작한다는 것을 발견하였다. 특히, GPT-2는 웹텍스트에 대해 underfitting이지만, zero-shot 환경에서 8개 테스트 언어 모델링 데이터셋 중 7개에서 state-of-the-art를 달성하였다. 즉, 언어 처리 시스템이 자연적 설명으로부터 과제수행능력을 배우는 언어처리모델을 개발할 수 있는 방법을 제안하였다.&lt;/p>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>기계 학습 시스템은 대규모 데이터셋, 고용량 모델, 지도 학습을 이용해 학습된 작업에서 우수한 성과를 보이지만, 데이터 분포의 작은 변화나 작업 정의에 민감하게 반응하고,매우 좁은 범위의 문제에서만 뛰어난 성능을 보여주고 있다. 그래서 보다 일반적인 문제 해결 능력을 갖춘 범용적인 모델 개발이 필요하며, 이는 결국 각각의 작업에 대해 훈련 데이터셋을 수동으로 생성하고 라벨링할 필요 없이 다양한 작업을 수행할 수 있는 모델을 의미한다.&lt;/p>
&lt;p>기계 학습 시스템을 만드는 주요한 방법은 훈련 예제를 수집하여 시스템을 학습시키고, independent and identically distributed (IID)에서 성능을 테스트하는 것이다. 이 방법은 좁은 범위의 과제에서는 잘 작동하지만, 범용적인 이해를 필요로 하는 캡션 모델, 독해, 이미지 분류 등에서 높은 성능을 내지 못했으며, 이 방법의 한계를 보여주었다.&lt;/p>
&lt;p>일반화하는 능력이 부족한 주요 원인으로 많은 연구가 단일 영역의 dataset과 단일 과제에만 맞춘 학습에만 치중되어 있기 때문이라고 보고 있다. 이를 개선하기 위해 다양한 도메인과 작업에서 훈련하고 성능을 측정하는 것이 필요하며, GLUE와 decaNLP 같은 benchmark dataset이 제안되었다.&lt;/p>
&lt;p>다중 작업 학습(Multitask learning)는 일반 성능을 향상에 높이는 유망한 방법이지만, NLP에서는 아직 초기 연구 단계이다. 최근의 기계학습 시스템의 일반화를 위해서는 수백에서 수천 개의 학습 샘플을 필요로 하며, 다중 작업 학습을 위해서도 그만큼 많은 수의 효과적인 트레이닝 쌍이 필요하다. 현재의 기술로는 dataset을 필요한 수준까지 계속 확장하는 것이 어려우며, 따라서 다중 작업 학습을 위한 새로운 접근법이 필요하다.&lt;/p>
&lt;p>현재 언어 작업에서 최고 성능을 보이는 모델은 사전 학습과 지도 학습을 결합한 방식을 사용한다. 이 접근법은 오랜 역사를 가지고 있으며, transfer 방식이 점차 유연해지고 있다. 초기에는 단어 벡터가 학습되어 특정 작업에 적용되었고, 그 다음으로는 순환 네트워크의 문맥 표현이 transfer 되었다. 최근 연구에서는 특정 작업에 특화된 아키텍처가 필요 없으며, 대신 self-attention block만으로 충분하다고 제안하고 있다.&lt;/p>
&lt;p>현재의 방법들은 작업 수행을 위해 여전히 지도 학습이 필요하다. 하지만 지도 데이터가 거의 없거나 전혀 없을 때, 언어 모델이 상식적인 추론이나 감성 분석 등의 특정 작업을 수행하는 데 잠재력이 있다는 것이 다른 연구에서 보여져 왔다.&lt;/p>
&lt;p>이 논문에서는 언어 모델이 parameter나 아키텍처 변경 없이 zero-shot setting에서 다양한 작업을 수행할 수 있는 능력을 보여준다. 이 접근법은 전이 학습의 일반화 추세를 이어가며, 작업에 따라 유망한 결과와 경쟁력 있는 성과, 그리고 state-of-the-art를 달성하는 잠재력을 보여준다.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>핵심은 언어 모델링(language modeling)이며, 이는 각 원소가 일련의 symbol $(s_1, s_2, &amp;hellip;, s_n)$ 으로 구성된 예제 $(x_1, x_2, &amp;hellip;, x_n)$ 에서 비지도분포 추정을 하는 것으로 정의된다. 언어의 순차적 특성 때문에 기호들에 대한 결합 확률은 조건부 확률의 곱으로 분해하는 것이 일반적이다.&lt;/p>
&lt;p>$$p(x) = \prod_{i=1}^n p(s_n | s_1, s_2, &amp;hellip;, s_{n-1}) $$&lt;/p>
&lt;p>이 방법은 $p(x)$ 및 $p(s_{n-k}, &amp;hellip;, s_n | s_1, &amp;hellip;, s_{s-k-1})$ 형태의 조건부의 샘플링과 추정을 가능하게 하며, 최근에는 Transformer와 같은 self-attention 아키텍처의 발전으로 이러한 조건부 확률을 계산하는 모델의 표현력이 크게 향상되었다.&lt;/p>
&lt;p>단일 작업을 수행하는 학습은 확률론적 프레임워크에서 조건부 분포 $p(output | input)$를 추정하는 것으로 볼 수 있다. 하지만 일반적인 시스템은 동일한 입력에 대해 수행해야 하는 다양한 작업을 고려해야 한다. 이를 위해, 시스템은 $p(output | input, task)$를 모델링해야 한다. 이는 다중학습과 메타학습 환경에서 다양하게 형식을 갖는다. McCann et al. (2018)은 언어를 활용하여 작업, 입력, 출력을 기호 시퀀스로 지정하는 방법을 제시하였고, 이 방법을 사용하여 MQAN이라는 단일 모델을 훈련시켜 다양한 작업을 수행할 수 있음을 보여주었다.&lt;/p>
&lt;p>언어 모델링은 출력 symbol에 대한 명시적인 지도 없이도 다양한 작업을 학습할 수 있다. 이는 감독된 학습 목표와 비감독된 학습 목표가 실질적으로 같기 때문인데, 이 두 목표의 global minimum은 동일하다. 예비 실험에서는 충분히 큰 언어 모델은 이러한 설정에서 다중 작업 학습을 수행할 수 있지만, 명시적으로 감독된 방법보다 학습 속도가 느리다는 것이 확인되었다.&lt;/p>
&lt;p>대화(dialog)의 맥락에서 자연어를 직접 학습하는 방법은 매력적인 접근법이지만, 상호작용이 필요없는 인터넷 사이트에 존재하는 방대한 양의 데이터를 활용하는 방법을 선택하였다. 충분한 용량을 가진 언어 모델은 자연어 시퀀스에서 작업을 추론하고 수행하며, 이를 통해 더 잘 예측하도록 학습할 것으로 예상된다. 모델은 비지도 다중작업 학습을 수행하게 될 것이며, 다양한 작업에서 언어 모델의 제로샷 성능을 분석하였다.&lt;/p>
&lt;h3 id="training-dataset">Training Dataset&lt;/h3>
&lt;p>이전 연구들은 주로 한정된 도메인의 텍스트를 가지고 언어 모델을 학습시켰다. 하지만 이 논문에서는 가능한 한 다양한 도메인과 맥락에서 작업을 수집하기 위해, 크고 다양한 dataset을 구축하였다.&lt;/p>
&lt;p>다양하고 방대한 텍스트의 출처로 웹 스크랩인 Common Crawl이 유망하지만, 데이터 품질 문제가 있습니다.&lt;/p>
&lt;p>이 dataset을 사용하는 대신, 문서의 품질을 중요시하는 새로운 웹 스크랩을 만들었다. 전체 웹 스크랩을 수동으로 필터링하는 비용을 줄이기 위해, 사람들이 선별한 웹 페이지를 대상으로 했다. 특히, 적어도 3 카르마를 받은 Reddit의 모든 외부 링크를 스크랩했는데, 이는 사용자들이 해당 링크를 유익하거나 재미있게 여겼는지의 지표로 볼 수 있다.&lt;/p>
&lt;p>결과적으로 나온 dataset인 WebText는 45백만 링크의 텍스트 부분집합을 포함하고 있으며, 텍스트 추출을 위해 Dragnet과 Newspaper 내용추출기를 사용하였다. 이 논문의 모든 결과는 2017년 12월 이후 링크를 제외한 초기 버전의 WebText를 사용하며, 이는 de-duplication과 cleaning 과정을 거친 후 40GB, 약 800만 개의 문서를 포함하고 있다. Wikipedia 문서는 분석을 복잡하게 할 수 있어 WebText에서 제외하였다.&lt;/p>
&lt;h3 id="input-representation">Input Representation&lt;/h3>
&lt;p>일반적인 언어 모델은 어떤 문자열의 확률도 계산하고 생성할 수 있어야 한다. 하지만 현재의 대규모 언어 모델은 전처리 과정으로 인해 모델링 가능한 문자열 범위가 제한된다. 유니코드 문자열을 UTF-8 바이트로 처리하는 것은 이를 해결하나, 현재 바이트 수준의 언어 모델은 대규모 데이터셋에서 단어 수준의 언어 모델만큼 효과적이지 않다. WebText에서 바이트 수준 언어 모델을 훈련시키려 했으나, 이와 비슷한 성능 격차를 경험하였다.&lt;/p>
&lt;p>Byte Pair Encoding(BPE)는 문자와 단어 수준 언어 모델링 사이의 중간 지점이다. 자주 나오는 symbol sequence의 단어수준 입력과 자주 나오지 않는 symbol sequence의 글자수준 입력을 적절히 보간(interpolate)한다. BPE 구현은 byte sequence가 아닌 unicode code points에서 동작한다. 이러한 구현은 모든 unicode 문자열을 모델링하기 위해 전체 unicode symbol의 전체 공간을 포함해야 한다. multi-symbol token을 추가하기 전 130,000개가 넘는 token을 포함하는 기본사전을 필요로 하게 된다. 이는 보통의 32,000개에서 64,000개의 token의 사전에 비해 지나치게 크다. 반면, byte수준의 BPE의 사전은 256개의 token만을 필요로 한다. 그러나 BPE를 byte sequence에 직접 적용하면, 토큰 어휘를 구축하기 위한 BPE의 greedy frequency 기반 heuristic 때문에 최적이 아닌 병합이 발생한다. 예를 들어, &amp;lsquo;dog&amp;rsquo;와 같은 일반적인 단어가 다양한 형태로 나타나면서 제한된 어휘 슬롯과 모델 용량이 최적화되지 않을 수 있다. 이를 해결하기 위해 byte sequence에 대해 문자 범주를 넘어서 병합하는 것을 방지하고, 공백에 대한 예외를 추가하여 압축 효율을 향상시키고 단어의 분열을 최소화하였다.&lt;/p>
&lt;p>이 입력 표현법은 단어 수준 언어 모델의 이점과 byte 수준 접근법의 범용성을 결합시킨다. 이러한 접근법은 어떤 unicode 문자열에도 확률을 부여할 수 있으므로, 사전 처리, 토큰화, 어휘 크기와 관계없이 모든 데이터셋에서 언어 모델을 평가할 수 있다.&lt;/p>
&lt;h3 id="model">Model&lt;/h3>
&lt;p>Transformer 기반 아키텍처를 사용하며, 이는 주로 OpenAI GPT 모델을 따른다. 몇 가지 수정사항은 레이어 정규화의 위치 변경, 추가적인 레이어 정규화의 삽입, 모델 깊이를 고려한 초기화 방식의 수정, 그리고 잔여 레이어 가중치의 스케일링이다. 또한, 어휘는 50,257개로 확장되었고, 맥락 크기와 배치 크기도 각각 1024 토큰과 512로 증가시켰다.&lt;/p>
&lt;h2 id="experiments">Experiments&lt;/h2>
&lt;p>&lt;img src="https://kurtkim.github.io/p/gpt-2/images/table2.png"
width="356"
height="188"
srcset="https://kurtkim.github.io/p/gpt-2/images/table2_hu4052d405d8c00af53725ab1cc3558100_19621_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/gpt-2/images/table2_hu4052d405d8c00af53725ab1cc3558100_19621_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="189"
data-flex-basis="454px"
>&lt;/p>
&lt;p>크기별로 네 개의 언어 모델을 훈련시키고 벤치마킹하였다. 가장 작은 모델의 크기는 원래의 GPT와 같으며, 두 번째로 작은 모델은 BERT의 가장 큰 모델과 같다. 가장 큰 모델인 GPT-2는 GPT보다 10배 이상 많은 parameter를 가지고 있다. 각 모델의 learning rate는 WebText의 5%인 held-out 샘플을 사용하여 수동 조정하으며, 모든 모델은 여전히 WebText에 underfitted 되었으며 더 오래 학습시키면 더 높은 성능을 얻을 수 있을 것이다.&lt;/p>
&lt;h3 id="language-modeling">Language Modeling&lt;/h3>
&lt;p>GPT-2 모델은 문자 단위(byte level)에서 작동하고, 손실이 큰 전처리나 토큰화가 필요 없으므로 모든 언어 모델 benchmark에서 평가할 수 있다. WebText 언어 모델에 따른 dataset의 로그-확률을 계산하는 방식으로 평가 하였다. WebText 언어 모델은 표준화된 텍스트, 토큰화 유물, 섞인 문장, &lt;!-- raw HTML omitted --> 문자열(40 billion 바이트 중 26번만 발생) 등을 예측해야 하기 때문에 많은 데이터셋에서 일반 분포 밖에서 테스트되어야 한다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/gpt-2/images/table3.png"
width="1302"
height="248"
srcset="https://kurtkim.github.io/p/gpt-2/images/table3_hu0672219cf8c312417ec05fb807289e43_62928_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/gpt-2/images/table3_hu0672219cf8c312417ec05fb807289e43_62928_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="525"
data-flex-basis="1260px"
>&lt;/p>
&lt;p>WebText 언어 모델은 도메인과 데이터셋 간에 잘 transfer되며, zero-shot setting에서 8개의 dataset 중 7개에서 state-of-the-art를 달성하였다.&lt;/p>
&lt;h3 id="childrens-book-test">Children’s Book Test&lt;/h3>
&lt;p>Children’s Book Test(CBT)는 다양한 카테고리의 단어에 대한 언어 모델의 성능을 평가하기 위한 테스트로, 생략된 단어에 대한 10개의 가능한 선택 중 올바른 것을 예측한다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/gpt-2/images/figure2.png"
width="632"
height="342"
srcset="https://kurtkim.github.io/p/gpt-2/images/figure2_hucc3cfd28bfd28dab2bf32e81236256ba_62137_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/gpt-2/images/figure2_hucc3cfd28bfd28dab2bf32e81236256ba_62137_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="443px"
>&lt;/p>
&lt;p>모델 크기가 증가함에 따라 성능이 지속적으로 개선되며, GPT-2는 일반 명사에서 93.3%, 개체명에서 89.1%의 성능을 달성하였다.&lt;/p>
&lt;h3 id="lambada">LAMBADA&lt;/h3>
&lt;p>LAMBADA dataset은 텍스트의 장거리 의존성(long-range dependencies)을 평가한다. GPT-2는 이 테스트에서의 perplexity를 99.8에서 8.6으로, 정확도를 19%에서 52.66%로 향상시켰다. 추가적으로, stop-word ﬁlter를 추가함으로써 정확도를 63.24%로 더욱 향상시켰다.&lt;/p>
&lt;h3 id="winograd-schema-challenge">Winograd Schema Challenge&lt;/h3>
&lt;p>&lt;img src="https://kurtkim.github.io/p/gpt-2/images/figure3.png"
width="620"
height="466"
srcset="https://kurtkim.github.io/p/gpt-2/images/figure3_hue70bf388100cd8d57dc0d6c9817d7a6c_53535_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/gpt-2/images/figure3_hue70bf388100cd8d57dc0d6c9817d7a6c_53535_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="319px"
>&lt;/p>
&lt;p>Winograd Schema Challenge는 텍스트의 모호성을 해결하는 능력을 통해 시스템의 상식적 추론 능력을 측정하고자 한다. GPT-2는 정확도를 7% 향상시켜 70.70%를 달성하였다.&lt;/p>
&lt;h3 id="reading-comprehension">Reading Comprehension&lt;/h3>
&lt;p>CoQA(The Conversation Question Answering dataset)는 7가지 다른 분야의 문서와 문서에 대한 질문자-답변자 사이의 자연어 대화가 쌍을 이루고 있다. CoQA 테스트는 독해능력과 대화에 기반한 모델의 답변능력을 평가한다. GPT-2는 미세조정 없이 55 F1 score를 달성해 4개 중 3개의 다른 모델을 능가하였다.&lt;/p>
&lt;h3 id="summarization">Summarization&lt;/h3>
&lt;p>GPT-2의 요약 능력은 CNN과 Daily Mail dataset을 사용해서 테스트했다. 문서 이후에 &amp;ldquo;TL;DR:&amp;rdquo; 토큰을 추가하고 Top-k 랜덤 샘플링을 통해 요약을 유도했다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/gpt-2/images/table4.png"
width="572"
height="236"
srcset="https://kurtkim.github.io/p/gpt-2/images/table4_hu04688c90c05b2df30841db6bc90a452e_40450_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/gpt-2/images/table4_hu04688c90c05b2df30841db6bc90a452e_40450_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="242"
data-flex-basis="581px"
>&lt;/p>
&lt;p>처음 생성된 3개의 문장을 요약 결과로 하여 실험한 결과, 기사의 최근 내용에 초점을 맞추거나 특정 세부사항을 혼동하는 경향이 있다. &amp;ldquo;TL;DR:&amp;rdquo; 토큰 없이 실험한 경우, 성능이 더 하락한 것을 보면 힌트를 통한 Task 유도가 유의한 결과를 냄을 확인할 수 있었다.&lt;/p>
&lt;h3 id="translation">Translation&lt;/h3>
&lt;p>번역 능력은 WMT-14 English-French dataset을 사용해서, 영어-프랑스어, 프랑스어-영어 두가지 경우에서 비교가 진행되었다. 번역 성능은 다른 Task에 비해 좋지 상대적으로 좋지 않다. 영어-프랑스어 테스트에서 5 BLEU를, 프랑스어-영어 테스트에서는 11.5 BLEU를 달성했다.&lt;/p>
&lt;h3 id="question-answering">Question Answering&lt;/h3>
&lt;p>언어 모델에 얼마나 많은 정보가 들어있는지 테스트하기 위해 factoid-style의 질문에 얼마나 정확한 답을 생성하는지 평가한다. Natural Questions dataset을 이용해 GPT-2의 성능을 평가하였고 &amp;lsquo;정확히 일치 하는지&amp;rsquo; 여부(exact match metric)를 지표로 비교한다. 질문의 4.1%에 대해 올바르게 답을 하였고, 이는 기존의 모델들보다 5.3배 높은 정확도이다. 매우 작은 모델들은 대체로 1%를 넘지 못하는 성능을 보였는데, 아직까지는 모델의 크기가 QA에 있어서 매우 중요한 요인이라는 것을 확인할 수 있었다. 또한, 가장 확신하는 1%의 질문에 대해 63.1%의 정확도를 보였지만, 이는 여전히 정보 검색과 문서 질문 답변 추출을 결합한 시스템의 30%에서 50% 범위의 성능보다 훨씬 떨어진다.&lt;/p>
&lt;h2 id="generalization-vs-memorization">Generalization vs Memorization&lt;/h2>
&lt;p>최근 연구에 따르면, 일반적인 이미지 데이터셋에는 상당한 양의 중복된 이미지가 포함되어 있어, 기계 학습 시스템의 일반화 성능을 과대평가하게 만든다. 데이터셋의 크기가 커질수록 이 문제는 더욱 심화될 가능성이 있으며, 이는 테스트 데이터가 얼마나 훈련 데이터에도 포함되어 있는지 분석하는 것이 중요함을 의미한다.&lt;/p>
&lt;p>이를 연구하기 위해, WebText 훈련 데이터의 8-gram을 포함하는 Bloom 필터를 생성하였고, 주어진 데이터셋에 대해 그 데이터셋의 8-gram 중 얼마나 많은 비율이 WebText 훈련 세트에도 포함되어 있는지를 계산하였다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/gpt-2/images/table6.png"
width="892"
height="144"
srcset="https://kurtkim.github.io/p/gpt-2/images/table6_hu172470c92ab1f519e4f88f1f5948b68f_30103_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/gpt-2/images/table6_hu172470c92ab1f519e4f88f1f5948b68f_30103_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="619"
data-flex-basis="1486px"
>&lt;/p>
&lt;p>일반적인 언어 모델 데이터셋의 테스트 세트는 WebText 훈련 세트와 1-6%의 중복을 가지며, 평균 중복률은 3.2%이다. 많은 데이터셋은 자신의 훈련 분할과 더 큰 중복을 가지며, 평균 중복률은 5.9%이다.&lt;/p>
&lt;p>데이터 중복을 최소화하는 방향으로 접근하였으며, 이러한 중복이 성능에 작은, 하지만 일관적인 향상을 가져다 준다는 분석 결과를 얻었다. 중복 제거 기법을 개선함으로써 이러한 문제에 대해 더욱 효과적으로 대응할 수 있다. 그리고 이러한 중복 제거 과정에서는 n-gram 중첩 기반의 방법을 활용하는 것이 중요하다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/gpt-2/images/figure4.png"
width="626"
height="572"
srcset="https://kurtkim.github.io/p/gpt-2/images/figure4_hu6224d7555cf4d52f787f03ba1e304417_70891_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/gpt-2/images/figure4_hu6224d7555cf4d52f787f03ba1e304417_70891_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="109"
data-flex-basis="262px"
>&lt;/p>
&lt;p>또한, WebText 언어 모델의 성능이 기억력에 의존하는지를 확인하기 위해 해당 모델이 자체 테스트 세트에서 어떤 성능을 보이는지 검사하였다. 이 결과, 모델 크기가 커짐에 따라 훈련 세트와 테스트 세트에서의 성능이 함께 향상되는 경향을 보였으며, 이로부터 GPT-2가 WebText에 대해 완벽하게 적합하지 않음을 추측할 수 있다.&lt;/p>
&lt;p>마지막으로, GPT-2가 말하는 유니콘의 발견에 대한 뉴스 기사를 작성하는 능력을 보여주었다. 이는 GPT-2의 창의성을 보여주는 한 예로 볼 수 있다.&lt;/p>
&lt;h2 id="related-work">Related Work&lt;/h2>
&lt;p>이 연구는 더 큰 dataset에서 학습된 큰 언어 모델의 성능을 측정하는 데 중점을 두었다. 이 연구는 이전 연구와 비슷한 방향성을 가지고 있으며, 우리의 실험 결과는 주어진 목표의 세부 작업에 대한 추세가 큰 파라미터 범위로도 지속되는 것을 확인하였다.&lt;/p>
&lt;p>생성 모델에서는 RNN 언어 모델이 줄 너비를 추적하고 인용문이나 댓글을 감지하는 등의 흥미로운 기능을 배우는 것이 확인되었다. 또한, 위키백과 기사를 생성하도록 훈련된 모델이 언어 간 이름 번역을 배울 수 있음이 관찰되었다.&lt;/p>
&lt;p>iWeb Corpus같이 웹 페이지의 대형 텍스트 말뭉치를 필터링하고 구성하는 다양한 방법, 모든 단어 벡터 표현 학습을 확대하거나, 기계 번역 모델에서 파생된 표현의 사용을 탐색하는 사전학습 방법, seq2seq 모델 등이 연구 되었고, 언어모델의 사전학습이 잡담이나 대화 같은 어려운 생성문제에 맞춰 미세조정할 때 도움이 된다는 것을 밝혀내었다.&lt;/p>
&lt;h2 id="discussion">Discussion&lt;/h2>
&lt;p>비지도 사전 학습 방법의 표현에 대한 많은 연구가 있었으며, 이는 비지도 학습이 유망한 연구 영역임을 시사한다. GPT-2는 독해에 대해 경쟁력 있는 성능을 보였지만, 요약 등의 작업에 대해서는 아직 기본적인 수준에 불과하다. 많은 NLP 작업에서 GPT-2의 제로샷 성능을 연구했지만, 아직 많은 실용적인 작업에서는 성능이 무작위 수준에 불과한 경우가 많다. 제로샷 성능은 GPT-2의 잠재적 성능의 기준을 설정하지만, 미세 조정을 통한 성능의 상한선은 아직 불분명하다. 더욱이, GPT-2의 추가 훈련 데이터와 용량이 단방향 표현의 비효율성을 극복하기에 충분한지는 아직 불확실하다.&lt;/p>
&lt;p>decaNLP나 GLUE와 갈은 benchmark에서 미세조정 할 것을 계획하고 있으며, GPT-2의 학습데이터와 그 크기가 BERT에서 말한 단방향 표현의 비효율성을 극복할 수 있을 만큼 충분한지도 확실치 않다고 한다.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>충분히 크고 다양한 dataset으로 학습된 큰 언어 모델인 GPT-2는 여러 도메인과 데이터셋에서 잘 수행하며, 테스트된 8개 언어 모델링 dataset 중 7개에서 state-of-the-art를 달성하였다. 이는 고용량 모델이 다양한 텍스트에 대한 가능성을 극대화하는 훈련을 통해, 명확한 지도 없이도 많은 작업을 수행하는 법을 배우기 시작한다는 것을 시사한다.&lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>&lt;a class="link" href="https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf" target="_blank" rel="noopener"
>Paper&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/openai/gpt-2" target="_blank" rel="noopener"
>Code&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>BERT</title><link>https://kurtkim.github.io/p/bert/</link><pubDate>Sat, 30 Dec 2023 00:00:00 +0000</pubDate><guid>https://kurtkim.github.io/p/bert/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>BERT(Bidirectional Encoder Representations from Transformers)는 Transformer의 양방향 인코더 표현을 사용하는 언어모델로, BERT는 레이블이 없는 텍스트에서 깊은 양방향 표현을 사전 학습함으로써, 하나의 출력 레이어만을 추가해서 다양한 작업에 맞게 미세조정 할 수 있다. 이 모델은 개념적으로 단순하면서도 실증적으로 강력하며, 다양한 자연어 처리 작업에서 새로운 최고 수준의 결과를 달성하였다.&lt;/p>
&lt;hr>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>언어 모델의 사전 학습은 다양한 자연어 처리 작업의 향상에 크게 기여하였다. 이는 문장 전체를 분석하여 문장 간 관계를 예측하는 자연어 추론이나 재구성과 같은 문장 수준의 작업뿐만 아니라, 명명된 개체 인식이나 질문 응답과 같이 토큰 수준의 작업을 포함한다.&lt;/p>
&lt;p>사전 학습된 모델을 downstream tasks에 적용하는 데는 두 가지 전략이 있다: feature-based와 미세조정(fine-tuning)이다. feature-based 접근법은 ELMo와 같이 사전 훈련된 표현을 추가 특성으로 사용하고, 미세 조정 접근법은 GPT와 같이 작업 특정 파라미터를 최소화하고 사전 훈련된 모든 파라미터를 미세 조정한다. 이 두가지 접근 방식은 사전 학습을 하는동안 같은 목적 함수를 공유하며, 일반적인 언어 표현을 학습하기 위해 단방향 언어 학습 모델을 사용한다.&lt;/p>
&lt;p>현재의 기술들은 특히 미세 조정 접근법에 대해 사전 학습된 표현의 가능성을 제한한다고 주장한다. 표준 언어 모델이 단방향적이므로, 사전 훈련 동안 사용할 수 있는 아키텍처가 제한되기 때문이다. OpenAI GPT의 경우, 모든 토큰이 이전 토큰만을 주목하는 &amp;lsquo;왼쪽에서 오른쪽으로&amp;rsquo;의 아키텍처를 사용한다. 이러한 제한은 문장 수준 작업이나 양방향 맥락 통합이 중요한 토큰 수준 작업에 대해 불리하다.&lt;/p>
&lt;p>이 논문에서는 BERT(Bidirectional Encoder Representations from Transformers)를 제안하여 미세 조정 기반 접근법을 개선한다. BERT는 일부 토큰을 무작위로 마스크한 &amp;ldquo;masked language model&amp;quot;을 사용하여 단방향성 제약을 완화하고, 이를 통해 깊은 양방향 Transformer를 사전 학습한다. 그리고 &amp;ldquo;next sentence prediction&amp;rdquo; 작업을 통해 텍스트 쌍 표현을 함께 사전 학습한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>언어 표현에 대한 양방향 사전 훈련의 중요성을 강조한다. BERT는 마스크된 언어 모델을 사용해 깊은 양방향 표현을 사전 학습하는데, 이는 단방향 언어 모델을 사용하는 기존 방법과 대조적이다. 또한, 독립적으로 훈련된 언어 모델을 얕게 연결하는 방식과도 차별화된다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>사전 학습된 표현은 작업별 아키텍처의 필요성을 줄이며, BERT는 다양한 작업에서 최고 수준의 성능을 달성하는 첫 미세 조정 기반 표현 모델이다. 이는 다수의 작업별 아키텍처들의 성능을 능가한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BERT는 11가지 자연어 처리(NLP) 작업에 대해 state-of-the-art 성능을 달성했다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="related-work">Related Work&lt;/h2>
&lt;p>일반적인 언어 표현을 사전 학습하는 것은 오랜 역사를 가지고 있으며, 이 섹션에서는 가장 널리 사용되는 접근법들을 간략하게 검토한다.&lt;/p>
&lt;h3 id="unsupervised-feature-based-approaches">Unsupervised Feature-based Approaches&lt;/h3>
&lt;p>단어의 범용적인 표현 학습은 비신경망 및 신경망 방법을 포함한 여러 연구의 주제였다. 사전 학습된 단어 임베딩은 현대 NLP 시스템의 핵심 부분이며, 처음부터 학습된 임베딩보다 크게 개선된다. 단어 임베딩 벡터를 사전 훈련하기 위해, 언어 모델링 목표와 맥락에서 단어를 구별하는 목표가 사용되었다.&lt;/p>
&lt;p>이러한 접근법은 문장이나 문단 임베딩 등의 더 큰 단위로 확장되었다. 문장 표현을 훈련시키기 위해, 후보 다음 문장을 순위 매기는 연구, 이전 문장의 표현을 기반으로 다음 문장의 단어를 생성하는 연구, 또는 노이즈 제거 오토인코더에서 파생된 연구 등이 있었다.&lt;/p>
&lt;p>ELMo와 그 전임자는 단어 임베딩 연구를 다른 차원으로 확장해, 맥락에 따라 변하는 특징을 추출하였다. 이는 언어 모델의 왼쪽과 오른쪽 표현을 연결해 이루어진다. ELMo는 이를 기존의 작업 특정 아키텍처와 결합해 주요 NLP 벤치마크를 향상시켰다. 또한, 다른 연구들은 LSTM을 이용해 맥락적 표현을 학습하거나, 클로즈 작업을 통해 텍스트 생성 모델의 견고성을 향상시키는 방법을 제안하였다.&lt;/p>
&lt;h3 id="unsupervised-fine-tuning-approaches">Unsupervised Fine-tuning Approaches&lt;/h3>
&lt;p>첫 번째 연구들은 레이블이 없는 텍스트에서 단어 임베딩 파라미터만 사전 학습하였다.&lt;/p>
&lt;p>최근에는 문장이나 문서 인코더가 레이블이 없는 텍스트에서 사전 훈련되고, 지도학습의 다음 작업을 위해 미세조정되었다. 이 방법의 장점은 적은 양의 파라미터만 처음부터 학습하면 된다는 것이며, 이 때문에 OpenAI GPT는 여러 문장 수준 작업에서 최고 성능을 달성하였다. 이러한 모델을 사전 학습하기 위해 왼쪽에서 오른쪽으로의 언어 모델링과 오토인코더가 사용되었다.&lt;/p>
&lt;h3 id="transfer-learning-from-supervised-data">Transfer Learning from Supervised Data&lt;/h3>
&lt;p>대규모 데이터셋을 가진 자연어 추론과 기계 번역 등의 감독 학습 작업에서 효과적인 전이 학습이 보여주었다. 또한, 컴퓨터 비전 연구에서는 ImageNet으로 사전 훈련된 대규모 모델을 미세조정하여 전이 학습의 중요성을 입증하였다.&lt;/p>
&lt;hr>
&lt;h2 id="bert">BERT&lt;/h2>
&lt;p>&lt;img src="https://kurtkim.github.io/p/bert/images/figure1.png"
width="1218"
height="514"
srcset="https://kurtkim.github.io/p/bert/images/figure1_hu00f70a8ca5c71ceb6a922a072bdffe29_165193_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/bert/images/figure1_hu00f70a8ca5c71ceb6a922a072bdffe29_165193_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="236"
data-flex-basis="568px"
>&lt;/p>
&lt;p>BERT는 사전 학습과 미세 조정 두 단계로 이루어진다. 사전 학습에서는 레이블이 없는 데이터로 모델을 학습하며, 미세 조정에서는 사전 훈련된 파라미터로 초기화된 BERT 모델을 downstream tasks의 레이블이 붙은 데이터로 미세 조정한다. 각 downstream tasks는 동일한 사전 훈련된 파라미터로 초기화되지만 별도의 미세 조정된 모델을 가진다.&lt;/p>
&lt;p>BERT는 다양한 작업에 걸친 통일된 아키텍처이며, 사전 학습된 아키텍처와 최종 downstream tasks 아키텍처 사이에는 거의 차이가 없다.&lt;/p>
&lt;h3 id="model-architecture">Model Architecture&lt;/h3>
&lt;p>BERT의 구조는 다중 레이어 양방향 Transformer 인코더로, Transformer의 널리 쓰이는 사용과 거의 동일하기 때문에, 모델 아키텍처의 상세한 설명은 &amp;ldquo;The Annotated Transformer&amp;quot;를 참조하도록 권장한다.&lt;/p>
&lt;p>이 연구에서는 레이어의 개수(Transformer 블록)를 $L$, 은닉의 크기를 $H$, self-attention 헤드 수를 $A$로 표시한다. $BERT_{BASE}$ (L=12, H=768, A=12, Total Parameters=110M)와 $BERT_{LARGE}$ (L=24, H=1024, A=16, Total Parameters=340M)의 두 모델 사이즈에 대한 결과를 비교한다.&lt;/p>
&lt;p>비교를 위해 $BERT_{BASE}$는 같은 모델 사이즈인 OpenAI GPT와 비교하였다. 그러나 중요한 점은, BERT Transformer는 양방향 self-attention을 사용하는 반면, GPT Transformer는 각 토큰이 왼쪽의 컨텍스트에만 주의를 기울일 수 있는 제한된 self-attention을 사용한다.&lt;/p>
&lt;h3 id="inputoutput-representations">Input/Output Representations&lt;/h3>
&lt;p>BERT의 입력 표현은 단일 문장과 문장 쌍(예: 〈질문, 답변〉)을 하나의 토큰 시퀀스에서 명확하게 표현할 수 있다. 여기서 &amp;ldquo;문장(senetence)&amp;ldquo;은 실제 문장이 아닌 텍스트의 일부를, &amp;ldquo;시퀀스(sequence)&amp;ldquo;는 BERT 입력 토큰을 의미하며, 이는 하나 또는 두 개의 문장일 수 있다.&lt;/p>
&lt;p>30,000개의 토큰 단어를 가진 WordPiece임베딩을 사용하며, 모든 문장의 첫번째 토큰은 특별한 분류 토큰([CLS])으로 시작한다. 이 토큰에 해당하는 마지막 은닉 상태(hidden state)는 분류 작업을 위해 총 시퀀스 표현으로 사용된다. 문장 쌍은 하나의 시퀀스로 묶이며, 특별한 토큰([SEP])과 학습된 임베딩을 사용해 문장을 구분한다. 입력 임베딩은 $E$로, [CLS] 토큰과 i번째 입력 토큰의 최종 은닉 벡터는 각각 $C \in R^H$, $T_i \in R^H$ 로 표기한다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/bert/images/figure2.png"
width="984"
height="308"
srcset="https://kurtkim.github.io/p/bert/images/figure2_hu31d588c51731c5786afe5c3c0605896d_67252_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/bert/images/figure2_hu31d588c51731c5786afe5c3c0605896d_67252_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="319"
data-flex-basis="766px"
>&lt;/p>
&lt;p>주어진 토큰에 대한 입력 표현은 해당 토큰, 세그먼트, 위치 임베딩을 합하여 구성된다.&lt;/p>
&lt;h3 id="pre-training-bert">Pre-training BERT&lt;/h3>
&lt;p>BERT를 사전 학습하기 위해 전통적인 왼쪽에서 오른쪽 또는 오른쪽에서 왼쪽으로의 언어 모델을 사용하지 않았으며, 두 가지 비지도 학습 작업을 사용하여 BERT를 사전 학습하였다.&lt;/p>
&lt;h4 id="task-1-masked-lm">Task #1: Masked LM&lt;/h4>
&lt;p>깊은 양방향 모델은 왼쪽에서 오른쪽 혹은 오른쪽에서 왼쪽 모델보다 강력하다는 것이 직관적이다. 하지만, 표준 언어 모델은 양방향 조건을 적용하면 각 단어가 간접적으로 자신을 &amp;lsquo;볼&amp;rsquo; 수 있게 되어, 모델이 문맥 속의 목표 단어를 쉽게 예측할 수 있게 되므로, 왼쪽에서 오른쪽 또는 오른쪽에서 왼쪽으로만 훈련된다.&lt;/p>
&lt;p>깊은 양방향 표현을 훈련하기 위해, 입력 토큰의 일부를 무작위로 마스킹하고 그 마스킹된 토큰들을 예측하는 &amp;lsquo;Masked LM&amp;rsquo; 방법을 사용한다. 이 방법은 Cloze 작업으로 불리기도 한다. 마스킹된 토큰에 해당하는 최종 은닉 벡터는 어휘에 대한 출력 softmax에 공급되며, 모든 실험에서 각 시퀀스의 15% 토큰을 무작위로 마스킹한다. 이 방법은 denoising auto-encoders와 달리 마스킹된 단어만을 예측한다.&lt;/p>
&lt;p>양방향 사전 학습 모델을 얻는 방법은 [MASK] 토큰이 미세 조정 과정에서 나타나지 않는 문제로 인해 사전 훈련과 미세 조정 사이에 불일치를 유발한다. 이를 완화하기 위해, &amp;ldquo;마스킹된&amp;rdquo; 단어를 항상 [MASK] 토큰으로 교체하지 않는다. 토큰 위치의 15%를 임의로 선택하고, 선택된 토큰은 80% 확률로 [MASK] 토큰, 10% 확률로 임의의 토큰, 10% 확률로 원래 토큰으로 교체한다. 그 후, 크로스 엔트로피 손실을 사용하여 원래 토큰을 예측한다.&lt;/p>
&lt;h4 id="task-2-next-sentence-prediction-nsp">Task #2: Next Sentence Prediction (NSP)&lt;/h4>
&lt;p>질문 응답(QA)과 자연어 추론(NLI) 같은 작업들은 두 문장 간의 관계를 이해하는 것에 기초하며, 이는 언어 모델링만으로는 직접적으로 캡처할 수 없다. 이를 해결하기 위해, 문장간 관계를 이해하는 모델을 위한 사전 훈련 과정에서, 어떤 하나의 언어를 사용하는 말뭉치로부터 생성될 수 있는 다음 문장 예측 과제를 2진화(binarized)된 다음 문장 예측 작업을 한다. 구체적으로, 각 사전 훈련 예제에서, 선택된 두 문장 A와 B는 50%의 확률로 실제 연속하는 문장이며, 나머지 50%는 말뭉치에서 임의로 선택된 문장이다. 이 간단한 방법이 QA와 NLI에 큰 도움이 된다는 것을 입증하였다.&lt;/p>
&lt;p>다음 문장 예측(NSP) 작업은 이전 연구와 밀접한 관련이 있지만, 이전 연구에서는 문장 임베딩만을 하위 작업에 전달했으나, BERT는 모든 매개변수를 최종 작업 모델 초기화에 사용한다.&lt;/p>
&lt;h4 id="pre-training-data">Pre-training data&lt;/h4>
&lt;p>사전 학습 절차는 대부분 언어 모델 사전 학습에 대한 기존 연구를 따른다. 이때 사용되는 말뭉치는 BooksCorpus(800M개의 단어)와 영어 위키백과(2,500M개의 단어)이다. 위키백과에서는 텍스트 부분만 추출하며, 긴 연속적인 시퀀스를 추출하기 위해 문장 수준이 아닌 문서 수준의 말뭉치 사용이 중요하다는 점을 강조한다.&lt;/p>
&lt;h3 id="fine-tuning-bert">Fine-tuning BERT&lt;/h3>
&lt;p>Transformer의 자기 self-attention mechanism을 활용한 BERT의 미세 조정은 단일 텍스트나 텍스트 쌍을 포함한 다양한 downstream tasks를 모델링하는데 효과적이다. 텍스트 쌍을 독립적으로 인코딩한 후 양방향 cross attention을 적용하는 것이 일반적이지만, BERT는 이 두 단계를 통합하여 self-attention으로 텍스트 쌍을 인코딩함으로써 두 문장 간의 양방향 cross attention을 효과적으로 포함시킨다.&lt;/p>
&lt;p>각 작업마다 BERT에 작업 특정 입력과 출력을 연결하고 모든 매개변수를 미세 조정한다. 입력에서, 사전 훈련된 문장 A와 B는 다양한 작업(표현 변경, 함축, 질문 답변, 텍스트 분류 등)의 입력 쌍에 상응한다. 출력에서, 토큰 표현은 토큰 수준 작업에, [CLS] 표현은 분류 작업에 사용된다.&lt;/p>
&lt;p>미세 조정은 사전 훈련에 비해 상대적으로 저렴하며, 이 논문의 모든 결과는 동일한 사전 훈련 모델을 기반으로 클라우드 TPU에서는 1시간, GPU에서는 몇 시간 안에 재현 가능하다.&lt;/p>
&lt;h2 id="experiments">Experiments&lt;/h2>
&lt;p>11가지 자연어 처리(NLP) 작업에 대한 BERT 미세 조정 결과를 보여준다.&lt;/p>
&lt;h3 id="glue">GLUE&lt;/h3>
&lt;p>General Language Understanding Evaluation(GLUE) benchmark는 다양한 자연어 이해 작업의 모음이다.&lt;/p>
&lt;p>GLUE에서 미세 조정을 하기 위해, 입력 시퀀스를 표현하고 첫 번째 입력 토큰([CLS])에 대응하는 최종 벡터를 종합 표현으로 사용한다. 미세 조정시 도입되는 유일한 새로운 매개변수는 분류 레이어의 가중치이다. 그리고 이들을 사용해 standard classiﬁcation 손실을 계산한다.&lt;/p>
&lt;p>batch size 32로 데이터를 3 epoch 동안 미세 조정한다. 각 작업마다 최적의 미세 조정 학습률을 선택하며, $BERT_{LARGE}$는 작은 데이터셋에서 불안정할 때 랜덤 재시작을 사용하여 최적의 모델을 선택한다. 랜덤 재시작에서는 동일한 사전 학습 체크포인트를 사용하지만 데이터 셔플링과 분류기 레이어 초기화는 다르게 합니다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/bert/images/table1.png"
width="1230"
height="272"
srcset="https://kurtkim.github.io/p/bert/images/table1_huf3a07f0fefdef490b04f70f7c1b26705_79420_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/bert/images/table1_huf3a07f0fefdef490b04f70f7c1b26705_79420_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="452"
data-flex-basis="1085px"
>&lt;/p>
&lt;p>$BERT_{BASE}$와 $BERT_{LARGE}$는 모든 작업에서 월등한 성능을 보여주며, 평균 정확도를 각각 4.5%, 7.0% 향상시켰다. 가장 큰 GLUE 작업인 MNLI에서 BERT는 정확도를 4.6% 향상시켰고, 공식 GLUE 리더보드에서는 $BERT_{LARGE}$가 80.5의 점수로 OpenAI GPT의 72.8을 능가했다.&lt;/p>
&lt;p>$BERT_{LARGE}$가 모든 작업에서 $BERT_{BASE}$를 크게 능가하며, 특히 훈련 데이터가 매우 적은 작업에서 그렇다는 것을 발견하였다.&lt;/p>
&lt;h3 id="squad-v11">SQuAD v1.1&lt;/h3>
&lt;p>The Stanford Question Answering Dataset (SQuAD v1.1)는 10만 개의 크라우드 소싱 질문/답변 쌍의 컬렉션이다. 주어진 질문과 답변을 포함하는 위키백과의 문단이 주어지면, 그 문단 내에서 실제 답변의 위치나 범위를 정확하게 예측하는 것이 목표이다.&lt;/p>
&lt;p>질문 응답 작업에서는 입력 질문과 문단을 하나의 연결된 시퀀스로 표현하며, 각각 다른 임베딩을 사용한다. 미세 조정 과정에서는 시작과 끝 벡터만 추가적으로 도입되며, 답변의 시작 단어 확률은 해당 단어와 시작 벡터 간의 내적 후 softmax를 적용하여 계산된다.&lt;/p>
&lt;p>답변 범위의 시작과 끝 위치를 예측하는 공식이 사용되며, 그 중 최대 점수를 가진 범위가 최종 예측값이 된다. 훈련 목표는 정확한 시작과 끝 위치의 로그 가능도 합이며, learning rate 5e-5와 batch size 32로 3 epoch 동안 미세 조정이 이루어진다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/bert/images/table2.png"
width="548"
height="488"
srcset="https://kurtkim.github.io/p/bert/images/table2_huc28c19d0056a77485b24c6c1b636d127_93131_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/bert/images/table2_huc28c19d0056a77485b24c6c1b636d127_93131_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
>&lt;/p>
&lt;p>BERT 모델은 다른 공개 데이터를 사용하여 학습된 모델들을 뛰어넘으며, 특히 TriviaQA에 먼저 미세 조정을 함으로써 성능을 향상시켰다. 단일 BERT 모델만으로도 최고의 앙상블 시스템을 능가하며, TriviaQA 데이터 없이도 모든 기존 시스템을 크게 앞서고있다.&lt;/p>
&lt;h3 id="squad-v20">SQuAD v2.0&lt;/h3>
&lt;p>SQuAD 2.0 작업은 제공된 문단에 짧은 답변이 존재하지 않을 수 있다는 가능성을 허용함으로써 SQuAD 1.1 문제 정의를 확장하였고, 이로 인해 문제가 더 현실적으로 변하였다.&lt;/p>
&lt;p>이 작업을 위해 SQuAD v1.1 BERT 모델을 간단하게 확장하였다. 답변이 없는 질문은 시작과 끝이 [CLS] 토큰에 있는 답변 범위로 취급하였다. 예측 시, 답변이 없는 범위의 점수와 최고의 비-null 범위의 점수를 비교하여, 특정 임계값을 넘을 경우 non-null 답변을 예측하였다. 이 모델에서는 TriviaQA 데이터를 사용하지 않았으며, learning rate 5e-5와 batch size 48로 2 epoch 동안 미세 조정을 수행하였다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/bert/images/table3.png"
width="554"
height="384"
srcset="https://kurtkim.github.io/p/bert/images/table3_hucafb5411e878c5b05d50058000c43f06_60324_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/bert/images/table3_hucafb5411e878c5b05d50058000c43f06_60324_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;p>BERT를 사용하지 않는 시스템들과의 결과를 비교하였다. 다른 모델들에 비해 F1 점수가 5.1점 향상되었다.&lt;/p>
&lt;h3 id="swag">SWAG&lt;/h3>
&lt;p>The Situations With Adversarial Generations (SWAG) dataset는 실제 상식 추론을 평가하는 113k개의 문장 쌍 완성 예제를 포함하고 있다. 주어진 문장에 대해, 작업은 네 가지 선택지 중 가장 그럴듯한 답을 선택하는 것이다.&lt;/p>
&lt;p>SWAG dataset에서 미세 조정을 할 때, 각각 주어진 문장과 가능한 연속성을 포함하는 네 개의 입력 시퀀스를 만든다. [CLS] 토큰 표현과 내적을 이루는 벡터는 각 선택지에 대한 점수를 나타내며, 이 점수는 softmax 레이어를 통해 정규화한다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/bert/images/table4.png"
width="390"
height="304"
srcset="https://kurtkim.github.io/p/bert/images/table4_huaa7b68886e46455dbc2a98e05a48a7e3_41001_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/bert/images/table4_huaa7b68886e46455dbc2a98e05a48a7e3_41001_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="128"
data-flex-basis="307px"
>&lt;/p>
&lt;p>learning rate가 2e-5이고 batch size가 16인 상태로 모델을 3 epoch 동안 미세 조정하였다. $BERT_{LARGE}$는 ESIM+ELMo 모델을 +27.1%로, OpenAI GPT를 8.3%로 능가하였다.&lt;/p>
&lt;h2 id="ablation-studies">Ablation Studies&lt;/h2>
&lt;p>상대적인 중요성을 더 잘 이해하기 위해 BERT의 여러 면에 걸쳐서 ablation 실험을 수행한다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/bert/images/table5.png"
width="606"
height="244"
srcset="https://kurtkim.github.io/p/bert/images/table5_huef70981bcc644e2ad9fa8119807b5d76_44344_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/bert/images/table5_huef70981bcc644e2ad9fa8119807b5d76_44344_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="248"
data-flex-basis="596px"
>&lt;/p>
&lt;h3 id="effect-of-pre-training-tasks">Effect of Pre-training Tasks&lt;/h3>
&lt;p>$BERT_{BASE}$의 동일한 사전 학습 데이터, 미세 조정 scheme, 그리고 hyperparameter를 사용하여 두 가지 사전 학습 목표를 평가함으로써 BERT의 깊은 양방향성의 중요성을 입증한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>No NSP: &amp;ldquo;다음 문장 예측(NSP)&amp;rdquo; 과제를 하지 않은, &amp;ldquo;Masked LM(MLM)&amp;ldquo;을 사용해 훈련된 양방향 모델&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LTR &amp;amp; No NSP: 왼쪽 컨텍스트만 있는 모델은 표준 LTR LM을 사용해 훈련되며, 이는 미세 조정 시에도 유지된다. 이 모델은 NSP 작업 없이 사전 훈련되었다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>NSP 작업을 제거하면 QNLI, MNLI, SQuAD 1.1에서 성능이 크게 저하된다. 또한, 양방향 표현을 훈련하는 것은 성능에 중요한 영향을 미치며, 특히 LTR 모델은 모든 작업에서 MLM 모델보다 성능이 떨어진다.&lt;/p>
&lt;p>SQuAD의 경우, 토큰 레벨 은닉 상태가 오른쪽 컨텍스트를 가지고 있지 않기 때문에 LTR 모델이 토큰 예측에서 성능이 떨어질 것이라는 것은 직관적으로 명확하다. 이를 개선하기 위해 무작위로 초기화된 BiLSTM을 추가했지만, 결과는 사전 훈련된 양방향 모델보다 훨씬 떨어진다. 또한, BiLSTM은 GLUE 작업에서의 성능을 저하시킨다.&lt;/p>
&lt;p>LTR과 RTL 모델을 별도로 훈련하는 것은 가능하지만, 이는 단일 양방향 모델보다 비용이 두 배 많이 들고, QA와 같은 작업에 대해 직관적이지 않다. 또한, 이 방식은 모든 계층에서 양방향 컨텍스트를 사용하는 모델보다 성능이 엄격하게 떨어진다.&lt;/p>
&lt;h3 id="effect-of-model-size">Effect of Model Size&lt;/h3>
&lt;p>모델 크기가 미세 조정 작업 정확도에 미치는 영향을 알아본다. BERT 모델을 같은 파라미터와 훈련 절차를 사용한 반면, 레이어의 수, 은닉 상태 개수, 어텐션 헤드 개수를 다르게 학습했다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/bert/images/table6.png"
width="528"
height="286"
srcset="https://kurtkim.github.io/p/bert/images/table6_huc9ab3a4646faacd803209a81ed695698_48955_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/bert/images/table6_huc9ab3a4646faacd803209a81ed695698_48955_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="443px"
>&lt;/p>
&lt;p>GLUE 작업 결과에 따르면, 더 큰 모델은 레이블이 붙은 훈련 예시가 적은 데이터셋에서도 정확도를 개선하였다. 이는 이미 상대적으로 큰 모델을 기반으로 중요한 개선을 이루어내며, 예를 들어 $BERT_{BASE}$는 110M, $BERT_{LARGE}$는 340M의 파라미터를 가진다. 이는 기존 문헌에서 제시한 Transformer 모델 보다 훨씬 크다.&lt;/p>
&lt;p>모델 크기를 늘리는 것이 대규모 작업에서 성능을 향상시키는 것은 잘 알려져 있지만, 이 연구는 모델이 충분히 사전 훈련되었다면 작은 규모의 작업에서도 큰 개선을 가져올 수 있다는 것을 보여준다. 이전의 연구들은 사전 훈련된 모델의 크기를 늘리는 것이 혼합된 결과를 가져왔지만, 이 연구는 모델이 작업에 직접 미세 조정을 받고, 매우 적은 수의 무작위로 초기화된 추가 파라미터만 사용할 때, 작은 규모의 작업도 크고 표현력 있는 사전 훈련된 표현의 이점을 볼 수 있다.&lt;/p>
&lt;h3 id="feature-based-approach-with-bert">Feature-based Approach with BERT&lt;/h3>
&lt;p>지금까지의 BERT 결과는 모두 미세 조정 방식을 사용했다. 이 방식은 사전 학습된 모델에 분류 계층을 추가하고 모든 파라미터를 하류 작업에 맞게 조정하는 방법이다. 그러나, 사전 학습된 모델에서 고정 특징을 추출하는 특징 기반 접근법도 장점이 있다. 일부 작업은 Transformer 인코더 아키텍처로 표현하기 어려워 특정 작업용 모델이 필요하며, 훈련 데이터의 복잡한 표현을 미리 계산하고 이를 기반으로 저렴한 모델로 실험을 진행하면 계산적으로 이점이 있다.&lt;/p>
&lt;p>이 섹션에서는 BERT를 이름 인식(NER) 작업에 적용하여 두 가지 접근법을 비교한다. BERT 입력에는 대소문자를 구분하는 WordPiece 모델을 사용하고, 데이터에서 제공하는 최대 문서 컨텍스트를 포함한다. 이 작업은 일반적인 방식에 따라 태깅 작업으로 설정되지만, 출력에서는 CRF 계층은 사용하지 않는다. NER 레이블 세트에 대한 토큰 수준 분류기의 입력으로 첫 번째 서브토큰의 표현을 사용한다.&lt;/p>
&lt;p>미세 조정 방식을 제거하기 위해, BERT의 매개변수를 조정하지 않고 특징 기반 방식을 적용하여 활성화 함수를 추출한다. 이 문맥적인 임베딩은 랜덤하게 초기화된 두 계층의 768차원 BiLSTM에 입력으로 사용되며, 이는 분류 레이어 이전에 이루어진다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/bert/images/table7.png"
width="550"
height="458"
srcset="https://kurtkim.github.io/p/bert/images/table7_hu0b7abc968dac65c5fc4894b739c4ee8e_88243_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/bert/images/table7_hu0b7abc968dac65c5fc4894b739c4ee8e_88243_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="288px"
>&lt;/p>
&lt;p>$BERT_{LARGE}$는 state-of-the-art 방법들과 비슷한 수준의 성능을 보여준다. 가장 효과적인 방법은 사전 훈련된 Transformer의 상위 4개 계층에서 토큰 표현을 결합하는 것이며, 이는 전체 모델을 미세 조정한 것보다 F1에서 0.3만큼 뒤떨어진다. 이는 BERT가 미세 조정과 특징 기반 접근법 모두에 효과적임을 보여준다.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>언어 모델과 전이 학습을 통한 최근 개선은 비지도 사전 학습이 언어 이해 시스템의 중요한 부분임을 보여준다. 이 결과는 low-resource tasks조차 깊은 단방향 아키텍처에서 이익을 얻을 수 있다는 것을 보여주었다. 이 논문에서는 이를 깊은 양방향 아키텍처로 일반화함으로써, 사전 훈련된 동일 모델이 다양한 NLP 작업을 성공적으로 처리할 수 있게 한다는 것을 보여준다.&lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>&lt;a class="link" href="https://arxiv.org/pdf/1810.04805.pdf" target="_blank" rel="noopener"
>Paper&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/google-research/bert" target="_blank" rel="noopener"
>Code&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="http://nlp.seas.harvard.edu/2018/04/03/attention.html" target="_blank" rel="noopener"
>The Annotated Transformer&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>GPT-1</title><link>https://kurtkim.github.io/p/gpt-1/</link><pubDate>Thu, 28 Dec 2023 00:00:00 +0000</pubDate><guid>https://kurtkim.github.io/p/gpt-1/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>자연어 이해는 텍스트의 함축, 질문에 대한 답변, 의미의 유사성 평가, 문서 분류 등 다양한 작업으로 구성되어 있다. 레이블이 지정된 데이터가 부족한 상황에서, 이 논문은 레이블이 없는 텍스트 데이터에 대해 언어 모델을 &lt;code>(생성적) 사전학습(generative pre-training)&lt;/code>하고, 이를 특정 작업에 &lt;code>미세조정(fine-tuning)&lt;/code>하는 방식을 제안한다. 이 방법은 모델 아키텍처에 최소한의 변경만을 요구하면서도 효과적인 전이를 달성하였고, 다양한 자연어 이해 벤치마크에서 우수한 성능을 보여주었다. 이 모델은 각 작업에 특별히 설계된 모델을 능가하며, 12개의 작업 중 9개에서 최고 성능을 달성하였다.&lt;/p>
&lt;hr>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>자연어 처리(NLP)에서 지도 학습의 의존성을 줄이는 것은 중요한데, 이는 대부분의 딥러닝 방법이 수동 레이블링된 대량의 데이터가 필요하기 때문이다. 이런 상황에서 레이블이 없는 데이터에서 언어 정보를 추출할 수 있는 모델은 유용한 대안이 될 수 있으며, 비지도 학습을 통해 학습하는 것이 더 나은 결과를 얻는 경우도 있다. 이를 입증하는 가장 강력한 예는 사전 학습된 단어 임베딩이며, 이는 다양한 NLP 작업에서 성능 향상을 위해 널리 사용되고 있다.&lt;/p>
&lt;p>레이블이 없는 텍스트에서 단어 수준을 넘어서는 정보를 활용하는 것은 어려운 도전 과제이며, 이유는 다음과 같다. 첫째, 텍스트 표현을 학습하고 다른 곳에 유용하게 전이하는 최적화 목표가 무엇인지 확실하지 않다. 둘째, 학습된 표현을 어떤 작업에 가장 효과적으로 적용할 방법이 아직 확립되지 않았다. 이런 불확실성이 효과적인 준지도 학습 방법을 개발하는 것을 어렵게 한다.&lt;/p>
&lt;p>이 연구는 언어 이해 작업에 &lt;code>비지도 사전 학습(unsupervised pre-training)&lt;/code>과 &lt;code>지도 미세 조정(supervised fine-tuning)&lt;/code>을 결합하는 준지도 학습을 제안한다. 목표는 적은 조정으로 다양한 작업에 적용 가능한 표현을 학습하는 것이다. 레이블이 없는 대량의 텍스트와 수동으로 레이블링된 훈련 예제를 사용하며, 학습은 두 단계로 진행된다. 먼저, 레이블이 없는 데이터로 모델의 초기 파라미터를 학습하고, 그 다음으로 지도 학습을 통해 이 파라미터를 목표 작업에 맞게 조정한다.&lt;/p>
&lt;p>이 연구에서는 다양한 작업에서 뛰어난 성능을 보인 &lt;code>Transformer&lt;/code>모델을 사용한다. 이 모델은 텍스트의 장기적인 의존성을 처리하는 더 구조화된 메모리를 제공하므로 강한 전이 성능을 보여준다. 전이 단계에서는 작업 특정 입력 조정을 사용하여 텍스트 입력을 연속 토큰 시퀀스로 처리하며, 이 방식은 사전 학습된 모델의 구조를 최소한으로 변경하면서 효과적으로 미세 조정할 수 있음을 실험적으로 입증한다.&lt;/p>
&lt;p>이 연구는 자연어 추론, 질문 응답, 의미 유사성, 텍스트 분류 등 네 가지 언어 이해 작업에서 모델을 평가하였다. 제시된 모델은 각 작업에 특화된 모델들보다 더 우수한 성능을 보여주었고, 12개 작업 중 9개에서 최고 성능을 보여주었다.&lt;/p>
&lt;hr>
&lt;h2 id="related-work">Related Work&lt;/h2>
&lt;h3 id="semi-supervised-learning-for-nlp">Semi-supervised learning for NLP&lt;/h3>
&lt;p>이 연구는 자연어에 대한 준지도 학습 범주에 속하며, 이는 시퀀스 라벨링이나 텍스트 분류와 같은 작업에 적용된다. 초기에는 레이블 없는 데이터를 사용해 단어나 구문 수준의 통계를 계산하였지만, 최근에는 레이블이 없는 말뭉치에서 훈련된 단어 임베딩을 활용하여 작업 성능을 향상시키는 방향으로 연구가 진행되고있다. 그러나 이 논문의 목표는 단어 수준 이상의 의미를 포착하는 것이며, 이를 위해 구문이나 문장 수준의 임베딩을 활용하여 텍스트를 벡터 표현으로 인코딩하는 방식을 채택하였다.&lt;/p>
&lt;h3 id="unsupervised-pre-training">Unsupervised pre-training&lt;/h3>
&lt;p>비지도 사전 학습은 좋은 초기화 지점을 찾는 것을 목표로 하며, 이미지 분류, 음성 인식, 엔티티 구분, 기계 번역 등 다양한 작업에서 DNN의 훈련을 돕는데 사용되고있다.&lt;/p>
&lt;p>이 연구는 언어 모델링 목표를 사용하여 신경망을 사전 학습하고, 지도 학습으로 목표 작업에서 미세 조정하는 방식을 따른다. 이 방법은 LSTM을 사용하는 이전의 방법들이 제한적인 예측 능력을 가지는 반면, Transformer는 더 넓은 범위의 언어 구조를 포착할 수 있게 한다. GPT 모델은 자연어 추론, 패러프레이즈 감지, 스토리 완성 등 다양한 작업에서 효과를 보여주었으며, 다른 모델이 새로운 파라미터를 많이 필요로 하는 반면, GPT 모델은 아키텍처에 최소한의 변경만 필요로 한다.&lt;/p>
&lt;h3 id="auxiliary-training-objectives">Auxiliary training objectives&lt;/h3>
&lt;p>보조적인 비지도 학습 목표 추가는 준지도 학습의 변형 형태로, 다양한 NLP 작업을 통해 의미 역할 라벨링을 개선하는데 사용되었다. 최근에는 이러한 보조 목표를 목표 작업에 추가하여 시퀀스 라벨링 작업에서 성능을 향상시켰다. 이 연구에서도 비지도 사전 훈련이 이미 목표 작업과 관련된 다양한 언어적 요소를 학습한다는 것을 보여준다.&lt;/p>
&lt;hr>
&lt;h2 id="framework">Framework&lt;/h2>
&lt;p>학습은 큰 말뭉치에서 대용량 언어 모델을 학습하는 단계와 레이블이 달린 데이터를 활용해 모델을 목표 작업에 맞게 미세 조정하는 단계로 이루어진다.&lt;/p>
&lt;h3 id="unsupervised-pre-training-1">Unsupervised pre-training&lt;/h3>
&lt;p>비지도 토큰 말뭉치 $U = \lbrace u_1, &amp;hellip; , u_n \rbrace $ 가 주어질때, 다음 Likelihood를 최대화하도록 표준언어모델링 목적함수를 사용한다:&lt;/p>
&lt;p>$$ L_1(U) = \sum_{i} \log{P} (u_i | u_{i-k}, &amp;hellip; , u_{i-1}, \theta) $$&lt;/p>
&lt;p>$k$는 context window의 크기이며, 조건부 확률 $P$는 parameter $\theta$를 가진 신경망을 사용하여 모델링된다. 이 parameter들은 stochastic gradient descent를 사용하여 학습된다.&lt;/p>
&lt;p>GPT 모델은 언어모델로 multi-layer Transformer decoder를 사용하며, 이 모델은 입력 컨텍스트 토큰에 대해 multi-headed self-attention을 적용한 후, position-wise feedforward layer를 적용하여 목표 토큰에 대한 출력 분포를 생성한다:&lt;/p>
&lt;p>$$ h_0 = UW_e + W_p $$
$$ h_l = \text{transformer_block}(h_{l-1}) \forall i \in [1, n] $$
$$ P(u) = \text{softmax}(h_n W^T_e) $$&lt;/p>
&lt;p>$U = (u_{i-k}, &amp;hellip; , u_{i-1}) $ 는 토큰의 컨텍스트 벡터이고, $n$은 layer의 수, $W_e$ 는 토큰 임베딩 행렬, $W_p$ 는 위치 임베딩 행렬이다.&lt;/p>
&lt;h3 id="supervised-ﬁne-tuning">Supervised ﬁne-tuning&lt;/h3>
&lt;p>모델을 학습한 후, parameter를 목표 작업에 맞게 조정한다. 레이블이 지정된 데이터셋 $C$ 는 입력 토큰 $x^1, &amp;hellip; , x^m $ 과 레이블 $y$로 구성된다. 입력은 사전 훈련된 모델을 통과하여 최종 transformer block의 활성값인 $h^m_l$ 을 얻으며, 이는 parameter $W_y$ 와 함께 선형 출력층으로 전달되어 $y$ 를 예측한다:&lt;/p>
&lt;p>$$ P(y|x^1, &amp;hellip; , x^m) = \text{softmax}(h^m_l W_y) $$&lt;/p>
&lt;p>이는 다음을 최대화 한다.&lt;/p>
&lt;p>$$ L_2(C) = \sum_{(x,y)} \log{P(y|x^1, &amp;hellip; , x^m)} $$&lt;/p>
&lt;p>추가로 미세 조정을 위한 보조 목표로 언어 모델링을 포함시키는 것은 지도 모델의 일반화를 향상시키고, 수렴을 가속화하는데 도움이 된다. 구체적으로, weight $\lambda$에 대해 다음을 최적화한다:&lt;/p>
&lt;p>$$ L_3(C) = L_2(C) + \lambda L_1(C) $$&lt;/p>
&lt;p>미세 조정 과정에서 추가 매개변수는 $W_y$ 와 구분자 토큰의 임베딩뿐이다.&lt;/p>
&lt;h3 id="task-speciﬁc-input-transformations">Task-speciﬁc input transformations&lt;/h3>
&lt;p>텍스트 분류같은 일부 작업들은 모델을 직접 미세 조정할 수 있지만, 질문 답변이나 텍스트 함의 같은 작업들은 구조화된 입력을 필요로 하는데, 이러한 입력에 대해 사전 학습된 모델은 별도의 수정 없이도 처리할 수 있다. 대신, 이런한 입력을 모델이 처리할 수 있는 순서가 있는 시퀀스로 변환한다. 이 접근법은 작업 간에 아키텍처를 크게 변경할 필요를 없애준다. 또한, 모든 변형에는 무작위로 초기화된 시작과 종료 토큰을 포함한다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/gpt-1/images/figure1.png"
width="1058"
height="450"
srcset="https://kurtkim.github.io/p/gpt-1/images/figure1_huf693ec86c2dee30b1295845fdb401f1a_181900_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/gpt-1/images/figure1_huf693ec86c2dee30b1295845fdb401f1a_181900_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="235"
data-flex-basis="564px"
>&lt;/p>
&lt;h4 id="textual-entailment">Textual entailment&lt;/h4>
&lt;p>텍스트 함의에서는, 전제 $p$와 가설 $h$를 구분자 &lt;code>$&lt;/code>로 연결한다.&lt;/p>
&lt;h4 id="similarity">Similarity&lt;/h4>
&lt;p>유사성 경우, 비교되는 두 문장의 순서는 정해져 있지 않으므로, 텍스트 두 개를 다른 순서로 이어붙여 각각을 독립적으로 처리하여 두 시퀀스 표현 $h^m_l$을 생성한다.&lt;/p>
&lt;h4 id="question-answering-and-commonsense-reasoning">Question Answering and Commonsense Reasoning&lt;/h4>
&lt;p>컨텍스트 문서 $z$, 질문 $q$, 가능한 답변들 $\lbrace a_k \rbrace$을 받는다. 각 가능한 답변을 문맥 문서와 질문에 연결하고, 구분자 토큰을 추가해 시퀀스 $[z; q;$ &lt;code>$&lt;/code>; $a_k]$ 를 만든다. 이 시퀀스들은 독립적으로 처리되고, softmax 계층을 통해 정규화되어 답변들에 대한 출력 분포를 생성한다.&lt;/p>
&lt;hr>
&lt;h2 id="experiments">Experiments&lt;/h2>
&lt;h3 id="setup">Setup&lt;/h3>
&lt;h4 id="unsupervised-pre-training-2">Unsupervised pre-training&lt;/h4>
&lt;p>언어 모델 학습에 BooksCorpus 데이터셋을 사용한다. 이는 다양한 장르의 7천개가 넘는 미발행 책들을 포함하며, 연속적인 긴 텍스트를 통해 모델이 long term depency를 학습할 수 있다. ELMo에서 사용된 1B Word Benchmark 데이터셋은 문장들이 서로 섞여 있어 long term depency를 학습하기 어렵다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/gpt-1/images/table1.png"
width="1068"
height="192"
srcset="https://kurtkim.github.io/p/gpt-1/images/table1_hu67f0911c3e9c0a1b268879a509ffb6ec_53434_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/gpt-1/images/table1_hu67f0911c3e9c0a1b268879a509ffb6ec_53434_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="556"
data-flex-basis="1335px"
>&lt;/p>
&lt;h4 id="model-speciﬁcations">Model speciﬁcations&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Hyperparameter&lt;/th>
&lt;th style="text-align:center">Descrption&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">layer&lt;/td>
&lt;td style="text-align:center">12-layer decoder-only transformer with masked self-attention heads&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">state dimension&lt;/td>
&lt;td style="text-align:center">decoder: 768, attention heads: 12, position-wise FFN: 3072&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">optimizer&lt;/td>
&lt;td style="text-align:center">Adam&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">learning rate&lt;/td>
&lt;td style="text-align:center">max: 2.5e-4, schedule: cosine annealing, warm-up step: 2,000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">schedule&lt;/td>
&lt;td style="text-align:center">100 epochs&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">batch size&lt;/td>
&lt;td style="text-align:center">64 random sample $\times$ 512 token/sample&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">weight initialization&lt;/td>
&lt;td style="text-align:center">$N(0, 0.02)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">subword segmentation&lt;/td>
&lt;td style="text-align:center">BPE (40,000 merges)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">dropout&lt;/td>
&lt;td style="text-align:center">0.1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">regularization&lt;/td>
&lt;td style="text-align:center">L2($w=0.01$)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">activation function&lt;/td>
&lt;td style="text-align:center">Gaussian Error Linear Unit(GELU)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">position embedding&lt;/td>
&lt;td style="text-align:center">learned positoin embeddings&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">pre-processing&lt;/td>
&lt;td style="text-align:center">cleaning: ftfy, tokenizer : spaCy&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="fine-tuning-details">Fine-tuning details&lt;/h4>
&lt;p>명시되지 않은 것들은 사전학습에 사용된 hyperparameter를 재사용했다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Hyperparameter&lt;/th>
&lt;th style="text-align:center">Descrption&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">dropout&lt;/td>
&lt;td style="text-align:center">0.1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Learning rate&lt;/td>
&lt;td style="text-align:center">max: 6.25e-5, warm-up: 0.2% of training&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">batch size&lt;/td>
&lt;td style="text-align:center">32&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">epochs&lt;/td>
&lt;td style="text-align:center">3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">auxiliary objective weight($\lambda$)&lt;/td>
&lt;td style="text-align:center">0.5&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="supervised-ﬁne-tuning-1">Supervised ﬁne-tuning&lt;/h3>
&lt;p>자연어 추론, 질문 응답, 의미론적 유사성, 텍스트 분류등의 평가를 진행하였고, 그 중 일부는 GLUE benchmark에 포함되어 있다.&lt;/p>
&lt;h4 id="natural-language-inference">Natural Language Inference&lt;/h4>
&lt;p>자연어 추론(NLI) 작업, 즉 텍스트 함의를 인식하는 것은 문장 쌍을 읽고, 그들 사이의 관계를 함의, 모순 또는 중립 중 하나로 판단하는 것으로, 이미지 캡션(SNLI), 텍스트 변환된 연설, 대중 소설, 정부 보고서(MNLI), 위키백과 기사(QNLI), 과학 시험(SciTail) 또는 뉴스 기사(RTE)를 포함한 다양한 출처의 다섯 개의 데이터셋을 사용해서 평가하였다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/gpt-1/images/table2.png"
width="1084"
height="324"
srcset="https://kurtkim.github.io/p/gpt-1/images/table2_hu495d483b1c75750171478d8e124f7ea5_71854_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/gpt-1/images/table2_hu495d483b1c75750171478d8e124f7ea5_71854_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="334"
data-flex-basis="802px"
>&lt;/p>
&lt;p>다섯 가지 데이터셋 중 네 가지에서 좋은 성능을 보여주었으며, MNLI에서 1.5%, SciTail에서 5%, QNLI에서 5.8%, SNLI에서 0.6%의 성능 향상을 보였다. 이는 GPT 모델이 여러 문장을 더 잘 이해하고, 언어적 모호성의 측면을 처리할 수 있다는 것을 보여준다.&lt;/p>
&lt;h4 id="question-answering-and-commonsense-reasoning-1">Question answering and commonsense reasoning&lt;/h4>
&lt;p>질문 응답 작업은 한 문장이나 여러 문장을 이해하는 능력을 평가한다. 중고등학교 시험의 영어 지문과 질문이 포함된 RACE 데이터셋을 사용한 평가에서 좋은 성능을 보여주었다. 또한, 여러 문장의 이야기 중에서 올바른 결말을 고르는 Story Cloze 평가에서도 GPT 모델은 이전 최고 성능을 크게 능가하였다. 이 결과는 GPT 모델이 넓은 범위에 걸친 문맥 정보를 잘 처리할 수 있음을 보여준다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/gpt-1/images/table3.png"
width="1078"
height="312"
srcset="https://kurtkim.github.io/p/gpt-1/images/table3_huadd22c7f91cb998e4bf1e5863627ba4f_62097_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/gpt-1/images/table3_huadd22c7f91cb998e4bf1e5863627ba4f_62097_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="345"
data-flex-basis="829px"
>&lt;/p>
&lt;h4 id="semantic-similarity">Semantic Similarity&lt;/h4>
&lt;p>의미론적 유사성(또는 패러프레이즈 감지) 작업은 두 문장이 의미적으로 동일한지 여부를 판단한다. 뉴스 출처에서 수집된 Microsoft Paraphrase(MRPC), Quora Question Pairs(QQP), 그리고 Semantic Textual Similarity benchmark(STS-B) 데이터셋을 사용한다. 이 중 STSB와 QQP에서 좋은 성늘을 보여주었다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/gpt-1/images/table4.png"
width="1076"
height="382"
srcset="https://kurtkim.github.io/p/gpt-1/images/table4_hu960b0c42aa968787120d1f3e94295e46_86789_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/gpt-1/images/table4_hu960b0c42aa968787120d1f3e94295e46_86789_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="281"
data-flex-basis="676px"
>&lt;/p>
&lt;h4 id="classiﬁcation">Classiﬁcation&lt;/h4>
&lt;p>텍스트 분류로 사용한 데이터셋은 문법적으로 맞는지를 판단하는 Corpus of Linguistic Acceptability(CoLA)와 단순 이진분류 평가인 Stanford Sentiment Treebank(SST-2)을 사용하였다. CoLA에서 35.0 에서 45.4점으로, SST-2에서 68.9 에서 72.8점으로 상승하였으며, GLUE benchmark에서도 72.8점으로 이전 최고 성능을 크게 능가하였다.&lt;/p>
&lt;p>GPT모델은 평가한 12개의 데이터셋 중 9개에서 state-of-the-art를 달성하였다. 그리고 STS-B(약 5.7k)와 같은 작은 데이터셋부터 가장 큰 SNLI(약 550k)와 같은 크기의 다양한 데이터셋에서 잘 작동함을 보여준다.&lt;/p>
&lt;hr>
&lt;h2 id="analysis">Analysis&lt;/h2>
&lt;h3 id="impact-of-number-of-layers-transferred">Impact of number of layers transferred&lt;/h3>
&lt;p>unsupervised pre-training에서 supervised target task로 transfer하는 layer 개수의 영향을 분석했다. MultiNLI와 RACE에서 성능을 관찰했고 transferring embeddings이 성능을 향상시킨다는 것과 각 transformer layer가 최대 9%까지 성능을 향상시킨다는 결과를 얻었다. 이는 pre-trained model의 각 layer가 target task를 푸는 데 유용한 기능을 포함함을 의미한다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/gpt-1/images/figure2.png"
width="1070"
height="478"
srcset="https://kurtkim.github.io/p/gpt-1/images/figure2_hu21f96b797eb02f25e10b12c7ce8aff79_177494_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/gpt-1/images/figure2_hu21f96b797eb02f25e10b12c7ce8aff79_177494_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="223"
data-flex-basis="537px"
>&lt;/p>
&lt;h3 id="zero-shot-behaviors">Zero-shot Behaviors&lt;/h3>
&lt;p>Trasformer를 사용한 language model이 pre-training에 효과적인 이유에 대한 가설로, Generative model이 학습하는 target tasks가 language modeling의 성능을 향상에 도움을 준다고 생각했고, 이를 검증하기 위해 pre-training 업데이트 횟수에 따른 target tasks의 성능을 fine-tuning없이 측정하였다.&lt;/p>
&lt;p>실험 결과 pre-training 업데이트 횟수에 따라 안정적 &amp;amp; 지속적으로 관련 taget task의 성능이 증가하는 것을 확인할 수 있었으며 이는 generative pre-training이 관련 task의 학습에 도움을 준다는 것을 의미한다. 반면, LSTM의 경우에는 업데이트 횟수에 따라 일관되게 안정적으로 증가하지 않고 분산을 가지면서 증가하는데, 이는 LSTM 보다 더 구조화된 transformer의 attentional memory가 transfer learning에 도움을 준다는 것을 의미한다.&lt;/p>
&lt;h3 id="ablation-studies">Ablation studies&lt;/h3>
&lt;p>세 가지 ablation study를 통해 다음의 결과를 얻었다. 첫째, 미세조정 시 보조 목적함수의 도움이 큰 데이터셋에서는 두드러지지만 작은 데이터셋에서는 그렇지 않다는 것을 확인하였다. 둘째, LSTM과 Transformer를 비교한 결과, LSTM은 오직 MRPC 데이터셋에서만 Transformer를 능가하는 것을 확인하였다. 마지막으로, 사전학습 없이 지도학습을 진행한 Transformer는 모든 작업에서 성능이 저하되었다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/gpt-1/images/table5.png"
width="1074"
height="208"
srcset="https://kurtkim.github.io/p/gpt-1/images/table5_hu95c5714341cf48b980d835242421642d_54388_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/gpt-1/images/table5_hu95c5714341cf48b980d835242421642d_54388_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="516"
data-flex-basis="1239px"
>&lt;/p>
&lt;hr>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>생성적 사전 학습과 미세조정을 사용한 모델을 통해 강력한 자연어 이해를 구현하였다. GPT 모델은 연속된 텍스트로 이루어진 다양한 말뭉치로 사전학습된 모델은 일반 지식(world knowledge)과 long term depency 처리하는 능력을 가질 수 있었다. 이를 통해, 우리는 지도학습 없이도 특정 작업의 성능을 향상시키는 것이 가능하다는 것을 보여주었으며, 특히 Trasformer 모델과 long term depency가 있는 텍스트 데이터셋이 이 접근법에서 잘 작동함을 확인하였다.&lt;/p>
&lt;hr>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>&lt;a class="link" href="https://cdn.openai.com/research-covers/language-unsupervised/language_understanding_paper.pdf" target="_blank" rel="noopener"
>Paper&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/openai/finetune-transformer-lm" target="_blank" rel="noopener"
>Code&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>