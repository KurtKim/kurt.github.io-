<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Music on K2H Blog</title><link>https://kurtkim.github.io/tags/music/</link><description>Recent content in Music on K2H Blog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 30 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://kurtkim.github.io/tags/music/index.xml" rel="self" type="application/rss+xml"/><item><title>MusicGEN</title><link>https://kurtkim.github.io/p/musicgen/</link><pubDate>Tue, 30 Jan 2024 00:00:00 +0000</pubDate><guid>https://kurtkim.github.io/p/musicgen/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>conditional music generation을 위한 &amp;ldquo;MusicGEN&amp;quot;이라는 언어 모델을 개발하였다. 이 모델은 여러 스트림의 압축된 이산 음악 표현을 다루며, 효율적인 토큰 교차 패턴과 single-stage transformer를 사용해 여러 모델을 계층적으로 구성하거나 업샘플링할 필요가 없다. 이 방법을 통해 텍스트 설명이나 멜로디 특징에 따라 높은 품질의 음악 샘플을 생성할 수 있음을 입증하였다. 실증적 평가를 통해 제안된 접근법이 기존 벤치마크보다 우수하다는 것을 보여주었다.&lt;/p>
&lt;hr>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>text-to-music은 텍스트 설명을 바탕으로 음악을 생성하는 작업이다. 이 과정은 long range sequence를 모델링하고 full frequency spectrum을 사용해야 하므로 어렵다. 또한, 다양한 악기의 하모니와 멜로디를 포함하는 음악은 복잡한 구조를 가지며, 이로 인해 음악 생성 과정에서는 멜로디 오류를 범할 여지가 거의 없다. 키, 악기, 멜로디, 장르 등 다양한 요소를 제어할 수 있는 능력은 음악 창작자에게 필수적이다.&lt;/p>
&lt;p>self-supervised audio representation, sequential modeling, audio synthesis 등의 최근 연구 진보가 새로운 모델 개발을 가능하게 한다. 최근 연구들은 오디오 신호를 같은 신호를 표현하는 여러 이산 토큰의 스트림으로 나타내는 것을 제안하였는데, 이를 통해 고품질의 오디오 생성과 효과적인 오디오 모델링이 가능해졌다. 그러나 이는 여러 parallel dependent stream을 동시에 모델링해야한다는 비용을 수반한다.&lt;/p>
&lt;p>Kharitonov et al. 과 Kreuk et al. 은 음성 토큰의 다중 스트림을 병렬로 모델링하는 지연 접근법을 제안하였다. Agostinelli et al. 은 음악 세그먼트를 다양한 세부성의 이산 토큰 시퀀스로 표현하고 이를 autoregressive 모델로 모델링하는 방식을 제안하였다. Donahue et al. 은 비슷한 접근법을 가요 생성 작업에 적용했고, Wang et al. 은 문제를 두 단계로 해결하는 방법을 제안하였다: 첫 번째 토큰 스트림만 모델링한 후, non-autoregressive 방식으로 나머지 스트림을 모델링한다.&lt;/p>
&lt;p>이 연구에서는 텍스트 설명에 따른 고품질 음악을 생성하는 &amp;ldquo;MusicGEN&amp;quot;이라는 단순하고 조절 가능한 모델을 소개한다. 이 모델은 음향 토큰의 병렬 스트림을 모델링하는 프레임워크를 제안하며, 스테레오 오디오 생성을 추가 비용 없이 확장할 수 있다. 또한, 비지도 멜로디 조건 설정을 통해 생성된 샘플의 제어력을 향상시키고, 주어진 조화와 멜로디 구조에 맞는 음악을 생성할 수 있다. MusicGEN은 평가에서 100점 만점에 84.8점의 높은 점수를 받았으며, 이는 최고 기준선의 80.5점보다 우수한 성능을 보여준다. 마지막으로, 인간 평가에 따르면 MusicGEN은 주어진 조화 구조에 잘 맞는 멜로디를 가진 고품질 샘플을 생성하며, 텍스트 설명을 충실히 따른다.&lt;/p>
&lt;p>&lt;strong>Our contribution:&lt;/strong> 32 kHz에서 고품질 음악을 생성하는 간단하고 효율적인 모델, MusicGEN을 제안한다. 이 모델은 효율적인 코드북 교차 전략을 통해 일관된 음악을 생성하며, 텍스트와 멜로디 조건에 모두 부합하는 단일 모델을 제공한다. 생성된 오디오는 제공된 멜로디와 일치하고 텍스트 조건 정보에 충실하다. 또한, 주요 설계 선택에 대한 광범위한 객관적 평가와 인간 평가를 제공한다.&lt;/p>
&lt;hr>
&lt;h2 id="method">Method&lt;/h2>
&lt;p>MusicGEN은 텍스트나 멜로디에 의존하는 autoregressive transformer-based decoder이다. 이 모델은 양자화된 오디오 토큰을 사용하며, 이는 고해상도 복구를 가능하게 한다. 병렬 스트림은 Residual Vector Quantization (RVQ)를 통해 생성되며, 각 스트림은 다양한 코드북에서 생성된 이산 토큰으로 구성된다. 이 연구에서는 다양한 코드북 교차 패턴에 적용 가능한 새로운 모델링 프레임워크를 소개하며, 이를 통해 양자화된 오디오 토큰의 내부 구조를 활용한다. MusicGEN은 텍스트나 멜로디를 기반으로 한 조건부 생성을 지원한다.&lt;/p>
&lt;h3 id="audio-tokenization">Audio tokenization&lt;/h3>
&lt;p>Residual Vector Quantization (RVQ)를 사용하여 양자화된 latent space와 adversarial reconstruction 손실을 가진 EnCodec을 사용한다. 이는 오디오 무작위 변수를 연속 텐서로 인코딩하고, 이를 다시 양자화하여 병렬 이산 토큰 시퀀스를 생성한다. RVQ에서는 각 양자화기가 이전 양자화기의 양자화 오류를 인코딩하므로, 다른 코드북의 양자화 값은 일반적으로 독립적이지 않다. 이 과정에서 첫 번째 코드북이 가장 중요하게 작용한다.&lt;/p>
&lt;h3 id="codebook-interleaving-patterns">Codebook interleaving patterns&lt;/h3>
&lt;p>&lt;strong>Exact flattened autoregressive decomposition.&lt;/strong> autoregressive 모델은 일정한 길이 $S$를 가진 이산 랜덤 시퀀스 $U$가 필요하며, 이 시퀀스는 {$1, &amp;hellip;, N$}$^S$에서 선택된다. 관례적으로 시퀀스의 시작은 $U_0 = 0$, 즉 특별 토큰으로 표현된다. 이를 통해 분포를 모델링한다.&lt;/p>
&lt;p>$$ \forall t &amp;gt; 0, p_t (U_{t−1}, &amp;hellip;, U_0) \triangleq \mathbb{P} [U_t | U_{t−1}, &amp;hellip;, U_0] $$&lt;/p>
&lt;p>auto-regressive density $p$를 이용해 랜덤 변수의 두 번째 시퀀스인 $\tilde{U}$를 만든다. 이때, $\tilde{U}_0 = 0$으로 초기화하고, $t &amp;gt; 0$인 모든 경우에 대해 재귀적으로 정의한다.&lt;/p>
&lt;p>$$ \forall t &amp;gt; 0, \mathbb{P} \big[\tilde{U}_t | \tilde{U}_{t−1}, &amp;hellip;, \tilde{U}_0 \big] = p_t (\tilde{U}_{t−1}, &amp;hellip;, \tilde{U}_0) $$&lt;/p>
&lt;p>$U$와 $\tilde{U}$가 같은 분포를 가진다는 것이 바로 확인된다. 이는 딥러닝 모델로 $p$의 완벽한 추정치 $\tilde{p}$를 맞출 수 있다면, $U$의 분포도 정확히 맞출 수 있다는 것을 의미한다.&lt;/p>
&lt;p>EnCodec 모델로부터 얻은 $Q$ 표현의 문제는 각 시간 단계마다 $K$개의 코드북이 있다는 점이다. 이를 해결하기 위해 $Q$를 펼쳐 $S = d \cdot f_r \cdot K$로 설정할 수 있다. 이 방식은 첫 번째 시간 단계의 각 코드북을 순차적으로 예측한다. 이론적으로 $Q$의 분포를 정확하게 모델링할 수 있지만, 복잡성이 증가하고 가장 낮은 샘플 속도 $f_r$에서 얻는 이익이 일부 손실된다.&lt;/p>
&lt;p>여러 가지 flattening 방법이 가능하며, 모든 $\hat{p_t}$ 함수를 한 모델로 추정할 필요는 없다. 예를 들어, MusicLM은 두 개의 모델을 사용해 첫 번째 $K/2$ 코드북과 나머지 $K/2$ 코드북을 각각 모델링한다. 이렇게 해도 autoregressive step의 수는 $df_r \cdot K$로 동일하다.&lt;/p>
&lt;p>&lt;strong>Inexact autoregressive decomposition.&lt;/strong> 일부 코드북이 병렬로 예측되는 autoregressive 분해를 고려하는 것이 가능하다. 즉, $V_0 = 0$을 정의하고, 모든 $t$와 $k$에 대해 $V_{t, k} = Q_{t, k}$로 시퀀스를 설정한다. 이때, 코드북 인덱스 $k$를 생략하면, 시간 $t$에서 모든 코드북이 연결된 것을 의미한다.&lt;/p>
&lt;p>$$ p_{t, k} (V_{t−1}, &amp;hellip;, V_0) \triangleq \mathbb{P} [V_{t, k} | V_{t−1}, \dot, &amp;hellip;, V_0] $$&lt;/p>
&lt;p>재귀적으로 $\tilde{V}_0 = 0$을 다시 정의하고, 모든 $t &amp;gt; 0$에 대해 이를 정의한다.&lt;/p>
&lt;p>$$ \forall t &amp;gt; 0, \mathbb{P} \big[\tilde{V}_{t, k} \big] = p_{t, k} (\tilde{V}_{t−1}, &amp;hellip;, \tilde{V}_0) $$&lt;/p>
&lt;p>일반적으로 정확한 분포 $p_{t,k}$를 가정하더라도 $\tilde{V}$는 $V$와 동일한 분포를 따르지 않는다. 실제로, 모든 $t$에 대해 $(V_{t,k})$ $k$가 $V_{t−1}, &amp;hellip;, $V_0$에 조건부로 독립인 경우에만 적절한 생성 모델을 가진다. $t$가 증가함에 따라 오류가 누적되고 두 분포는 점점 멀어진다. 이 분해법은 부정확하지만 원래의 프레임 속도를 유지하므로, 학습과 추론이 특히 긴 시퀀스에 대해 크게 가속화된다.&lt;/p>
&lt;p>&lt;strong>Arbitrary codebook interleaving patterns.&lt;/strong> 다양한 분해 실험을 진행하고, 부정확한 분해의 영향을 측정하기 위해 코드북 교차 패턴을 사용한다. 모든 시간 단계와 코드북 인덱스의 쌍을 나타내는 $\Omega$ 집합을 고려하며, 코드북 패턴은 $P_0 = \emptyset$으로 시작해 $P_s$가 $\Omega$ 의 부분집합인 시퀀스이다. 이 패턴은 $\Omega$를 모델링하는 데 사용되며, 모든 위치를 병렬로 예측합니다. 실용적으로, 각 $P_s$에서 코드북 인덱스가 최대 한 번만 나타나는 패턴으로 제한한다.&lt;/p>
&lt;p>&amp;ldquo;parallel&amp;rdquo; 패턴과 같은 여러 분해를 쉽게 정의할 수 있다. 이 패턴은 다음과 같이 주어진다.&lt;/p>
&lt;p>$$ P_s = \lbrace (s, k) : k \in \lbrace 1, &amp;hellip;, K \rbrace \rbrace $$&lt;/p>
&lt;p>코드북 사이에 &amp;ldquo;delay&amp;quot;를 도입하는 것도 가능하다.&lt;/p>
&lt;p>$$ P_s = \lbrace (s − k + 1, k) : k \in \lbrace 1, &amp;hellip;, K \rbrace , s − k \geq 0 \rbrace $$&lt;/p>
&lt;p>다양한 코드북 패턴의 장단점을 실증적으로 평가하여, 병렬 코드북 시퀀스 모델링의 중요성을 강조한다.&lt;/p>
&lt;h3 id="model-conditioning">Model conditioning&lt;/h3>
&lt;p>&lt;strong>Text conditioning.&lt;/strong> 입력 오디오에 대응하는 텍스트를 표현하는 세 가지 주요 방법에 대해 실험하였다: T5 인코더를 사용하는 Kreuk et al. 의 방법, 지시기반 언어 모델을 사용하는 Chung et al. 의 방법, 그리고 공동 텍스트-오디오 표현인 CLAP을 사용하는 방법이다. 이 세 가지 방법 모두 조건부 오디오 생성 테스트에서 사용되었다.&lt;/p>
&lt;p>&lt;strong>Melody conditioning.&lt;/strong> 텍스트보다는 다른 오디오 트랙이나 휘파람, 허밍 등에서 얻은 멜로디 구조를 조건으로 삼는 것이 음악에 더 적합하다. 이를 위해 입력의 chromagram과 text description에 동시에 조건을 부여하여 멜로디 구조를 제어하는 실험을 진행하였다. 하지만 raw chromagram에 조건을 부여하면 과적합이 발생해 원본 샘플이 재구성되는 문제가 발생하였다. 이를 해결하기 위해 각 시간 단계에서 주요 time-frequency 빈도를 선택하는 정보 병목 방법을 도입하였다. 이는 supervised proprietary 데이터가 필요 없는 unsupervised 학습 방법으로, 데이터 수집 비용을 줄이는 효과가 있다.&lt;/p>
&lt;h3 id="model-architecture">Model architecture&lt;/h3>
&lt;p>&lt;strong>Codebook projection and positional embedding.&lt;/strong> 코드북 패턴에 따라 각 패턴 단계에서는 일부 코드북만 사용된다. 각 코드북은 최대 한 번만 사용되거나 아예 사용되지 않는다. 코드북이 사용되면, 해당 값은 학습된 임베딩 테이블을 통해 표현되고, 사용되지 않으면 특별 토큰으로 표시된다. 이렇게 변환된 각 코드북의 기여를 합산하며, 첫 번째 입력은 모든 특별 토큰의 합이 된다. 마지막으로, 현재 단계를 인코딩하기 위해 사인 임베딩을 합산한다.&lt;/p>
&lt;p>&lt;strong>Transformer decoder.&lt;/strong> 입력값은 여러 layer와 차원을 가진 transformer를 통해 처리된다. 각 layer는 causal self-attention block으로 구성되고, 조건부 신호 $C$에 따라 cross-attention block을 사용한다. 멜로디 조건을 사용할 경우, 조건부 텐서 $C$를 transformer 입력의 접두어로 사용한다. layer는 fully connected block으로 끝나며, 이 block은 linear layer, ReLU, 그리고 다시 linear layer로 구성된다. 각 block은 residual skip 연결로 래핑되고, 각 block에는 layer normalization가 적용된다.&lt;/p>
&lt;p>&lt;strong>Logits prediction.&lt;/strong> transformer decoder의 출력은 패턴 단계에서 $Q$의 값에 대한 logit 예측으로 변환된다. 코드북이 존재하면, 코드북 특정 linear layer를 적용하여 logit 예측을 얻는다.&lt;/p>
&lt;hr>
&lt;h2 id="experimental-setup">Experimental setup&lt;/h2>
&lt;h3 id="models-and-hyperparameters">Models and hyperparameters&lt;/h3>
&lt;p>&lt;strong>Audio tokenization model.&lt;/strong> 32 kHz 단음 오디오를 위한 비인과적인 5층 EnCodec 모델을 사용하며, 이는 50 Hz의 frame rate와 initial hidden size 64를 가진다. 4개의 양자화기를 가진 RVQ로 임베딩을 양자화하고, 오디오 시퀀스에서 무작위로 잘린 1초 오디오 세그먼트로 모델을 학습시킨다.&lt;/p>
&lt;p>&lt;strong>Transformer model.&lt;/strong> 300M, 1.5B, 3.3B parameter의 크기를 가진 autoregressive transformer 모델을 학습시킨다. 이 모델들은 긴 시퀀스의 처리 속도와 메모리 사용량을 개선하기 위해 memory efficient Flash attention을 사용한다. 이 기술은 xFormers 패키지에서 구현되어 있다.&lt;/p>
&lt;p>이 모델들은 전체 음악 트랙에서 무작위로 샘플링된 30초 오디오 클립을 학습 데이터로 사용한다. 각 모델은 1M 단계 동안 AdamW optimizer를 사용하여 학습되며, batch size는 192, $\beta_1$은 0.9, $\beta_2$는 0.95, weight decay는 0.1, 그리고 gradient clipping은 1.0의 값을 가진다.&lt;/p>
&lt;p>300M parameter 모델의 경우, D-Adaptation 기반의 automatic step-size를 사용하여 모델의 수렴을 개선한다. 이 방법은 모델의 크기가 더 큰 경우에는 별다른 효과가 없었다.&lt;/p>
&lt;p>모델의 learning rate은 4000 step의 warmup을 가진 cosine learning rate을 따르며, 이동 평균은 0.99의 decay를 사용하여 계산된다.&lt;/p>
&lt;p>각 모델은 각각 32, 64, 96의 GPU를 사용하여 학습되며, mixed precision 방식을 사용한다. 더욱이, bfloat16이 시스템에서 불안정성을 초래하므로 float16을 사용한다.&lt;/p>
&lt;p>마지막으로, 샘플링 과정에서는 top-k 샘플링 방법을 사용하여 상위 250개의 토큰만을 유지하고, 이 토큰들의 확률 분포를 이용하여 샘플링을 진행한다. 이때의 temperature 값은 1.0이다.&lt;/p>
&lt;p>&lt;strong>Text preprocessing.&lt;/strong> Kreuk et al. 은 불용어를 제거하고 텍스트를 표제어화하는 텍스트 정규화 방법을 제안하였다. 음악 데이터셋에서는 음악 키, 템포, 악기 유형 등의 추가 정보를 텍스트 설명에 병합하는 실험을 진행하였다. 또한, 단어 dropout을 텍스트 augmentation 전략으로 사용하였다. 최종 모델에서는 0.25 확률로 정보 병합, 0.5 확률로 텍스트 dropout, 0.3 확률로 단어 dropout을 적용하였다.&lt;/p>
&lt;p>&lt;strong>Codebook patterns and conditioning.&lt;/strong> 30초의 오디오를 1500개의 autoregressive step으로 변환하는 &amp;ldquo;delay&amp;rdquo; 교차 패턴을 사용한다. 텍스트 조건 부여에는 T5 텍스트 encoder를 사용하며, 필요에 따라 멜로디 조건 부여를 추가한다. FLAN-T5와 CLAP를 실험하고, 각 텍스트 encoder의 성능을 비교하였다. 멜로디 조건 부여에는 chromagram을 계산하고 양자화하는 방법을 사용하였다. 학습 중에는 조건을 일정 확률로 드롭하고, 추론 시에는 가이드 스케일을 적용한다.&lt;/p>
&lt;h3 id="datasets">Datasets&lt;/h3>
&lt;p>&lt;strong>Training datasets.&lt;/strong> 20K 시간의 라이선스 음악, 내부 데이터셋의 10K 고품질 음악 트랙, 그리고 ShutterStock과 Pond5 음악 데이터 컬렉션을 사용하여 MusicGEN을 학습시킨다. 이 데이터셋들은 모두 텍스트 설명, 장르, BPM, 태그 등의 메타데이터와 함께 32 kHz로 샘플링된 전체 길이의 음악을 포함하며, 오디오는 모노로 다운믹스된다.&lt;/p>
&lt;p>&lt;strong>Evaluation datasets.&lt;/strong> MusicCaps 벤치마크에서 평가하였다. 이 벤치마크는 전문 음악가들이 준비한 5.5K의 샘플과 장르별로 균형을 이루는 1K의 샘플로 구성되어 있다. 균형되지 않은 샘플에서 객관적 지표를 보고하고, 질적 평가를 위해 장르 균형 샘플에서 예제를 추출하였다. 또한, 멜로디 평가와 소거 연구를 위해 학습 세트와 아티스트가 중복되지 않는 528개의 음악 트랙으로 구성된 평가 세트를 사용하였다.&lt;/p>
&lt;h3 id="evaluation">Evaluation&lt;/h3>
&lt;p>&lt;strong>Baselines.&lt;/strong> Riffusion과 Mousai, 두 가지 text-to-music 생성 모델과 MusicGEN을 비교한다. 오픈소스 Riffusion 모델을 이용해 추론을 실행하고, Mousai의 경우 저자들이 제공한 오픈소스를 이용해 이 연구의 데이터셋으로 모델을 학습시켜 비교하였다. 가능한 경우, MusicLM과 Noise2Music과도 비교하였다.&lt;/p>
&lt;p>&lt;strong>Evaluation metrics.&lt;/strong> 객관적인 지표인 Fréchet Audio Distance(FAD), Kullback-Leiber Divergence(KL), 그리고 CLAP 점수를 이용하여 제안한 방법을 평가한다. FAD 점수는 생성된 오디오의 타당성을 나타내며, KL-Divergence는 원본 음악과 생성된 음악 사이의 레이블 확률을 비교한다. 이때, KL이 낮을수록 생성된 음악이 원본 음악과 유사한 개념을 가지고 있다고 판단한다. 마지막으로, CLAP 점수는 트랙 설명과 생성된 오디오 사이의 정렬을 정량화한다.&lt;/p>
&lt;p>인간 평가자들을 활용하여 overall quality(OVL)과 relevance to the text input(REL)을 평가하는 연구를 진행하였다. 평가자들은 제공된 오디오 샘플의 품질과 텍스트와의 일치도를 각각 1에서 100의 범위로 평가하였다. 이 평가는 Amazon Mechanical Turk 플랫폼에서 모집한 평가자들을 통해 진행되었고, 각 샘플은 최소 5명의 평가자에 의해 평가되었다. 잡음 주석과 이상치는 CrowdMOS 패키지를 통해 필터링하였으며, 모든 샘플은 공정성을 위해 -14dB LUFS에서 정규화되었다.&lt;/p>
&lt;hr>
&lt;h2 id="results">Results&lt;/h2>
&lt;p>text-to-music 생성 작업에 대한 제안된 방법의 결과를 제시하며, 이전의 연구와 비교한다. 또한, 멜로디 특징에 기반한 음악 생성 능력을 평가하고, 스테레오 오디오 생성을 위해 코드북 패턴을 확장하는 방법을 설명한다.&lt;/p>
&lt;h3 id="comparison-with-the-baselines">Comparison with the baselines&lt;/h3>
&lt;p>&lt;img src="https://kurtkim.github.io/p/musicgen/images/table1.png"
width="1132"
height="372"
srcset="https://kurtkim.github.io/p/musicgen/images/table1_hu82e130725237512cebe1a4c4f1872ed9_104459_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/musicgen/images/table1_hu82e130725237512cebe1a4c4f1872ed9_104459_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="304"
data-flex-basis="730px"
>&lt;/p>
&lt;p>제안된 방법과 Mousai, Riffusion, MusicLM, 그리고 Noise2Music와의 비교 한다. Noise2Music과 MusicLM의 공식 구현이 없으므로, 각각의 원고에서 보고된 FAD만을 보고한다. 인간 연구에서는 MusicCaps의 악기만을 사용한 40개 샘플을 사용하였으며, MusicGEN의 chromagram 학습에서 누수를 방지하기 위해 테스트 시간 동안 보류된 세트에서 무작위로 chromagram을 샘플링하였다.&lt;/p>
&lt;p>결과적으로 MusicGEN은 오디오 품질과 텍스트 설명 준수 측면에서 인간 청취자들에게 더 높은 평가를 받았다. Noise2Music은 MusicCaps에서 FAD 측면에서 가장 우수했으며, 텍스트 조건부로 학습된 MusicGEN이 뒤를 이었다. 멜로디 조건을 추가하면 객관적 지표가 저하되지만, 인간 평가에는 큰 영향을 미치지 않았다.&lt;/p>
&lt;p>낮은 평가를 받은 모델에 대해서는 FAD가 주관적 평가와 상관관계가 있지만, 높은 평가를 받은 모델에는 그러지 않았다. 또한, MusicCaps의 많은 샘플이 &amp;ldquo;noisy&amp;rdquo; 녹음이라는 설명을 포함하고 있어, 오디오 품질 향상이 일정 수준을 넘어설 경우 FAD가 악화될 수 있다는 사실을 발견하였다.&lt;/p>
&lt;h3 id="melody-evaluation">Melody evaluation&lt;/h3>
&lt;p>&lt;img src="https://kurtkim.github.io/p/musicgen/images/table2.png"
width="974"
height="192"
srcset="https://kurtkim.github.io/p/musicgen/images/table2_hu84589e5fca9f397abb8c20fca19cbe40_51604_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/musicgen/images/table2_hu84589e5fca9f397abb8c20fca19cbe40_51604_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="507"
data-flex-basis="1217px"
>&lt;/p>
&lt;p>텍스트와 멜로디를 동시에 고려하는 MusigGEN을 객관적, 주관적 지표로 평가하였다. 이를 위해 새로운 지표인 chroma cosine-similarity를 도입하였으며, 이는 참조 샘플과 생성된 샘플의 chroma 사이의 average cosine-similarity를 측정한다. 또한, 인간 연구를 통해 생성된 음악과 멜로디 사이의 관계를 평가하였다. 결과적으로 MusigGEN은 주어진 멜로디를 따르는 음악을 성공적으로 생성하며, chroma를 떨어뜨려도 성능이 유지되는 것으로 나타났다.&lt;/p>
&lt;h3 id="fine-tuning-for-stereophonic-generation">Fine-tuning for stereophonic generation&lt;/h3>
&lt;p>&lt;img src="https://kurtkim.github.io/p/musicgen/images/figure2.png"
width="1160"
height="518"
srcset="https://kurtkim.github.io/p/musicgen/images/figure2_hu82a0dfe475666588aef20e9ef9119079_204671_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/musicgen/images/figure2_hu82a0dfe475666588aef20e9ef9119079_204671_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="223"
data-flex-basis="537px"
>&lt;/p>
&lt;p>스테레오 데이터로의 생성을 확장하려는 실험을 진행하였다. 동일한 EnCodec 토크나이저를 사용하여 왼쪽과 오른쪽 채널에 독립적으로 적용하였고, 사전 학습된 단일 음향 MusicGEN 모델을 스테레오 오디오를 포함하는 데이터셋으로 미세 조정하였다. &amp;ldquo;delay&amp;rdquo; 패턴을 재사용하고, &amp;ldquo;stereo delay&amp;quot;과 &amp;ldquo;stereo partial delay&amp;rdquo; 두 가지 변형을 도입하였다. 이 간단한 전략을 통해 추가적인 계산 비용 없이 스테레오 오디오를 생성할 수 있었다. 스테레오 출력을 모노로 다운믹싱하면, 모노 모델과 거의 동등한 품질을 느낄 수 있었다. 전반적으로 스테레오 오디오가 모노보다 높게 평가되었으며, &amp;ldquo;stereo partial delay&amp;quot;이 &amp;ldquo;stereo delay&amp;quot;에 비해 전반적인 품질과 텍스트 관련성에서 약간의 향상을 보였습니다.&lt;/p>
&lt;h3 id="ablation">Ablation&lt;/h3>
&lt;p>다양한 코드북 패턴의 제거 연구와 모델 크기, 기억 연구 결과를 소개한다. 이 모든 연구는 보류된 평가 세트에서 임의로 샘플링된 30초 분량의 1K 샘플을 사용하여 수행되었다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/musicgen/images/table4.png"
width="1022"
height="318"
srcset="https://kurtkim.github.io/p/musicgen/images/table4_huf62e92f64d1bdb73d42bde58b852d6de_88931_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/musicgen/images/table4_huf62e92f64d1bdb73d42bde58b852d6de_88931_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="321"
data-flex-basis="771px"
>&lt;/p>
&lt;p>&lt;strong>The effect of the codebook interleaving patterns.&lt;/strong> 여러 코드북 패턴을 평가하였다. 이는 &amp;ldquo;delay&amp;rdquo;, &amp;ldquo;partial delay&amp;rdquo;, &amp;ldquo;parallel&amp;rdquo;, &amp;ldquo;coarse first&amp;rdquo;, &amp;ldquo;Partial flattening&amp;rdquo;, &amp;ldquo;flattening&amp;rdquo; 등의 패턴을 포함한다. 이 중 &amp;ldquo;flattening&amp;rdquo; 패턴은 생성을 개선하지만 높은 계산 비용이 들며, 간단한 &amp;ldquo;delay&amp;rdquo; 방식을 사용하면 비슷한 성능을 더 적은 비용으로 달성할 수 있음을 발견하였다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/musicgen/images/table5.png"
width="1076"
height="196"
srcset="https://kurtkim.github.io/p/musicgen/images/table5_hud8b26f41b0e31e8e2f3e6f87f76a2efe_54637_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/musicgen/images/table5_hud8b26f41b0e31e8e2f3e6f87f76a2efe_54637_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="548"
data-flex-basis="1317px"
>&lt;/p>
&lt;p>&lt;strong>The effect of model size.&lt;/strong> 다양한 모델 크기(300M, 1.5B, 3.3B parameter)에 대한 결과를 보고하였다. 모델 크기를 크게하면 성능이 향상되지만, 학습과 추론 시간이 더 길어진다. 주관적인 품질은 1.5B에서 최적이며, 더 큰 모델은 텍스트 프롬프트를 더 잘 이해한다.&lt;/p>
&lt;p>&lt;strong>Memorization experiment.&lt;/strong> 우리는 MusicGEN의 기억능력을 분석하였다. 학습 세트에서 20,000개의 예제를 무작위로 선택하고, 각각에 대해 원본 오디오에 해당하는 프롬프트를 모델에 입력하였다. greedy decoding을 사용하여 5초 길이의 오디오를 생성하고, 생성된 오디오와 원본 오디오가 일치하는 비율을 보고하였다. 또한, 80% 이상 일치하는 경우의 비율도 보고하였다.&lt;/p>
&lt;hr>
&lt;h2 id="related-work">Related work&lt;/h2>
&lt;p>&lt;strong>Audio representation.&lt;/strong> 최근 연구는 음악 신호를 압축된 표현으로 변환하고 이를 기반으로 생성 모델을 적용하는 방식을 주로 사용하고 있다. Lakhotia et al. 은 k-means를 사용한 음성 표현의 양자화를, Défossez et al. 과 Zeghidour et al. 은 residual vector quantization를 사용한 원시 파형에 대한 VQ-VAE 적용을 제안하였다. 이러한 방법들은 텍스트에서 오디오로의 생성에 활용되고 있다.&lt;/p>
&lt;p>&lt;strong>Music generation.&lt;/strong> 음악 생성은 다양한 방법으로 연구되어 왔다. Dong et al. 은 GAN을 사용한 심볼symbolic릭 음악 생성을, Bassan et al. 은 symbolic 음악의 비지도학습 분할을 제안하였다. Ycart et al. 은 RNN을 이용한 polyphonic 음악 모델링을, Ji et al. 은 음악 생성에 대한 딥러닝 방법들을 포괄적으로 조사하였다.&lt;/p>
&lt;p>Dhariwal et al. 은 hierarchical VQ-VAE를 사용하여 음악 샘플을 discrete representation으로 변환하고, 이를 통해 음악을 생성하는 방법을 제안하였다. Gan et al. 은 주어진 비디오에 대한 음악을 생성하면서 미디 노트를 예측하는 방법을, Agostinelli et al. 은 의미 토큰과 음향 토큰을 사용하여 음악을 표현하는 방법을 제안하였다. Donahue et al. 은 이러한 접근법을 노래 동반 생성 작업에 적용하였다.&lt;/p>
&lt;p>diffusion 모델을 사용하는 것은 대안적인 접근법이다. Schneider et al., Huang et al., Maina, Forsgren and Martiros는 이를 텍스트에서 음악으로 변환하는 작업에 적용하였다. Schneider et al.과 Huang et al. 은 오디오 생성과 샘플링 비율 증가에 diffusion 모델을 사용하였다. Forsgren et al. Martiros는 5초 오디오 세그먼트 생성과 장기 시퀀스 생성을 위해 spectrogram을 이용한 diffusion 모델을 미세조정하였다.&lt;/p>
&lt;p>&lt;strong>Audio generation.&lt;/strong> 텍스트에서 오디오로 변환하는 연구가 다양하게 진행되었다. Yang et al. 은 오디오 spectrogram을 VQ-VAE를 이용해 표현하고, 이를 기반으로 텍스트 CLIP 임베딩에 조건화된 diffusion 모델을 적용하였다. Kreuk et al. 과 Sheffer와 Adi는 각각 transformer 언어 모델과 이미지-오디오 생성을 위한 접근법을 제안하였다. 또한, Huang et al. 과 Liu et al. 은 텍스트-오디오 작업을 위해 latent diffusion 모델을 사용하면서 이를 다양한 작업에 확장하는 방법을 제안하였다.&lt;/p>
&lt;hr>
&lt;h2 id="discussion">Discussion&lt;/h2>
&lt;p>텍스트와 멜로디에 따라 조절 가능한 음악 생성 모델인 MusicGEN을 소개하였다. 이 모델은 단순한 코드북 교차 전략을 통해 고품질의 음악 생성을 가능하게 하고, autoregressive 시간 단계를 줄일 수 있다. 또한 모델 크기, 조건화 방법, 텍스트 전처리 기법의 영향에 대한 포괄적인 연구를 제공하며, 생성된 오디오의 멜로디를 제어하는 chromagram 기반 조건화를 소개하였다.&lt;/p>
&lt;p>&lt;strong>Limitations&lt;/strong> 이 모델의 생성 방법은 조건에 따른 세밀한 제어를 허용하지 않아 CF guidance에 주로 의존한다. 텍스트 조건에 대한 데이터 augmentation은 상대적으로 간단하지만, 오디오 조건에 대한 데이터 augmentation와 guidance에 대해 추가 연구가 필요하다.&lt;/p>
&lt;p>&lt;strong>Broader impact.&lt;/strong> 대규모 생성 모델은 윤리적 도전을 제시한다. 모든 학습 데이터가 권리 소유자와 합의 하에 이루어지며, 데이터셋의 다양성 부족 문제를 인지하고 있다. 이 문제를 해결하기 위해 단순화된 모델을 사용하여 새로운 데이터셋에 대한 응용을 확대하고 있다. 또한, 이러한 모델이 아티스트에 대한 불공정한 경쟁을 일으킬 수 있음을 인지하며, 이 문제를 해결하기 위해 열린 연구를 통해 모든 참가자가 모델에 동등하게 접근할 수 있도록 노력하고 있다. 고급 제어 기법을 통해, 모델이 음악 애호가와 전문가 모두에게 도움이 될 수 있도록 하고 있다.&lt;/p>
&lt;hr>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>&lt;a class="link" href="https://arxiv.org/pdf/2306.05284.pdf" target="_blank" rel="noopener"
>Paper&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/facebookresearch/audiocraft" target="_blank" rel="noopener"
>Github&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>CLAP</title><link>https://kurtkim.github.io/p/clap/</link><pubDate>Tue, 16 Jan 2024 00:00:00 +0000</pubDate><guid>https://kurtkim.github.io/p/clap/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>이 연구에서는 contrastive learning을 통해 자연어 설명과 오디오 데이터를 결합한 오디오 표현을 개발하는 방법을 제안한다. 이를 위해 633,526개의 오디오-텍스트 쌍을 모은 LAION-Audio-630K를 공개하고, 이를 활용해 오디오와 텍스트를 처리하는 모델을 구축하였다. 이 모델은 텍스트-오디오 검색에서 우수한 성능을 보였고, zero-shot 오디오 분류에서는 state-of-the-art를 달성하였다.&lt;/p>
&lt;hr>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>오디오는 텍스트, 이미지와 더불어 중요한 정보 유형이지만, 세부적인 주석이 필요한 오디오 작업은 데이터 수집이 노동 집약적이어서 사용 가능한 데이터가 제한적이다. 이 때문에 많은 감독 없이 다양한 오디오 작업에 적합한 효과적인 오디오 표현을 만드는 것은 어려운 과제이다.&lt;/p>
&lt;p>Contrastive learning 방식은 인터넷에서 모아진 대규모 노이즈 데이터로 모델을 학습시키는데 효과적이다. 최근 제안된 Contrastive Language-Image Pretraining (CLIP) 방식은 텍스트와 이미지를 shared latent space에 투영하여 학습한다. 이 방식은 데이터 주석에 제약받지 않으며, ImageNet 데이터셋의 변형에 대해 zero-shot 설정에서 높은 정확도를 보여준다. 또한, 오디오와 자연어도 중복 정보를 포함하며, 이를 통해 crossmodal 정보의 오디오 표현을 형성할 수 있다. 이러한 모델 학습은 쌍으로 된 오디오와 텍스트 데이터만을 필요로 하므로 수집이 상대적으로 쉽다.&lt;/p>
&lt;p>최근 연구들은 텍스트-오디오 검색 작업에 대한 대조적(contrastive) 언어-오디오 사전 학습 모델을 제안하였다. 일부 연구는 오디오 encoder로 Pretrained Audio Neural Network (PANN)을, 텍스트 encoder로 BERT를 사용하며, 다른 연구는 성능 향상을 위해 HTSAT와 RoBERTa를 추가로 앙상블하였다. 또한, AudioClip과 WaveCLIP과 같은 연구들은 이미지-오디오(또는 이미지-오디오-언어) 사전 학습 모델에 초점을 맞추었다. 이러한 모든 모델들은 오디오 도메인에서의 대조적 학습에 큰 잠재력을 보여주고 있다.&lt;/p>
&lt;p>현재의 언어-오디오 대조적 학습 연구들은 전체적인 강점을 아직 다 보여주지 못하였다. 모델들은 대부분 작은 데이터셋에서 학습되었고, 오디오/텍스트 encoder의 선택과 hyperparameter 설정에 대한 충분한 조사가 없었다. 또한, 모델들은 다양한 길이의 오디오를 처리하는 데 어려움을 겪었으며, 텍스트-오디오 검색에만 초점을 맞추고 downstream task에서의 오디오 표현을 평가하지 않았다. 이러한 문제점들을 해결하고 더 많은 하downstream task에 대한 일반화 능력을 발견하는 것이 필요하다.&lt;/p>
&lt;p>이 논문에서는 이전 연구를 바탕으로, 위의 문제점들을 개선하기 위해 데이터셋, 모델 설계, 실험 설정에 대한 기여를 한다:&lt;/p>
&lt;ul>
&lt;li>이 논문에서는 633,526개의 오디오-텍스트 쌍을 포함하는 현재 가장 큰 공개 오디오 캡션 데이터셋인 LAION-Audio-630K를 공개하고, 학습 과정을 돕기 위해 키워드-캡션 모델을 활용해 AudioSet의 레이블을 캡션으로 확장하였다. 이 데이터셋은 다른 오디오 작업에도 활용될 수 있다.&lt;/li>
&lt;li>이 논문에서는 대조적 언어-오디오 사전 학습 파이프라인을 구축하고, 이를 위해 두 개의 오디오 인코더와 세 개의 텍스트 인코더를 선택하였다. 또한, 성능 향상과 variable-length inputs 처리를 위해 feature fusion mechanism을 활용하였다.&lt;/li>
&lt;li>이 논문에서는 텍스트-오디오 검색과 zero-shot 및 지도 오디오 분류와 같은 downstream task에 대한 모델의 포괄적인 실험을 수행하였다. 데이터셋의 확장, keyword-to-caption augmentation, feature fusion이 모델 성능을 향상시키는 데 도움이 된다는 것을 보여주었다. 이를 통해 텍스트-오디오 검색과 오디오 분류 작업에서 state-of-the-art를 달성하였다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="laion-audio-630k-and-training-dataset">LAION-Audio-630K And Training Dataset&lt;/h2>
&lt;h3 id="laion-audio-630k">LAION-Audio-630K&lt;/h3>
&lt;p>&lt;img src="https://kurtkim.github.io/p/clap/images/table1.png"
width="664"
height="206"
srcset="https://kurtkim.github.io/p/clap/images/table1_huc915c892c5fa79f7a24207ab27da5b09_35590_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/clap/images/table1_huc915c892c5fa79f7a24207ab27da5b09_35590_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="322"
data-flex-basis="773px"
>&lt;/p>
&lt;p>LAION-Audio-630K는 총 4,325.39시간에 걸친 633,526쌍의 오디오-텍스트 데이터셋을 수집하였다. 이 데이터셋은 사람의 활동, 자연 소리, 오디오 효과 등을 포함하며, 공개적으로 사용 가능한 여러 웹사이트에서 수집하였다. 현재로서는 LAION-Audio-630K가 공개적으로 이용 가능한 가장 큰 오디오-텍스트 데이터셋이다.&lt;/p>
&lt;h3 id="training-dataset">Training Dataset&lt;/h3>
&lt;p>이 논문에서는 모델 성능이 데이터셋의 크기와 유형에 따라 어떻게 변화하는지 테스트하기 위해, 세 가지 학습 세트 설정을 사용하였다. 이들 설정은 AudioCaps+Clotho (약 55K 샘플), LAION-Audio-630K (약 630K 샘플), Audioset (1.9 백만 오디오 샘플)을 포함하며, 모든 중복 데이터는 제외하였다.&lt;/p>
&lt;h3 id="dataset-format-and-preprocessing">Dataset Format and Preprocessing&lt;/h3>
&lt;p>이 작업에서 사용된 모든 오디오 파일은 48kHz sample rate의 mono channel로 전처리되었다. 레이블만 있는 데이터셋의 경우, 템플릿이나 키워드-캡션 모델을 사용해 레이블을 캡션으로 확장하였다. 이를 통해 대조적 언어-오디오 사전 학습 모델의 학습에 더 많은 데이터를 활용할 수 있게 되었고, 총 오디오 샘플 수는 2.5M개로 증가하였다.&lt;/p>
&lt;hr>
&lt;h2 id="model-architecture">Model Architecture&lt;/h2>
&lt;h3 id="contrastive-language-audio-pretraining">Contrastive Language-Audio Pretraining&lt;/h3>
&lt;p>&lt;img src="https://kurtkim.github.io/p/clap/images/figure1.png"
width="680"
height="972"
srcset="https://kurtkim.github.io/p/clap/images/figure1_huef2bf2bcce39fef884bc41272d03fdcb_166045_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/clap/images/figure1_huef2bf2bcce39fef884bc41272d03fdcb_166045_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="69"
data-flex-basis="167px"
>&lt;/p>
&lt;p>오디오 데이터 $X_i^a$와 텍스트 데이터 $X_i^t$의 입력을 각각 처리하기 위해 두 개의 encoder를 사용한다. 여기서 $(X_i^a, X_i^t)$는 $i$로 색인된 오디오-텍스트 쌍 중 하나이다. 오디오 임베딩 $E_i^a$와 텍스트 임베딩 $E_i^t$는 각각 오디오 encoder $\mathbf{f}_{audio}(\cdot)$와 텍스트 encoder $\mathbf{f}_{text}(\cdot)$에 의해 얻어지며, projection layer를 사용한다:&lt;/p>
&lt;p>$$ E_i^a = \text{MLP}_{audio}(\mathbf{f}_{audio}(X_i^a)) $$&lt;/p>
&lt;p>$$ E_i^t = \text{MLP}_{text}(\mathbf{f}_{text}(X_i^t)) $$&lt;/p>
&lt;p>오디오/텍스트 projection layer는 2-layer multilayer perceptron(MLP)이다. 이는 ReLU activation function을 사용하여 encoder ouptput을 동일한 차원 $D$로 매핑한다(i.e., $E_i^a, E_i^t \in \mathbb{R}^D$). 이로 인해 오디오 데이터와 텍스트 데이터의 관계를 더 잘 파악할 수 있다.&lt;/p>
&lt;p>이 모델은 오디오와 텍스트 임베딩 간의 contrastive learning을 통해 학습되며, 이 때 다음의 loss function를 사용한다:&lt;/p>
&lt;p>$$ \mathbf{L} = {{1}\over{2N}} \sum_{i=1}^N (log {{exp(E_i^a \cdot E_i^t / \gamma)}\over{\sum_{j=1}^N exp(E_i^a \cdot E_j^t / \gamma)}} + log {{exp(E_i^t \cdot E_a^t / \gamma)}\over{\sum_{j=1}^N exp(E_i^t \cdot E_j^a / \gamma)}})$$&lt;/p>
&lt;p>$\gamma$는 손실을 조정하는 학습 가능한 parameter이며, 로그항은 오디오-텍스트 또는 텍스트-오디오 변환을 고려한다. $N$은 일반적으로 데이터 수를 나타내지만, 효율적인 학습을 위해 학습 시 배치 크기로 사용된다.&lt;/p>
&lt;p>학습된 모델의 임베딩$(E^a, E^b)$은 다양한 문맥에서 활용되어, 각 작업에 따른 성능을 향상시키는 데 도움을 준다.&lt;/p>
&lt;h3 id="downstream-tasks-in-inference-stage">Downstream Tasks in Inference Stage&lt;/h3>
&lt;p>&lt;strong>Text-to-Audio Retrieval&lt;/strong> target 오디오 임베딩 $E_p^a$는 cosine similarity 함수를 사용하여 $M$개의 텍스트 임베딩 $E^t = \lbrace E_1^t, &amp;hellip;, E_M^t \rbrace$중에서 가장 가까운 텍스트 임베딩 $E_q^t$를 찾아, 가장 잘 매치되는 텍스트를 결정할 수 있다. 이는 오디오와 텍스트 간의 가장 적합한 대응을 찾는데 사용된다.&lt;/p>
&lt;p>&lt;strong>Zero-shot Audio Classiﬁcation&lt;/strong> $M$개의 오디오 클래스 $C = \lbrace C_1, &amp;hellip;, C_M \rbrace$에 대해, $M$개의 프롬프트 텍스트 $X^t = \lbrace X_1^t, &amp;hellip;, X_M^t \rbrace$를 구성하고, 주어진 오디오 $X_p^a$에 대해 코사인 유사도를 통해 $X^t$중에서 가장 최적의 매치 $X_q^t$를 찾는다. 이 방법의 장점은 오디오 카테고리가 제한되지 않고, 분류 작업을 텍스트-오디오 검색 작업으로 변환할 수 있다는 점이다.&lt;/p>
&lt;p>&lt;strong>Supervised Audio Classiﬁcation&lt;/strong> 모델 학습 후, 주어진 오디오 $X_p^a$의 임베딩 $E_p^a$은 projection layer를 추가하고 미세조정하여 고정 카테고리 분류 작업으로 매핑될 수 있다.&lt;/p>
&lt;h3 id="audio-encoders-and-text-encoders">Audio Encoders and Text Encoders&lt;/h3>
&lt;p>PANN과 HTSAT 두 모델을 오디오 encoder로 선택하였다. PANN은 CNN 기반, HTSAT은 transformer 기반 모델이며, 둘 다 바로 앞(penultimate) layer의 output $L$을 MLP layer으로 보낸다다. 각각의 output 차원 $L_{PANN} = 2048$, $L_{HTSAT} = 768$이다.&lt;/p>
&lt;p>텍스트 encoder로 CLIP transformer, BERT, RoBERTa를 선택하였다다. output 차원은 각각 $L_{CLIP} = 512$, $L_{BERT} = 768$, $L_{RoBERTa} = 768$이며, 오디오와 텍스트 output을 모두 512 차원으로 매핑하기 위해 2layer MLP를 적용하였다.&lt;/p>
&lt;h3 id="feature-fusion-for-variable-length-audio">Feature Fusion for Variable-Length Audio&lt;/h3>
&lt;p>오디오는 길이가 가변적인 특성을 가지기 때문에, 전체 오디오를 인코더에 입력하고 임베딩의 평균을 출력하는 전통적인 방식은 계산 효율이 떨어진다. 따라서 대략적인 전역 정보와 랜덤 샘플링된 지역 정보를 결합하여 다양한 길이의 오디오에 대해 일정한 계산 시간 내에서 학습하고 추론한다.&lt;/p>
&lt;p>$T$초의 오디오와 ﬁxed chunk duration $d = 10$초에 대해:&lt;/p>
&lt;ul>
&lt;li>$T \leq d$인 경우: 먼저 입력을 반복한 다음, 그것을 0값으로 채운다. 예를 들어, 3초의 입력은 $3 \times 3 = 9$초로 반복되고, 1초의 0 값으로 패딩된다. 이 방식은 짧은 오디오 입력에 대해 효과적으로 처리할 수 있게 해준다.&lt;/li>
&lt;li>$T &amp;gt; d$인 경우: 먼저 입력을 $T$에서 $d$초로 다운샘플링하여 전역 입력으로 사용한다. 그런 다음 입력의 앞 ${1}\over{3}$, 중간 ${1}\over{3}$, 뒤 ${1}\over{3}$에서 각각 무작위로 $d$초 클립을 슬라이스하여 지역 입력으로 사용한다. 우리는 이 $4 \times d$ 입력들을 오디오 encoder의 첫 번째 layer로 보내어 초기 특징을 얻고, 그런 다음 세 개의 지역 특징들이 시간 축에서 3-stride를 가진 다른 2D-Convolution 계층에 의해 하나의 특징으로 변환된다. 마지막으로, 지역 특징 $X_{local}^a$와 전역 특징 $X_{global}^a$는 다음과 같이 결합된다:&lt;/li>
&lt;/ul>
&lt;p>$$ X_{fusion}^a = \alpha X_{global}^a + (1 - \alpha)X_{local}^a $$&lt;/p>
&lt;p>여기서 $\alpha = \mathbf{f}_{AFF}(X_{global}^a, X_{local}^a)$는 두 입력의 결합 요소를 학습하기 위한 두 개의 분기를 가진 CNN 모델인 attention feature fusion (AFF)에 의해 얻어진 요소이다. &amp;ldquo;slice &amp;amp; vote&amp;rdquo; 방법과 비교하여, 특징 결합은 첫 몇 개의 layer에서만 오디오 슬라이스를 처리하기 때문에 학습 시간을 절약한다. 이 방식은 긴 오디오 입력에 대해 효과적으로 처리할 수 있게 해준다.&lt;/p>
&lt;h3 id="keyword-to-caption-augmentation">Keyword-to-Caption Augmentation&lt;/h3>
&lt;p>일부 데이터셋에서는 오디오에 대응하는 키워드로 레이블이나 태그를 사용한다. 이러한 키워드를 바탕으로 사전 학습된 언어 모델 T5를 사용하여 캡션을 생성하며, output 문장에서 편향을 제거하는 후처리를 진행한다. 예를 들어, &amp;ldquo;여성&amp;quot;과 &amp;ldquo;남성&amp;quot;을 &amp;ldquo;사람&amp;quot;으로 교체하여 성별 편향을 제거한다.&lt;/p>
&lt;hr>
&lt;h2 id="experiments">Experiments&lt;/h2>
&lt;p>제안한 모델에 대해 세 가지 실험을 수행한다. 다양한 encoder를 사용해 최적의 조합을 찾고, 다양한 데이터셋 크기에서 특징 결합과 keyword-to-caption augmentation을 적용해 효과를 검증하며, 오디오-텍스트 검색과 텍스트-오디오 검색에서의 성능을 평가한다. 마지막으로 최적의 모델로 zero-shot과 지도 오디오 분류 실험을 수행한다.&lt;/p>
&lt;h3 id="hyperparameters-and-training-details">Hyperparameters and Training Details&lt;/h3>
&lt;p>AudioCaps, Clotho, LAIONAudio-630K, AudioSet 데이터셋을 사용해 모델을 학습시킨다. 오디오 데이터는 10-second input length, 480 hop size, 1024 window size, 64 mel-bins으로 처리하며, 입력은 $(T = 1024, F = 64)$의 형태를 가진다. 텍스트 데이터는 최대 토큰 길이를 77로 토큰화한다.&lt;/p>
&lt;p>10초보다 긴 오디오는 무작위로 10초 세그먼트로 분할한다. 학습 중에는 $\beta_1 = 0.99, \beta_2 = 0.9$의 Adam optimizer를 사용하고, warm-up과 learning rate $10^{−4}$의 cosine learning rate decay를 사용한다. AudioCaps+Clotho 데이터셋에서는 batch size를 768로, LAION-Audio-630K를 포함하는 학습 데이터셋에서는 2304로, AudioSet을 포함하는 학습 데이터셋에서는 4608로 설정하여 모델을 학습시킵니다. 모델은 총 45 에포크 동안 학습된다.&lt;/p>
&lt;h3 id="text-to-audio-retrieval">Text-to-Audio Retrieval&lt;/h3>
&lt;p>&lt;strong>Audio and Text Encoders&lt;/strong> 텍스트-오디오 검색을 위해 가장 적합한 오디오와 텍스트 encoder를 찾기 위해 실험을 진행하였다. 이를 위해 두 오디오 encoder와 세 텍스트 encoder를 결합하고, AudioCaps와 Clotho 데이터셋에서 학습을 진행하였다. 이 실험의 목표는 최적의 encoder 조합을 찾는 것이다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/clap/images/table2.png"
width="592"
height="214"
srcset="https://kurtkim.github.io/p/clap/images/table2_hueb35c23a5ca995604e43931c9ca5897a_39395_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/clap/images/table2_hueb35c23a5ca995604e43931c9ca5897a_39395_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="276"
data-flex-basis="663px"
>&lt;/p>
&lt;p>HTSAT 오디오 encoder는 PANN보다 더 좋은 성능을 보이고, 텍스트 encoder는 RoBERTa가 BERT보다 우수하며, CLIP transformer는 가장 성능이 낮다. 또한, RoBERTa는 overfit이 덜 발생하지만, CLIP transformer는 overfit이 많아 일반화 성능이 낮다.&lt;/p>
&lt;p>&lt;strong>Dataset Scale&lt;/strong> HTSAT-RoBERTa 모델을 사용하여 텍스트-오디오 검색 실험을 수행하였다. 데이터셋 크기를 점차 늘렸지만, &amp;ldquo;AudioCaps + Clotho&amp;quot;에서 &amp;ldquo;LA.&amp;ldquo;로 확대해도 AudioCaps의 성능은 개선되지 않았다. 하지만 Clotho 세트에서의 성능은 향상되었다. 이는 AudioCaps가 사전 학습된 AudioSet와 유사한 오디오를 포함하고 있기 때문이며, 다른 출처의 데이터를 더 많이 받게 되면, 모델의 일반화는 증가하지만 AudioSet 데이터의 분포에서 벗어나게 된다. 따라서, AudioCaps의 성능은 떨어지지만, Clotho의 성능은 향상되었다. 이는 다양한 오디오 유형 간의 성능 유지에 대한 타협을 보여준다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/clap/images/table3.png"
width="1358"
height="282"
srcset="https://kurtkim.github.io/p/clap/images/table3_hu33d594c9c09d66373764e22f05571ae3_107352_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/clap/images/table3_hu33d594c9c09d66373764e22f05571ae3_107352_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="481"
data-flex-basis="1155px"
>&lt;/p>
&lt;p>&lt;strong>Keyword-to-Caption and Feature Fusion&lt;/strong> feature fusion mechanism과 keyword-to-caption augmentation를 모델에 추가하면 성능이 향상된다. Clotho 데이터셋에서는 특히 효과적이다. AudioSet을 학습 세트에 추가하면 AudioCaps의 성능은 증가하지만 Clotho에서는 감소하는 것을 확인할 수 있다. 이는 AudioCaps와 Clotho 간의 성능 타협을 재확인한다. 또한, keyword-to-caption augmentation는 대부분의 지표에서 단순 템플릿 텍스트 프롬프팅보다 더 나은 성능을 보인다.&lt;/p>
&lt;p>최적 모델은 텍스트-오디오 검색에서 대부분의 지표에서 이전 방법보다 우수하며, 특히 AudioCaps에서 36.7%, Clotho에서 18.2%의 결과를 보여주었다. 대규모 데이터셋에서의 학습과 feature fusion은 모델 성능을 효과적으로 개선시킨다는 것을 입증하였다.&lt;/p>
&lt;h3 id="zero-shot-and-supervised-audio-classiﬁcation">Zero-shot and Supervised Audio Classiﬁcation&lt;/h3>
&lt;p>&lt;strong>Zero-shot Audio Classiﬁcation&lt;/strong> 모델의 일반화와 견고성을 평가하기 위해, 세 가지 주요 모델에 대해 zero-shot 오디오 분류 실험을 수행하였다. 이 모델들은 ESC50, VGGSound, Urbansound8K 데이터셋에서 평가되었고, top-1 정확도를 지표로 사용했다. &amp;ldquo;This a sound of label.&amp;rdquo; 형식의 텍스트 프롬프트를 사용하여 오디오를 분류하였다. 학습 데이터와 테스트 데이터셋간에 겹치는 부분은 제외하고 평가를 진행하였다.&lt;/p>
&lt;p>&lt;strong>Supervised Audio Classiﬁcation&lt;/strong> FSD50K와 VGGSound 데이터셋에서 오디오 encoder를 미세 조정하여 지도 학습 오디오 분류를 수행하였다. ESC50와 Urbansound8K는 데이터 유출 문제로 인해 실험을 수행하지 않았다. FSD50K 평가에는 mAP를 지표로 사용하였다.&lt;/p>
&lt;p>&lt;img src="https://kurtkim.github.io/p/clap/images/table4.png"
width="664"
height="280"
srcset="https://kurtkim.github.io/p/clap/images/table4_hue3d9dda28790c2573ee91b7137dfa0ae_55869_480x0_resize_box_3.png 480w, https://kurtkim.github.io/p/clap/images/table4_hue3d9dda28790c2573ee91b7137dfa0ae_55869_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="237"
data-flex-basis="569px"
>&lt;/p>
&lt;p>세 가지 데이터셋에서 zero-shot 오디오 분류의 state-of-the-art를 보여주며, 이는 보이지 않는 데이터에 대한 모델의 높은 일반화 능력을 입증한다. feature fusion mechanism과 keyword-to-caption augmentation은 모델 성능을 향상시키는 데 기여하며, 우리의 지도 학습 오디오 분류 결과는 VGGSound에서 최고 성능을, FSD50K에서는 가장 가까운 성능을 보여주었다. 이 결과는 제안된 모델이 효과적인 오디오 표현을 학습한다는 것을 확인한다.&lt;/p>
&lt;h3 id="conclusion-and-futrue-work">Conclusion And Futrue Work&lt;/h3>
&lt;p>이 논문에서는 대규모 오디오-텍스트 데이터셋을 제안하고 언어-오디오 contrastive learning 패러다임을 개선하였다. LAION-Audio-630, keyword-tocaption augmentation가 있는 AudioSet, 그리고 feature fusion이 오디오 이해와 작업 성능을 향상시키며 가변 길이 데이터에서의 효과적인 학습을 가능하게 함을 보여주었다. 미래 연구는 더 큰 학습 데이터 수집과 오디오 합성, 분리 등의 downstream task 적용을 고려하고 있다.&lt;/p>
&lt;hr>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>&lt;a class="link" href="https://arxiv.org/pdf/2211.06687.pdf" target="_blank" rel="noopener"
>Paper&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/LAION-AI/CLAP" target="_blank" rel="noopener"
>Github&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>