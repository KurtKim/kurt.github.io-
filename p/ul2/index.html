<!doctype html><html lang=ko-kr dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='Unifying Language Learning Paradigms'><title>UL2</title>
<link rel=canonical href=https://kurtkim.github.io/p/ul2/><link rel=stylesheet href=/scss/style.min.ff300df33b80e2ac49809c825614392ed1c7b27591d65d3c4043602cd162e25f.css><meta property='og:title' content='UL2'><meta property='og:description' content='Unifying Language Learning Paradigms'><meta property='og:url' content='https://kurtkim.github.io/p/ul2/'><meta property='og:site_name' content="K2H'log"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='NLP'><meta property='article:tag' content='LLM'><meta property='article:published_time' content='2024-02-02T00:00:00+00:00'><meta property='article:modified_time' content='2024-02-02T00:00:00+00:00'><meta name=twitter:title content="UL2"><meta name=twitter:description content="Unifying Language Learning Paradigms"><link rel="shortcut icon" href=favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="메뉴 여닫기">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/k2h_hud72815e7fea33e555ee8ed75e79e7624_40760_300x0_resize_q75_box.jpg width=300 height=306 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>K2H'log</a></h1><h2 class=site-description>넓고 얕은 지식을 위한</h2></div></header><ol class=social-menu><li><a href=https://github.com/kurtkim/ target=_blank title=1 rel=me><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li><a href=https://www.linkedin.com/in/kyeong-hun-kim-430ba075/ target=_blank title=2 rel=me><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li><li><a href=https://www.instagram.com/kurt_k2h/ target=_blank title=3 rel=me><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/></svg></a></li><li><a href=https://brunch.co.kr/@bigevlt target=_blank title=4 rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-pencil-minus" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 20h4L18.5 9.5a2.828 2.828.0 10-4-4L4 16v4"/><path d="M13.5 6.5l4 4"/><path d="M16 19h6"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://kurtkim.github.io/ selected></option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>다크 모드</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">목차</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#abstract>Abstract</a></li><li><a href=#introduction>Introduction</a></li><li><a href=#background-pre-trained-language-models>Background: Pre-trained Language Models</a><ol><li><a href=#pre-trained-language-models>Pre-trained Language Models</a></li><li><a href=#pre-training-objectives-for-large-language-models>Pre-training Objectives for Large Language Models</a></li><li><a href=#uniﬁed-pre-training-proposals>Uniﬁed Pre-training Proposals</a></li></ol></li><li><a href=#unifying-language-learning-paradigms-ul2>Unifying Language Learning Paradigms (UL2)</a><ol><li><a href=#pre-training>Pre-training</a><ol><li><a href=#uniﬁed-perspective-for-pre-training-tasks>Uniﬁed Perspective for Pre-training Tasks</a></li><li><a href=#mixture-of-denoisers>Mixture of Denoisers</a></li><li><a href=#mode-switching>Mode Switching</a></li></ol></li></ol></li><li><a href=#model-architecture>Model Architecture</a></li><li><a href=#ablative-experiments>Ablative Experiments</a><ol><li><a href=#baselines>Baselines</a></li><li><a href=#experimental-setup>Experimental Setup</a><ol><li><a href=#datasets-and-tasks>Datasets and Tasks</a></li><li><a href=#metrics-and-holistic-evaluation>Metrics and Holistic Evaluation</a></li><li><a href=#implementation-details>Implementation Details</a></li></ol></li><li><a href=#overview-of-ablative-experimental-results>Overview of Ablative Experimental Results</a><ol><li><a href=#decoder-vs-encoder-decoder>Decoder Vs Encoder-Decoder</a></li><li><a href=#is-gpt-andor-t5-the-optimal-setup>Is GPT and/or T5 the optimal setup?</a></li><li><a href=#on-the-performance-of-unilm-and-sclm>On the Performance of UniLM and SCLM</a></li><li><a href=#on-the-performance-of-the-proposed-ul2>On the Performance of the Proposed UL2</a></li></ol></li><li><a href=#mode-switching-ablations>Mode Switching Ablations</a></li><li><a href=#mixture-of-denoisers-ablations>Mixture-of-Denoisers Ablations</a></li><li><a href=#modestly-scaling-model-size-and-pretraining-data>Modestly Scaling Model Size and Pretraining Data</a></li></ol></li><li><a href=#scaling-to-20b-parameters>Scaling to 20B Parameters</a><ol><li><a href=#pretraining-and-model-conﬁguration>Pretraining and Model Conﬁguration</a></li><li><a href=#experiments-at-20b-scale>Experiments at 20B scale</a><ol><li><a href=#setup-and-implementation-details>Setup and Implementation Details</a></li><li><a href=#datasets-for-supervised-finetuning>Datasets for Supervised Finetuning</a></li><li><a href=#summary-of-supervised-finetuning-results>Summary of Supervised Finetuning Results</a></li><li><a href=#results-on-supervised-finetuning>Results on Supervised Finetuning</a></li><li><a href=#tradeoffs-between-finetuning-and-prompt-based-zero-shot-learning-superglue>Tradeoffs between Finetuning and Prompt-based Zero-shot Learning (SuperGLUE)</a></li><li><a href=#generative-few-shot-xsum-summarization>Generative Few-shot: XSUM Summarization</a></li></ol></li></ol></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#reference>Reference</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/paper-review/>Paper Review</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/ul2/>UL2</a></h2><h3 class=article-subtitle>Unifying Language Learning Paradigms</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Feb 02, 2024</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>17 분 정도</time></div></footer></div></header><section class=article-content><h2 id=abstract>Abstract</h2><p>이 논문에서는 데이터셋과 설정에 걸쳐 보편적으로 효과적인 사전 학습 모델에 대한 통합 프레임워크를 제시한다. 아키텍처 원형과 사전 학습 목표를 분리하고, 다양한 사전 학습 목표가 어떻게 변환될 수 있는지를 보여준다. 또한, 다양한 사전 학습 패러다임을 함께 결합하는 Mixture-of-Denoisers (MoD)를 제안하고, downstream 미세 조정이 특정 사전 학습 체계와 연관되는 모드 전환 개념을 도입한다. 이 방법으로, 이 모델은 다양한 NLP 작업에서 최고의 성능을 달성하였으며, 특히 in-context 학습에서 강력한 결과를 보였다.</p><hr><h2 id=introduction>Introduction</h2><p>NLP 연구자나 실무자들은 다양한 사전 학습된 모델 중에서 선택할 수 있습니다. 그러나 어떤 모델을 사용할지는 &ldquo;상황"과 &ldquo;작업 종류"에 따라 결정된다.</p><p>이에 대한 답변은 &ldquo;encoder-only or encoder-decoder?&rdquo;, &ldquo;span corruption or language model?&rdquo; 등의 디테일한 후속 질문을 수반하며, 결과적으로는 목표로 하는 downstream task에 따라 항상 달라진다. 이 논문은 왜 사전 학습된 언어 모델의 선택이 downstream task에 따라 달라져야 하는지, 그리고 어떻게 다양한 작업에서 보편적으로 잘 작동하는 모델을 사전 학습할 수 있는지에 대해 질문하고 재고한다.</p><p>이 논문은 언어 모델을 보편적으로 적용 가능하게 하는 방안을 제시한다. 다양한 작업과 설정에서 효과적인 &ldquo;Unifying Language Learning Paradigms&rdquo; 즉, UL2라는 프레임워크를 소개하며, 이는 다른 모델들이 종종 타협해야 하는 반면, UL2는 일관되게 잘 수행될 수 있음을 보여준다.</p><p><img src=/p/ul2/images/figure1.png width=736 height=688 srcset="/p/ul2/images/figure1_hucdf1dfbdc96e3b94b170bbbc050e8c09_75927_480x0_resize_box_3.png 480w, /p/ul2/images/figure1_hucdf1dfbdc96e3b94b170bbbc050e8c09_75927_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=106 data-flex-basis=256px></p><p>보편적 모델의 장점은 자원을 여러 모델에 분산시키는 대신, 단일 모델의 개선과 확장에 집중할 수 있다는 것이다. 특히, 자원이 제한된 환경에서는 다양한 작업에 잘 적응할 수 있는 하나의 사전 학습된 모델을 가지는 것이 더 바람직하다.</p><p>UL2의 핵심은 새롭게 제안된 Mixture-of-Denoisers (MoD)라는 사전 학습 목표로, 이를 통해 여러 작업에서 강력한 성능을 보인다. MoD는 기존의 denoising 목표와 새롭게 도입된 X-denoising, S-denoising, R-denoising를 혼합한 것으로, 이는 개념적으로 단순하지만 다양한 작업에 매우 효과적이다.</p><p>이 논문의 방법은 모델이 조건화된 컨텍스트의 유형이 다른 사전 학습 목표들을 활용한다. 예로, span corruption 목표는 prefix 언어 모델링의 여러 영역을 활성화하는데, 여기서 prefix는 손상되지 않은 토큰의 연속된 구간을 의미하며, 목표는 모든 prefix에 접근이 가능하다. 스팬이 전체 시퀀스 길이에 근접하는 설정은 장거리 컨텍스트에 기반한 언어 모델링과 유사하다. 따라서, 이러한 다른 패러다임들을 부드럽게 연결하는 사전 학습 목표를 설계할 수 있다.</p><p>각 denoiser가 다른 방식으로 어렵다는 것은 명확하며, extrapolation 또는 interpolation의 성격에서도 차이가 있다. 예를 들어, span corruption을 통해 모델을 양방향 컨텍스트로 제한하면 작업이 쉬워지고 완성에 가깝게 된다. 반면, PreﬁxLM/LM 목표는 더 &ldquo;open ended"이다. 이러한 행동은 다양한 denoising 목표의 cross entropy loss를 모니터링하여 쉽게 관찰할 수 있다.</p><p>MoD 공식을 통해, 모델이 사전 학습 중 다른 denoiser를 구별하고, downstream task를 학습할 때 적응적으로 모드를 전환하는 것이 유익하다는 추측을 제시하였다. 이를 위해 &ldquo;mode switching&rdquo; 라는 새로운 개념을 도입해, 사전 학습 작업에 특정 센티널 토큰을 연결하고 dynamic mode switching을 가능하게 하였다. 이를 통해 모델은 사전 훈련 후 필요에 따라 R, S, X denoiser 사이의 모드를 전환할 수 있다.</p><p>아키텍처를 self-supervision scheme에서 분리하였으며, 사전 학습된 모델이 그 기반 아키텍처에 의해 크게 특징지어진다는 일반적인 오해와 달리, denoiser의 선택이 더 큰 영향을 미친다는 것을 발견하였다. MoD는 어떤 기반체도 지원하며, UL2는 아키텍처에 중립적이다. 기본적으로, 기반 아키텍처의 선택은 다른 효율성 지표 간의 타협이라고 볼 수 있다.</p><p>9가지 다양한 작업에 대한 실험을 수행했고, 결과로서 UL2는 모든 설정에서 T5와 GPT와 같은 기준을 능가하는 것을 확인하였다. 평균적으로 UL2는 T5를 43.6%, 언어 모델을 76.1% 능가하였으며, 모든 작업에서 UL2만이 T5와 GPT와 같은 모델을 능가하였다.</p><p>UL2를 대략 20B 개의 parameter로 확장하여 50개가 넘는 다양한 NLP 작업에 대한 실험을 수행하였다. 이 작업들은 언어 생성, 언어 이해, 텍스트 분류, 질문 응답, 상식 추론, 긴 텍스트 추론, 구조화된 지식 구축 및 정보 검색 등을 포함한다. 이러한 실험 결과, UL2는 대부분의 작업과 설정에서 state-of-the-art를 달성하였다.</p><p>UL2로 수행한 zero/few-shot 실험에서 UL2가 zero-shot SuperGLUE에서 GPT-3 175B를 능가하였다. 최신의 state-of-the-art의 모델과 비교했을 때, UL2는 C4 코퍼스에서만 학습되었음에도 compute-matched 설정에서 경쟁력을 유지하였다. 또한, zero-shot과 미세조정 성능 사이의 타협을 탐색한 결과, UL2가 두 학습 패러다임에 대해 pareto-efﬁcient를 확인하였다. one-shot 요약에서, UL2는 LM 맞춤형 T5 XXL 모델의 성능을 세 배로 늘렸고, 같은 계산 비용에서 PaLM과 LaMDA와 경쟁하거나 능가하였다. 이에 따라, 학습된 UL2 모델의 T5X 기반 Flax 체크포인트를 공개하였다.</p><hr><h2 id=background-pre-trained-language-models>Background: Pre-trained Language Models</h2><p>사전 학습된 언어 모델, 사전 학습 목표, 그리고 다른 통합 사전 학습 제안에 대한 배경에 대해 논의한다.</p><h3 id=pre-trained-language-models>Pre-trained Language Models</h3><p>언어에 대한 사전 학습된 표현을 학습하는 것은 현대 NLP 연구의 핵심 부분이다. 첫 Transformer인 GPT는 causal 언어 모델로 학습되었고, BERT는 많은 downstream task에 대한 bidirectional 모델링의 중요성을 보여주었다. BERT는 masked language modeling(MLM)을 소개했고, XLNet은 학습 중에 마스크된 토큰 간의 종속성을 고려하기 위한 permutation 언어 모델링을 도입하였다. 그 후에도 여러 논문들이 사전 학습 과정에 대한 추가적인 개선을 제안하였다.</p><p>T5와 같은 two-stack encoder-decoder 구조는 분류와 sequence-to-sequence 작업에서의 성능 향상으로 인기를 얻었다. 그러나 이러한 모델들은 오픈 텍스트 생성과 프롬프트 기반 추론에서 제한된 성능을 보여, 다른 목표로 학습된 decoder-only 모델이 필요하게 되었다. 이 작업에서는 두 구조 모두에게 적합한 일반적인 학습 패러다임을 통해 이들 사이의 성능 격차를 줄이려고 한다.</p><p><strong>Decoder-only vs Encoder-only</strong> decoder-only와 encoder-only 아키텍처는 모두 다음 토큰을 예측하는 autoregressive 모델이다. 하지만 이들은 BERT 스타일의 encoder-only 모델이 인기를 얻은 position-wise masked LM denoising(autoencoding)과는 다르며, 이러한 autoencoding 모델은 생성 능력이 제한적이라는 단점이 있다. downstream task를 위해 task speciﬁc classiﬁcation head를 사용하는 것이 번거롭기 때문에, 이러한 모델의 사용은 권장하지 않는다. 그러나 예외적으로 regression이나 효율성 향상을 위해 task speciﬁc head를 사용할 수 있다. 이를 고려하면, encoder-decoder에서 시작하여 필요에 따라 decoder를 제거하는 것이 바람직하며, 결국 decoder-only과 encoder-decoder 아키텍처 사이에서 선택해야 한다.</p><p><strong>Decoder-only vs Encoder-Decoder</strong> decoder-only 모델과 encoder-decoder 모델의 차이는 미미하며, PreﬁxLM 모델은 사실상 공유 parameter를 가진 encoder-decoder 모델이다. encoder-decoder 모델은 입력과 대상을 독립적으로 처리하며, decoder-only 모델은 이들을 연결해 처리한다. 이 둘의 inductive bias는 상당히 유사하지만, encoder-decoder 모델은 일반적으로 decoder-only 모델의 약 2배의 parameter를 가진다. 이는 encoder-decoder 모델이 입력 토큰과 대상 토큰을 연결하는 교차 주의 구성 요소를 가지고 있기 때문이다.</p><p><strong>Sparse Models</strong> 최근에는 Switch Transformer, GLaM, GShard 등의 sparse 전문가 혼합 모델과 같은 sparse 사전학습 모델이 state-of-the-art를 달성하는 추세이다. 이러한 sparse 모델은 사전학습 목표 주제와는 별개로 밀집 모델과 비교해 ﬂop-per-parameter가 매우 다르며, 이는 encoder-decoder 모델 대 decoder-only 모델 논의에서 주요한 이슈이다.</p><h3 id=pre-training-objectives-for-large-language-models>Pre-training Objectives for Large Language Models</h3><p>최근의 연구는 대규모 감독 멀티태스크 사전학습의 가능성을 보여주지만, 대부분의 사전학습 목표는 비지도 데이터에 의존하고 있다. decoder-only 모델은 주로 causal 언어 모델 목표로 학습되며, encoder-decoder 모델에는 범위 손상이 효과적인 목표로 탐색되었다. 다양한 아키텍처와 사전학습 목표의 조합이 zero-shot 일반화에 어떤 영향을 미치는지에 대한 체계적인 연구가 이루어졌다. 또한, 특정 denoising 방법의 이점은 여전히 불명확하며, 사전학습은 일반적으로 subword 수준에서 적용되지만, 문자나 바이트 수준에서도 적용된 사례가 있다. 이 경우, 손상된 범위는 subword 기반 denoising보다 훨씬 크다.</p><h3 id=uniﬁed-pre-training-proposals>Uniﬁed Pre-training Proposals</h3><p>UniLM은 single transformer 모델을 사용하여 여러 언어 모델링 목표에 대해 학습하는 방식을 제안하였다. 이는 BERT와 preﬁx-LM 모델을 결합하는 방식과 유사하며, explicit mask token을 추가하는 클로즈 타입의 공식을 사용한다. 최근에는 주제 통합 추세가 있어, 상식 추론, 질문 응답, 문제 해결, 구조화된 지식 그라운딩 등의 공통 작업을 하나의 모델로 통합하는 연구가 진행되고 있다.</p><hr><h2 id=unifying-language-learning-paradigms-ul2>Unifying Language Learning Paradigms (UL2)</h2><p>UL2 프레임워크와 제안된 사전 학습 목표에 대해 설명한다.</p><h3 id=pre-training>Pre-training</h3><p>제안된 사전 학습 목표에 대해 논의한다.</p><h4 id=uniﬁed-perspective-for-pre-training-tasks>Uniﬁed Perspective for Pre-training Tasks</h4><p><img src=/p/ul2/images/figure2.png width=1056 height=688 srcset="/p/ul2/images/figure2_huf6428536317265b6d5b23be9f26a7380_170741_480x0_resize_box_3.png 480w, /p/ul2/images/figure2_huf6428536317265b6d5b23be9f26a7380_170741_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=153 data-flex-basis=368px></p><p>많은 사전 학습 작업은 &ldquo;input-to-target&rdquo; 형태로 구성되며, 모델은 주어진 맥락(입력)을 바탕으로 예상 출력(대상)을 생성하다. 언어 모델은 이전 시점의 모든 토큰을 입력으로 사용해 다음 토큰을 예측하며, span corruption에서는 손상되지 않은 토큰을 사용해 손상된 범위를 예측한다. Preﬁx-LM은 양방향 입력 처리를 통해 더 많은 모델링 능력을 제공한다.</p><p>사전 학습 목표는 서로 간소화될 수 있다. 예를 들어, span corruption 목표에서 전체 시퀀스가 손상된 범위(대상)인 경우, 문제는 실질적으로 언어 모델링 문제가 된다. 큰 범위를 설정하여 span corruption을 사용하면, 지역적 영역에서 언어 모델링 목표를 효과적으로 모방할 수 있다.</p><p>이 논문에서는 denoising 작업의 모든 종류를 포함하는 표기법을 정의한다. denoising 작업의 입력과 목표는 평균 범위 길이($µ$), 손상률($r$), 손상 범위 수($n$) 세 가지 값으로 parameterized &ldquo;span corruption&rdquo; 함수를 통해 생성된다. 입력 텍스트가 주어지면, 이 함수는 µ의 평균을 가진 분포에서 추출된 범위에 손상을 가하고, 이 손상된 범위는 복구 대상으로 사용된다.</p><p>이 공식을 사용하여 causal 언어 모델링과 유사한 목표를 설정하려면, 시퀀스 길이와 동일한 범위 길이를 가진 단일 범위$(µ = L, r = 1.0, n = 1)$를 설정하면 된다. Preﬁx LM 목표와 유사하게 설정하려면, preﬁx의 길이인 P를 사용하여 $(µ = L − P, r = 1.0 − P/L, n = 1)$을 설정하고, 단일 손상 범위가 항상 시퀀스의 끝에 도달하도록 제약을 둔다.</p><p>inputs-to-targets 공식은 encoder-decoder 모델과 single-stack transformer 모델에 모두 적용 가능하다. 이 논문에서는 다음 대상 토큰을 예측하는 모델을 선택하는데, 이는 더 일반적이며 더 많은 작업을 수용할 수 있기 때문이다. 이 방법은 특수한 &ldquo;CLS&rdquo; 토큰과 task-speciﬁc projection head 사용을 배제한다.</p><h4 id=mixture-of-denoisers>Mixture of Denoisers</h4><p><img src=/p/ul2/images/figure3.png width=1076 height=322 srcset="/p/ul2/images/figure3_hu3a62ad6ba63de7d780fee257a0671dfb_119519_480x0_resize_box_3.png 480w, /p/ul2/images/figure3_hu3a62ad6ba63de7d780fee257a0671dfb_119519_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=334 data-flex-basis=801px></p><p>강력한 보편적 모델은 사전 학습 과정에서 다양한 문제 해결에 노출되어야 하며, 이러한 다양성은 모델의 목표에 반영되어야 한다고 주장한다. 그렇지 않으면 모델은 장문의 일관된 텍스트 생성 등의 능력이 부족해질 수 있다.</p><p>현재의 목표 함수 클래스와 함께, 사전 학습 동안 사용되는 세 가지 주요 패러다임을 정의한다:</p><ul><li><strong>R-Denoiser</strong> regular denoising은 2에서 5 토큰 범위의 standard span corruption을 사용하며, 이는 약 15%의 입력 토큰을 마스킹한다. 이 짧은 범위는 유창한 텍스트 생성보다는 지식 획득에 유용할 수 있다.</li><li><strong>S-Denoiser</strong> inputs-to-target 작업을 구성할 때 엄격한 순차적 순서를 따르는 preﬁx 언어 모델링은 denoising의 특정 케이스이다. 입력 시퀀스를 두 개의 서브 시퀀스, 즉 문맥과 대상으로 분할하며, 대상은 미래 정보에 의존하지 않는다. 이 방식은 문맥 토큰보다 이전 위치에 대상 토큰이 있을 수 있는 표준 span corruption과는 다르다. 또한, 매우 짧은 메모리나 없는 S-Denoising은 standard causal 언어 모델링과 유사하다.</li><li><strong>X-Denoiser</strong> X-denoising은 입력의 작은 부분을 통해 큰 부분을 복구해야 하는 극단적인 denoising이다. 이 방법은 제한된 정보를 가진 메모리에서 긴 대상을 생성하는 상황을 모방한다. 이를 위해, 입력 시퀀스의 약 50%가 마스킹되는 공격적인 denoising 예제를 포함한다. 이것은 범위 길이나 손상률을 늘림으로써 달성된다. X-denoising은 일반 span corruption과 언어 모델 목표 사이의 중간점을 찾는 것에 동기를 두고 있다.</li></ul><p>이 denoiser 집합은 이전에 사용된 목표 함수와 밀접한 연관이 있다. R-Denoising은 T5 span corruption 목표와, S-Denoising은 GPT와 유사한 인과적 언어 모델과 연결되어 있으며, X-Denoising은 T5와 causal LMs의 목표 조합에 모델을 노출한다. X-denoisers는 더 많은 토큰을 예측학습하므로 샘플 효율성을 향상시킨다. 이 모든 작업을 균일하게 혼합하여 hybrid self-supervised 목표를 제안하며, 최종적으로 7개의 denoiser가 혼합된다.</p><p><img src=/p/ul2/images/table1.png width=784 height=190 srcset="/p/ul2/images/table1_hu1a16490df31adfaa682dddf269386e13_32827_480x0_resize_box_3.png 480w, /p/ul2/images/table1_hu1a16490df31adfaa682dddf269386e13_32827_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=412 data-flex-basis=990px></p><p>X- 및 R-Denoisers는 평균이 $µ$인 normal distribution에서 범위 길이를 샘플링한다. S-Denoisers는 uniform distribution을 사용하고, 손상된 범위의 수를 1로 고정하며, 손상된 부분 다음에는 잘린 토큰이 없어야 한다. 이는 대략적으로 seq2seq denoising 또는 Preﬁx LM 사전 학습 목표와 같다.</p><p>LM은 Preﬁx-LM의 특별한 경우로, mixture에 causal LM 작업을 포함할 필요가 없다고 판단하였다. 모든 작업은 mixture에서 대략적으로 동일하게 참여하며, S-denoisers의 비율을 mixture 내 denoiser 중 최대 50%까지 늘리는 대안을 탐색하였다.</p><p>Mixture-of-Denoisers의 강력함은 그것의 혼합에서 비롯된다. 단독으로는 일부 denoiser 유형이 잘 작동하지 않는데, 예를 들어, 원래의 T5 논문에서는 50%의 손상률(X-denoising)을 가진 옵션이 잘 작동하지 않았다.</p><h4 id=mode-switching>Mode Switching</h4><p>모델이 주어진 작업에 더 적합하게 작동하도록 모드를 전환하는 패러다임 토큰을 사용하는 모드 스위칭 개념을 도입하였다. 미세 조정과 downstream task을 위해, 모델이 더 나은 해결책을 학습하도록 유도하기 위해 패러다임 토큰을 추가합니다. 이 모드 스위칭은 실제로 downstream task의 행동을 upstream 학습 동안 사용한 특정 모드에 연결시킨다.</p><h2 id=model-architecture>Model Architecture</h2><p>UL2는 아키텍처에 중립적인 접근 방식을 취하며, encoder-decoder와 decoder-only의 선택은 효율성의 타협이라고 주장한다. 따라서 UL2는 decoder와와 encoder-decoder 모두를 포함하고 있다. UL2는 표준 T5 transformer를 강화하여 GLU 레이어와 T5 스타일의 상대적 주의를 적용하였고, 아키텍처 변경과 사전 학습 기여를 혼동하지 않기 위해 모델의 기본 구조는 T5와 유사하게 유지하였다.</p><hr><h2 id=ablative-experiments>Ablative Experiments</h2><p>ablative experimental 설정(예: 기준선, 데이터셋, 구현 세부 사항)과 결과에 대해 설명한다. 전반적인 연구 결과는 UL2가 9개의 작업 중 9개에서 T5-유형 및 GPT-유형 모델을 능가한다는 것을 보여준다.</p><h3 id=baselines>Baselines</h3><p>다음의 사전 학습 기준선과 비교한다:</p><ul><li><strong>Causal Language Model (CLM)</strong> 이것은 GPT와 같은 대다수의 표준 사전 학습 모델에서 사용되는 표준 left-to-right auto-regressive 언어 모델 사전 학습이다. 이 모델을 GPT-유형이라고 부른다.</li><li><strong>Preﬁx LM (PLM)</strong> 이것은 M이 bidirectional receptive ﬁeld를 가진 causal LM의 약간의 변형으로, 이 논문에서는 M의 길이를 균일하게 샘플링하고 auto-regressive 목표에서만 손실을 계산한다.</li><li><strong>Span Corruption (SC)</strong> 이것은 T5에서 제안된 standard denoising 목표로, 특정 텍스트 부분을 지우고 센티넬 토큰으로 대체한 후, 이를 목표로 복사하고 모델에 의해 자동으로 생성하는 아이디어이다. 이 논문에서는 평균 범위 3과 denoising 비율 15%를 사용한다.</li><li><strong>Span Corruption + LM (SCLM)</strong> CLM과 Span Corruption을 동일한 비율로 혼합하여 학습한다. 이 목표의 SC 구성 요소에 대해 SC에 대한 동일한 hyper-parameter를 사용한다.</li><li><strong>UniLM (ULM)</strong> 이것은 causal 언어 모델링, Prefix LM, bidirectional i.i.d denoising을 혼합한 Dong et al. (2019)의 목표이다. UniLM을 cloze 스타일 또는 BERT 스타일로 학습하는 대신, 마스크된 토큰을 생성하여 decoder-only 아키텍처와 encoder-decoder 아키텍처 모두에 적용할 수 있고, 미세 조정을 위한 task-speciﬁc linear head의 필요성을 제거한다.</li></ul><p>모든 목표를 위해 단일 스택과 encoder-decoder 아키텍처를 모두 고려하며, 모든 아키텍처는 encoder-decoder 또는 decoder-only 모델로 구현된다. BERT 스타일의 사전 학습은 효과적으로 이 스타일의 학습에 통합되었다고 보여진다. Taskspeciﬁc classiﬁcation head는 유니버설 모델 원칙에 위배되며 번거로우므로 권장되지 않는다.</p><h3 id=experimental-setup>Experimental Setup</h3><p>다양한 지도 학습과 프롬프트 기반 few-shot 학습 작업에 대해 실험을 진행한다.</p><h4 id=datasets-and-tasks>Datasets and Tasks</h4><p>8개의 NLU 부작업을 포함한 SuperGLUE와 언어 생성에 초점을 맞춘 GEM 벤치마크의 일부 데이터셋을 사용해 실험을 진행한다. 이러한 모든 작업은 지도 미세 조정과 프롬프트 기반 one-shot 학습에서 평가되며, 모델들의 일반적인 텍스트 생성 능력도 C4 검증 세트에 대한 perplexity 점수로 비교한다. 이러한 접근법은 다양한 연구 설정에 대한 충분한 커버리지를 제공한다고 믿는다.</p><h4 id=metrics-and-holistic-evaluation>Metrics and Holistic Evaluation</h4><p>SuperGLUE와 GEM 벤치마크에 대한 실험 결과를 각각의 적절한 지표로 보고하며, 언어 모델링의 경우 negative log perplexity를 보고한다. 모델의 범용성, 즉 다양한 작업에서의 성능은 주요 평가 기준이다. 이를 위해 기준에 대한 정규화된 상대적 이득을 종합 지표로 사용하며, 이를 통해 새 모델이 표준 모델(GPT나 T5 같은)보다 얼마나 더 나은지 쉽게 이해할 수 있다. 이 지표는 정규화되어 벤치마크 lottery effect에 취약해지는 것을 방지한다.</p><h4 id=implementation-details>Implementation Details</h4><p>실험은 JAX/Flax와 T5X4 프레임워크, Flaxformer를 통해 진행되며, C4 코퍼스를 사용해 모든 모델을 500K step 동안 사전 학습한다. 이 과정은 64~128개의 TPUv4 칩을 사용하며, Adafactor optimizer를 통해 모델을 최적화한다. 다양한 아키텍처의 트레이드오프를 이해하기 위해, decoder-only 아키텍처와 encoder-decoder 아키텍처를 모두 사용하며, 이들 모델의 주요 실험 결과를 보고한다. 모든 모델은 standard transformer를 사용하며, decoder-only 모델은 입력에서 bidirectional receptive ﬁeld를, 타겟에서는 autoregressive decoding을 사용한다. 이것은 본질적으로 PrefixLM 유형 아키텍처로, full causal decoder 모델보다 더 나은 것으로 확인되었다.</p><h3 id=overview-of-ablative-experimental-results>Overview of Ablative Experimental Results</h3><p>모든 벤치마크 작업과 데이터셋에 대한 원래 결과, T5와 GPT 모델과 같은 잘 정립된 기준선에 대한 상대적인 비교를 보고한다.</p><p><img src=/p/ul2/images/table2.png width=1060 height=380 srcset="/p/ul2/images/table2_hufb55428c5d634ab7171178e4b47db827_105678_480x0_resize_box_3.png 480w, /p/ul2/images/table2_hufb55428c5d634ab7171178e4b47db827_105678_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=278 data-flex-basis=669px></p><p><img src=/p/ul2/images/table3.png width=1092 height=410 srcset="/p/ul2/images/table3_huf6ced914a36605d6b69453a0e58d73b7_101320_480x0_resize_box_3.png 480w, /p/ul2/images/table3_huf6ced914a36605d6b69453a0e58d73b7_101320_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=266 data-flex-basis=639px></p><p><img src=/p/ul2/images/table4.png width=1072 height=394 srcset="/p/ul2/images/table4_hu168fc403d12d43b2f45413fbc4c4130b_101233_480x0_resize_box_3.png 480w, /p/ul2/images/table4_hu168fc403d12d43b2f45413fbc4c4130b_101233_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=272 data-flex-basis=652px></p><h4 id=decoder-vs-encoder-decoder>Decoder Vs Encoder-Decoder</h4><p>decoder-only 모델과 encoder-decoder 모델은 계산력이나 parameter의 측면에서 비교될 수 있다. 결과적으로, encoder-decoder 모델은 decoder-only에 비해 약 2배의 parameter를 가지지만 처리 속도는 비슷하다.</p><p>모델의 희소성을 고려하면 encoder-decoder가 약간 우대될 수 있다. 결과를 보면, T5를 기준으로 할 때, UL2 decoder를 제외하고는 사전 학습된 decoder 모델이 T5를 능가하지 못하며, 전체 성능은 10%~30% 저하된다. 가장 좋은 decoder 모델은 Preﬁx-LM로, T5보다 약 10% 낮습니다. 이 결과로 보아, 저장 공간 문제가 없다면 encoder-decoder 모델이 decoder-only 모델보다 우선적으로 고려되어야 한다.</p><p>parameter 제약이 있는 경우, Preﬁx-LM decoder가 적합한 대체품이 될 수 있다. 또한, UL2 decoder가 T5 encoder-decoder 설정을 +14.6% 능가하는 것은 흥미로운 점이지만, 이는 UL2 encoder-decoder를 능가하지는 못한다. 이로서 self-supervision 목표가 기본 구조보다 본질적으로 중요하며, 구조적 선택은 주로 효율성의 타협을 독립적으로 연구하는 것이라는 점을 강조한다.</p><h4 id=is-gpt-andor-t5-the-optimal-setup>Is GPT and/or T5 the optimal setup?</h4><p>GPT와 같은 설정과 T5와 같은 설정을 비교하는 결과에 따르면, causal LM 설정(GPT와 유사)이 가장 성능이 떨어지며, 가능한 경우 항상 Preﬁx-LM 또는 UniLM으로 학습하는 것이 좋다. Preﬁx-LM 사전 학습은 T5 범위 손상 설정을 +16.7% 능가하며, Preﬁx-LM encoder-decoder 모델은 특정 작업에서는 약간의 성능 저하를 보이지만 다른 작업에서는 크게 향상된다. 따라서 Preﬁx-LM과 T5 중 어느 것이 보편적으로 우수한 모델인지는 분명하지 않는다.</p><h4 id=on-the-performance-of-unilm-and-sclm>On the Performance of UniLM and SCLM</h4><p>encoder-decoder 설정에서 UniLM과 SCLM 목표는 표준 범위 손상 목표보다 전반적으로 더 좋은 성능을 보여, 사전 학습 목표를 혼합하는 것이 유용함을 보여준다. decoder 설정에서는 UniLM이 +9.4%, SCLM이 +16.1%의 성능 향상을 보여주었다. UniLM과 SCLM은 9개 작업 중 6개에서 T5를 능가하였으며, SCLM이 one-shot 생성에서 가장 뛰어난 성능을 보여주었다.</p><h4 id=on-the-performance-of-the-proposed-ul2>On the Performance of the Proposed UL2</h4><p>UL2는 GPT와 같은 모델과 T5와 같은 모델에 비해 가장 뛰어난 성능을 보이며, T5에 비해 +43.4%, GPT와 같은 모델에 비해 +76.2%의 성능 향상을 보인다. 9개의 고려된 모든 작업에서 UL2는 T5를 능가한다. UL2는 항상 모든 작업에서 가장 높은 성능을 보이지는 않지만, 일관성이 있으며, 특정 작업에서 다른 방법에게 손실을 보여도 이는 상대적으로 미미하다. 반대로, UL2가 T5를 능가할 때, 이익은 매우 크며, 이런 일관된 개선으로 인해 UL2는 T5와 GPT와 같은 모델의 대체품으로 사용될 수 있다.</p><h3 id=mode-switching-ablations>Mode Switching Ablations</h3><p><img src=/p/ul2/images/table5.png width=618 height=218 srcset="/p/ul2/images/table5_hu77939970274c9f4fff5ef7c499fc1e5c_38228_480x0_resize_box_3.png 480w, /p/ul2/images/table5_hu77939970274c9f4fff5ef7c499fc1e5c_38228_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=283 data-flex-basis=680px></p><p>모드 전환 기능이 성능에 미치는 영향을 확인하기 위해 실험을 진행하였다. 실험 결과, 프롬프트의 사용이 모델 성능에 큰 영향을 미치며, 특히 XSum에서는 올바른 프롬프트 사용이 성능 차이를 48%까지 만들어내었다. 반면 SuperGLUE는 프롬프트에 덜 민감했지만, one-shot 평가에서는 프롬프트를 사용하는 것이 대체로 더 좋은 결과를 보여주었다.</p><h3 id=mixture-of-denoisers-ablations>Mixture-of-Denoisers Ablations</h3><p><img src=/p/ul2/images/table6.png width=732 height=426 srcset="/p/ul2/images/table6_hu02dad93faeab3370872a92794621909b_80447_480x0_resize_box_3.png 480w, /p/ul2/images/table6_hu02dad93faeab3370872a92794621909b_80447_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=171 data-flex-basis=412px></p><p>개별 목표의 효과성을 검증하기 위한 광범위한 실험을 실시하였다. 평균 범위와 손상률의 변화, 그리고 사용된 S-denoising의 비율(% SD)을 변화시켜 결과를 확인하였다. mixture 내의 denoiser의 총 수는 $∥ Span ∥ \times ∥ Corrupt Rate ∥ + 1$로 계산되며, 이러한 설정들은 Var-A부터 Var-J까지의 레이블로 표시되어 있다.</p><p><strong>X-Denoising is Complementarily Effective but Does Not Sufﬁce as a Standalone</strong> mixing Extreme Denoising이 효과적이며, 대부분의 최고 결과는 긴 범위를 가진 mixture에서 나왔다. 긴 범위를 사용하지 않는 경우와 비교했을 때, 긴 범위를 사용하는 것이 더 좋은 성능을 보였다. 그러나 긴 범위만을 사용하는 경우는 일반적으로 성능이 좋지 않았으며, 이는 Extreme Denoising이 단독으로는 충분하지 않음을 나타낸다. 이 결과는 이전 연구에서 50%의 손상률이 잘 작동하지 않음을 보여주는 점과 일치한다. 그러나 이 결과는 BERT 스타일의 masked language modeling 대신 inputs-to-targets 형태의 사전 학습을 사용하는 아키텍처와 약간 충돌한다.</p><p><strong>Small Amounts of S-Denoisers is Preferred</strong> S-denoisers를 전체 MoD mixture의 50%로 확대하는 설정은 일반적으로 성능을 저하시킨다는 결론을 내렸다. 따라서 S-denoisers는 필요하지만, 작은 양(약 20%)이 선호된다. S-denoising이 전혀 없는 경우를 탐색해보았지만, 일부 작업에서는 성능이 향상되지만, 다른 작업에서는 크게 저하되는 것을 확인하였다. 이 결과로부터 S-denoising이 중요하다는 결론을 도출하였다.</p><h3 id=modestly-scaling-model-size-and-pretraining-data>Modestly Scaling Model Size and Pretraining Data</h3><p><img src=/p/ul2/images/table7.png width=1000 height=188 srcset="/p/ul2/images/table7_hu5801fe16411126f14c766e792704ab51_43298_480x0_resize_box_3.png 480w, /p/ul2/images/table7_hu5801fe16411126f14c766e792704ab51_43298_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=531 data-flex-basis=1276px></p><p>모델 크기와 사전 학습 데이터셋 크기를 확대하여 추가 실험을 진행하였다. 이 실험에서는 UL2 encoder-decoder 모델을 약 1B 개의 parameter로 확대하고, 사전 학습 토큰의 수를 0.5조 개로 늘렸다. 이렇게 크게 확대된 설정에서도 UL2 모델은 여전히 경쟁력이 있었다. 주요 변화 중 하나는 UL2가 SuperGLUE 스위트를 포기하고, 대신 8개 작업 중 7개에서 성능을 능가하고, one-shot 평가에서 성능을 2-4배 향상시키는 결과를 보여주었다. 지도 미세 조정에서의 이익은 작지만 XSUM, SGD, TOT에서 눈에 띄게 나타났다.</p><hr><h2 id=scaling-to-20b-parameters>Scaling to 20B Parameters</h2><p>확대된 설정에서 UL2를 평가하고자 한다. 이전 실험 결과를 바탕으로 encoder-decoder 아키텍처를 사용한다. UL2는 아키텍처에 중립적이지만, 본질적인 희소성 때문에 encoder-decoder 아키텍처 사용을 권장한다.</p><p>UL2를 약 200억 개의 parameter 규모에서 학습시켰다. 이 크기는 중간 규모의 모델로, UL2가 더 큰 규모에서도 작동할 수 있다는 것을 보여준다. 이 모델은 특정 제어나 완화 전략 없이 학습되었으며, 때때로 loss spike를 보였다. 그러나 이 모델을 사용한 많은 실험에서 state-of-the-art를 달성 하였으므로, 현재 결과가 모델의 진정한 잠재력을 과소평가한 것으로 보인다.</p><h3 id=pretraining-and-model-conﬁguration>Pretraining and Model Conﬁguration</h3><p>이전 실험과 동일한 프로토콜을 따라, C4 코퍼스에서 UL2를 사전 학습하였다. 이 때, 모델이 사전 학습 중에 보는 토큰의 수를 확대하였다. batch size는 1024, TPUv4 칩 512개를 사용하였고, 총 1 trillion 개의 토큰에 대해 약 한 달 이상 학습하였다. 이 모델은 32개의 encoder layer와 32개의 decoder layer를 가지며, 각 head는 총 16개이고 각각의 차원이 256이다. UL20B는 T5와 유사하지만, 목표와 스케일링 노브가 약간 다르며, 이 20B 모델의 체크포인트를 공개하고 오픈 소스화하였다.</p><h3 id=experiments-at-20b-scale>Experiments at 20B scale</h3><p>UL20B 실험에 대한 실험 설정을 설명한다.</p><h4 id=setup-and-implementation-details>Setup and Implementation Details</h4><p>미세 조정과 컨텍스트 내 학습에 대한 실험을 진행하였다. 지도 미세 조정은 일반적으로 5만에서 10만 사이의 사전 학습 단계 후에 이루어졌고, 각각의 downstream task에 대해 수동적으로 미세 조정하였다. 일부 작업은 모델이 아직 사전 학습 중일 때 미세 조정되었으며, 많은 작업은 공개한 수렴에 가까운 체크포인트에서 미세 조정되었다. 작업이 최고의 성능에 도달하면 컴퓨팅을 절약하기 위해 미세 조정을 중단하였다. 또한, 대규모 다중 작업 학습과 UL2의 결합은 미래의 작업으로 남겨두었다.</p><p>지도 미세 조정을 위해, Adafactor optimizer를 사용하고 학습률은 {$5 \times 10^−5, 1 \times 10^−4$}의 범위에서 설정하였다. optimizer의 상태를 재설정하고 실제 목표 토큰의 수에 기반한 손실 정규화를 적용하였다. batch size는 일반적으로 32에서 128의 범위였고, 미세 조정 성능에는 큰 영향을 미치지 않았다. 평가된 많은 작업들은 크게 조정되지 않고, 리더보드 제출 전에 한 두 번만 실행하였다.</p><h4 id=datasets-for-supervised-finetuning>Datasets for Supervised Finetuning</h4><p>총 50개 이상의 자연어 처리(NLP) 작업을 고려한다. 작업의 분류는 일반적으로 유연하며, 일부 작업은 다른 분류 경계로 넘어갈 수 있다.</p><ul><li><strong>Language Generation</strong> summarization과 data-to-text generation 작업에 대해 평가하며, 이를 위해 CNN/Dailymail, XSUM, MultiNews, SAMSum, WebNLG, E2E, 그리고 CommonGen 데이터셋을 사용한다. WebNLG, E2E, CommonGen의 경우, GEM 벤치마크 버전을 사용하였다.</li><li><strong>Language Generation with Human Evaluation</strong> GENIE 리더보드를 통한 인간 평가를 사용하여 aNLG, ARC-DA, WMT19, XSUM 등의 작업을 평가하였다.</li><li><strong>Language Understanding, Classiﬁcation and Question Answering</strong> RACE, QASC, OpenBookQA, TweetQA, QuAIL, IMDB, Agnews, DocNLI, Adversarial NLI, VitaminC, Civil Comments, Wikipedia Toxicity detection 등의 데이터셋을 사용하여 독해, 질문 응답, 텍스트 분류, 자연어 추론 등의 작업을 수행한다. 또한, SuperGLUE와 GLUE 데이터셋도 활용하였다.</li><li><strong>Commonsense Reasoning</strong> HellaSwag, SocialIQA/SIQA, PhysicalIQA/PIQA, CosmosQA, AbductiveNLI, CommonsenseQA, 그리고 CommonsenseQA2 등의 데이터셋을 활용한다.</li><li><strong>Long Range Reasoning</strong> GovReport, SumScr, QMSUm, QASPER, NarrativeQA, QuaLITY, 그리고 ContractNLI 등 일곱 개의 구성 작업이 포함된 Scrolls 벤치마크를 사용한다.</li><li><strong>Structured Knowledge Grounding</strong> UniﬁedSKG에서 WikiTQ, CompWQ, FetaQA, HybridQA, WikiSQL, TabFat, Feverous, SQA, MTOP, 그리고 DART 등의 작업을 사용한다. 평가 수행이 상대적으로 편리하고, 정확도나 완전 일치 같은 주요 메트릭을 사용하는 데이터셋을 선택하였다.</li><li><strong>Information Retrieval</strong> 차별화 가능한 검색 인덱스 설정을 사용하여 주어진 쿼리에 대해 관련 문서를 검색하는 IR 작업을 수행하며, 이는 최신의 차세대 IR 패러다임이다. 실험에서는 DSI 논문의 NQ 분할을 사용하였다.</li></ul><p>각 데이터셋의 state-of-the-art를 보고하며, 생성 작업에 대해서는 ROUGE-2를, 나머지 데이터셋에 대해서는 이전 작업에서 사용된 주요 메트릭을 보고한다. BLEU 점수에 대해서는 sacrebleu를 사용하며, 외부 지식 기반을 사용하는 상식 추론 작업과는 비교하지 않는다. GLUE는 일반적으로 포화 상태로, 많은 미발표 결과가 있으므로, 우리는 T5 모델 이후 실제로 큰 진전이 없었다고 판단하여 state-of-the-art로 간주한다.</p><p>가능한 한 모든 리더보드에 점수를 제출하려 노력하지만, 노동 비용이 과도하게 높은 경우나, 기존 state-of-the-art 접근법이 개발 점수를 제공하거나, 특정 데이터셋에 대한 보고가 완전성을 위한 것인 경우에는 제출하지 않는다. 리더보드에서 보고할 때에는 가장 높은 성능을 보인 출판된 작업을 state-of-the-art로 간주하며, 익명의 제출이 더 높은 점수를 받았을 수도 있다는 것을 표시한다. 최종 시퀀스 길이를 늘리는 것이 점수를 상당히 향상시킬 것으로 예상되지만, 물류와 시간표 상의 이유로 이는 미래의 작업에 맡긴다.</p><h4 id=summary-of-supervised-finetuning-results>Summary of Supervised Finetuning Results</h4><p>실험 결과에 대한 개요를 설명한다.</p><p><img src=/p/ul2/images/table8-1.png width=1030 height=1278 srcset="/p/ul2/images/table8-1_huef72c91a40a8f33fbb43c15c9a51455c_378305_480x0_resize_box_3.png 480w, /p/ul2/images/table8-1_huef72c91a40a8f33fbb43c15c9a51455c_378305_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=80 data-flex-basis=193px></p><p><img src=/p/ul2/images/table8-2.png width=1032 height=974 srcset="/p/ul2/images/table8-2_huf871f9455c3ef9b677f7a64e6e9a8f02_255129_480x0_resize_box_3.png 480w, /p/ul2/images/table8-2_huf871f9455c3ef9b677f7a64e6e9a8f02_255129_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=105 data-flex-basis=254px></p><h4 id=results-on-supervised-finetuning>Results on Supervised Finetuning</h4><p>실험 결과, UL2는 50개 이상의 NLP 작업에서 state-of-the-art를 달성하였다. 성능 차이는 크게 나타났으며, UL2가 state-of-the-art를 달성하지 못한 경우에도 경쟁력이 있었다. 각 벤치마크에서 state-of-the-art를 얻는 난이도는 크게 다르며, 일부 벤치마크에서는 이미 큰 모델이 state-of-the-art를 보이고 있어 능가하는 것이 쉽지 않았다. UL2 20B는 GENIE 작업에서 인간 평가에서도 우수한 성과를 보였으며, 이는 UL2의 생성 품질이 탄탄하다는 것을 입증한다.</p><h4 id=tradeoffs-between-finetuning-and-prompt-based-zero-shot-learning-superglue>Tradeoffs between Finetuning and Prompt-based Zero-shot Learning (SuperGLUE)</h4><p><img src=/p/ul2/images/table9.png width=1078 height=240 srcset="/p/ul2/images/table9_hu9360f719bd4ac07a1ae8ddc36349b116_63847_480x0_resize_box_3.png 480w, /p/ul2/images/table9_hu9360f719bd4ac07a1ae8ddc36349b116_63847_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=449 data-flex-basis=1078px></p><p><img src=/p/ul2/images/table10.png width=1080 height=394 srcset="/p/ul2/images/table10_hua78890f12b6ed46ccfad98d05ff55bea_101700_480x0_resize_box_3.png 480w, /p/ul2/images/table10_hua78890f12b6ed46ccfad98d05ff55bea_101700_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=274 data-flex-basis=657px></p><p>SuperGLUE 벤치마크에서 미세조정과 in-context 학습의 상충 관계를 연구한다. UL20B를 사용한 실험 결과, state-of-the-art를 달성하지 못했지만, T5-11B를 능가하는 경쟁력을 유지하였다. 하지만, 매개변수가 200B+ 이상인 ST-MoE-32B 모델에 비해 아직 뒤쳐진다. 이는 ST-MoE-32B가 특정 아키텍처를 사용하여 학습되고 있으며, 이 아키텍처가 NLU 미세조정에 매우 유리하기 때문이다.</p><h4 id=generative-few-shot-xsum-summarization>Generative Few-shot: XSUM Summarization</h4><p><img src=/p/ul2/images/table11.png width=588 height=268 srcset="/p/ul2/images/table11_hubb8a853de78c1b71ac075ecb0a494b1b_35158_480x0_resize_box_3.png 480w, /p/ul2/images/table11_hubb8a853de78c1b71ac075ecb0a494b1b_35158_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=219 data-flex-basis=526px></p><p>XSum 데이터셋을 사용해 few-shot in-context one-shot 학습을 추가로 실시하였다. 기존 모델들과 비교했을 때, UL2 20B의 성능은 LM Adaptation을 적용한 T5 XXL 모델의 성능의 약 3배였으며, LaMDA 137B를 능가하고 PaLM 8B의 성능의 거의 두 배에 가까웠다. 그러나 가장 좋은 결과는 여전히 큰 PaLM 모델들에서 나왔다.</p><hr><h2 id=conclusion>Conclusion</h2><p>보편적으로 효과적인 모델을 학습시키는 새로운 패러다임, UL2를 제안하였다. 이는 여러 사전 학습 작업을 다양화하고 섞는 Mixture of Denoisers (MoD) 사전학습과 downstream 작업 동작을 upstream 사전학습과 연결하는 mode switching 방법을 특징으로 한다. UL2는 다양한 지도 학습 및 few-shot 작업에서 GPT와 T5 모델을 일관되게 능가하였고, 50개 이상의 NLP 작업에서 state-of-the-art를 달성하였다.</p><hr><h2 id=reference>Reference</h2><ul><li><a class=link href=https://arxiv.org/pdf/2205.05131v1.pdf target=_blank rel=noopener>Paper</a></li><li><a class=link href=https://github.com/google-research/google-research/tree/master/ul2 target=_blank rel=noopener>Github</a></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/nlp/>NLP</a>
<a href=/tags/llm/>LLM</a></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>관련 글</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/opt-iml/><div class=article-details><h2 class=article-title>OPT-IML</h2></div></a></article><article><a href=/p/galactica/><div class=article-details><h2 class=article-title>Galactica</h2></div></a></article><article><a href=/p/bloom/><div class=article-details><h2 class=article-title>BLOOM</h2></div></a></article><article><a href=/p/helm/><div class=article-details><h2 class=article-title>HELM</h2></div></a></article><article><a href=/p/glm-130b/><div class=article-details><h2 class=article-title>GLM-130B</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=KurtKim/kurtkim.github.io issue-term=pathname crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2024 K2H'log</section><section class=powerby><a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>로 만듦<br><a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>의 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.17.0>Stack</a></b> 테마 사용 중</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"}),MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}})</script></body></html>