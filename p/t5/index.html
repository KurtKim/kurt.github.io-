<!doctype html><html lang=ko-kr dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer'><title>T5</title>
<link rel=canonical href=https://kurtkim.github.io/p/t5/><link rel=stylesheet href=/scss/style.min.ff300df33b80e2ac49809c825614392ed1c7b27591d65d3c4043602cd162e25f.css><meta property='og:title' content='T5'><meta property='og:description' content='Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer'><meta property='og:url' content='https://kurtkim.github.io/p/t5/'><meta property='og:site_name' content="K2H'log"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='NLP'><meta property='article:tag' content='LLM'><meta property='article:published_time' content='2023-12-18T00:00:00+00:00'><meta property='article:modified_time' content='2023-12-18T00:00:00+00:00'><meta name=twitter:title content="T5"><meta name=twitter:description content="Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer"><link rel="shortcut icon" href=favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="메뉴 여닫기">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/k2h_hud72815e7fea33e555ee8ed75e79e7624_40760_300x0_resize_q75_box.jpg width=300 height=306 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>K2H'log</a></h1><h2 class=site-description>넓고 얕은 지식을 위한</h2></div></header><ol class=social-menu><li><a href=https://github.com/kurtkim/ target=_blank title=1 rel=me><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li><a href=https://www.linkedin.com/in/kyeong-hun-kim-430ba075/ target=_blank title=2 rel=me><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li><li><a href=https://www.instagram.com/kurt_k2h/ target=_blank title=3 rel=me><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/></svg></a></li><li><a href=https://brunch.co.kr/@bigevlt target=_blank title=4 rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-pencil-minus" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 20h4L18.5 9.5a2.828 2.828.0 10-4-4L4 16v4"/><path d="M13.5 6.5l4 4"/><path d="M16 19h6"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://kurtkim.github.io/ selected></option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>다크 모드</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">목차</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#abstract>Abstract</a></li><li><a href=#introduction>Introduction</a></li><li><a href=#setup>Setup</a><ol><li><a href=#model>Model</a></li><li><a href=#the-colossal-clean-crawled-corpus>The Colossal Clean Crawled Corpus</a></li><li><a href=#downstream-tasks>Downstream Tasks</a></li><li><a href=#input-and-output-format>Input and Output Format</a></li></ol></li><li><a href=#experiments>Experiments</a><ol><li><a href=#baseline>Baseline</a><ol><li><a href=#model-1>Model</a></li><li><a href=#training>Training</a></li><li><a href=#vocabulary>Vocabulary</a></li><li><a href=#unsupervised-objective>Unsupervised Objective</a></li><li><a href=#baseline-performance>Baseline Performance</a></li></ol></li><li><a href=#architectures>Architectures</a><ol><li><a href=#model-structures>Model Structures</a></li><li><a href=#comparing-different-model-structures>Comparing Different Model Structures</a></li><li><a href=#objectives>Objectives</a></li><li><a href=#results>Results</a></li></ol></li><li><a href=#unsupervised-objectives>Unsupervised Objectives</a><ol><li><a href=#disparate-high-level-approaches>Disparate High-Level Approaches</a></li><li><a href=#simplifying-the-bert-objective>Simplifying the BERT Objective</a></li><li><a href=#varying-the-corruption-rate>Varying the Corruption Rate</a></li><li><a href=#corrupting-spans>Corrupting Spans</a></li><li><a href=#discussion>Discussion</a></li></ol></li><li><a href=#pre-training-data-set>Pre-training Data set</a><ol><li><a href=#unlabeled-data-sets>Unlabeled Data Sets</a></li><li><a href=#pre-training-data-set-size>Pre-training Data set Size</a></li></ol></li><li><a href=#training-strategy>Training Strategy</a><ol><li><a href=#fine-tuning-methods>Fine-tuning Methods</a></li><li><a href=#multi-task-learning>Multi-task Learning</a></li><li><a href=#combining-multi-task-learning-with-fine-tuning>Combining Multi-Task Learning with Fine-Tuning</a></li></ol></li><li><a href=#scaling>Scaling</a></li><li><a href=#putting-it-all-together>Putting It All Together</a></li></ol></li><li><a href=#reflection>Reflection</a><ol><li><a href=#takeaways>Takeaways</a></li><li><a href=#outlook>Outlook</a></li></ol></li><li><a href=#reference>Reference</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/paper-review/>Paper Review</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/t5/>T5</a></h2><h3 class=article-subtitle>Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Dec 18, 2023</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>28 분 정도</time></div></footer></div></header><section class=article-content><h2 id=abstract>Abstract</h2><p>전이 학습은 데이터가 풍부한 작업에서 먼저 모델을 사전 훈련시킨 후, 이를 downstream task에 미세 조정하는 방식으로, 자연어 처리(NLP)에서 중요한 기법이다. 이 논문에서는 모든 텍스트 기반 언어 문제를 텍스트-텍스트 형식으로 변환하는 통합 프레임워크를 통해 NLP를 위한 전이 학습 기법을 탐색한다. 이 연구에서는 사전 훈련 목표, 아키텍처, 라벨이 없는 데이터셋, 전이 접근법 등 다양한 요소를 비교 분석하여, 요약, 질문 응답, 텍스트 분류 등 여러 분야에서 state-of-the-art를 달성하였다. 또한, 이러한 연구를 통한 데이터셋, 사전 훈련된 모델, 코드를 공개하여, NLP를 위한 전이 학습 연구를 더욱 촉진시키고자 한다.</p><hr><h2 id=introduction>Introduction</h2><p>자연어 처리(NLP) 머신러닝 모델 훈련은 모델이 텍스트를 이해하고 적절하게 처리하는 능력을 개발하는 것을 목표로 하며, 이는 단어의 철자와 의미부터 고수준의 지식까지 다양한 요소를 포함한다. 최근에는 데이터가 풍부한 작업에서 모델을 사전 학습하는 것이 일반적이며, 이를 통해 모델은 다양한 작업에 활용할 수 있는 일반적인 능력과 지식을 개발하게 된다. 특히 NLP에서는 레이블이 없는 대량의 텍스트 데이터를 이용한 비지도 학습으로 사전 학습이 진행되며, 이 방법은 주요 NLP 벤치마크에서 state-of-the-art를 달성하는 데 사용되었다.</p><p>자연어 처리(NLP)에서의 전이 학습에 대한 최근 연구는 다양한 사전 학습 목표와 레이블 없는 데이터 세트, 벤치마크 등을 개발했다. 이 분야는 빠르게 발전하고 있지만, 그로 인해 다양한 기법을 비교하거나 이해하는 것이 어려워졌다.</p><p><img src=/p/t5/images/figure1.png width=1170 height=426 srcset="/p/t5/images/figure1_hu1038ec56a8248b7b1a8e5f6fb8351c28_110308_480x0_resize_box_3.png 480w, /p/t5/images/figure1_hu1038ec56a8248b7b1a8e5f6fb8351c28_110308_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=274 data-flex-basis=659px></p><p>모든 텍스트 처리 문제를 &ldquo;Text-to-Text"의 일관된 문제로 바라보며, 이를 통해 다양한 NLP 문제에 대한 성능을 평가하고 전이 학습의 한계를 탐색하고자 한다. 이 연구의 목표는 새로운 방법을 제안하는 것이 아니라, 현재 이 분야가 어디에 서 있는지를 종합적으로 이해하는 것이다. 이를 위해 &ldquo;Colossal Clean Crawled Corpus(C4)&ldquo;라는 웹에서 수집한 영어 텍스트 데이터 세트를 사용한다. 또한, 데이터가 부족한 환경에서의 전이 학습의 중요성을 인식하여, 코드, 데이터 세트, 그리고 사전 학습된 모델을 공개한다.</p><hr><h2 id=setup>Setup</h2><p>모든 문제를 &ldquo;Text-to-Text&rdquo; 변환하는 접근법과 레이블 없는 텍스트 데이터를 구성한 &ldquo;Colossal Clean Crawled Corpus(C4)&ldquo;를 제안한다. 모델과 프레임워크의 이름은 &ldquo;Text-to-Text Transfer Transformer(T5)&ldquo;이다.</p><h3 id=model>Model</h3><p>NLP의 초기 전이 학습은 RNN을 이용했지만, 최근에는 Transformer 아키텍처 기반의 모델이 일반적이다. Transformer는 처음에는 기계 번역에 효과적이었지만, 이후 다양한 NLP 환경에서 널리 사용되었다. 그래서 논문에서 연구되는 모든 모델은 Transformer 아키텍처를 기반으로 하며, 이 아키텍처에서 크게 벗어나지는 않았다.</p><p>Transformer의 핵심 구성 요소는 self-attention으로, 시퀀스의 각 요소를 시퀀스의 나머지 부분의 가중 평균으로 대체한다. 원래 Transformer는 encoder-decoder 아키텍처로 설계되었지만, 최근에는 언어 모델링이나 분류, 범위 예측 작업에 적합한 아키텍처를 생성하는 다양한 형태의 self-attention을 사용한 single Transformer layer stack 모델이 일반적이다.</p><p>T5의 encoder-decoder Transformer는 입력 토큰을 임베딩으로 매핑하고 이를 인코더에 전달한다. 인코더는 &ldquo;self-attention layer"과 &ldquo;feed-forward network"를 포함하며, 각 입력에 layer normalization와 residual skip connection을 적용한다. dropout은 네트워크 전체에 적용된다. 디코더는 인코더와 비슷하지만, 인코더 출력에 self-attention mechanism이 추가되고, autoregressive 또는 causal self-attention을 사용한다. 디코더 출력은 dense layer로 전달되고, 모든 attention mechanism은 독립적인 &ldquo;head"로 나누어져 있다.</p><p>Transformer 모델은 순서에 상관 없는 self-attention 특성 때문에 position signal을 제공한다. 초기에는 sinusoidal position signal이나 learned position embeddings을 사용했지만, 최근에는 relative position embeddings이 주로 사용되고 있다. 이는 &ldquo;key"와 &ldquo;query"의 오프셋에 따라 다른 임베딩을 생성한다. 우리는 position embedding을 간소화하여 attention weight 계산에 사용되는 스칼라로 만들었다. 모든 layer가 position embedding parameter를 공유하며, 각 layer의 attention head는 다른 position embedding을 사용한다. 이 모델은 원래의 Transformer와 비슷하지만, layer normalization 위치와 position embedding 체계가 다르다.</p><p>모델의 확장성을 실험하기 위해 parameter와 layer를 늘리고, 그 성능 변화를 관찰했다. 복잡한 큰 모델 학습을 위해 모델과 데이터 병렬성을 사용하고, 5개의 TPU 파드를 활용한 Cloud TPU Pods에서 모델을 학습시켰다.</p><h3 id=the-colossal-clean-crawled-corpus>The Colossal Clean Crawled Corpus</h3><p>레이블이 없는 데이터의 품질, 특성, 크기가 어떤 영향을 미치는지 분석한다. 이를 위해 웹에서 스크랩된 텍스트를 제공하는 Common Crawl을 사용한다. Common Crawl은 이전에 언어 모델 훈련, 상식적 추론, 기계 번역 텍스트 채굴, 사전 훈련 데이터 세트, 최적화기 테스트 등 다양한 NLP 연구에 활용된 바 있다.</p><p>Common Crawl은 웹에서 스크랩된 텍스트를 제공하는 공개 아카이브이다. 매월 약 20TB의 텍스트 데이터를 생성하지만, 이 중 대부분은 자연언어가 아닌 메뉴, 오류 메시지, 중복 텍스트 등의 쓸데없는 텍스트이다. 또한, 작업에 도움이 되지 않을 것 같은 내용도 많이 포함되어 있다. 이러한 문제를 해결하기 위해, 다음과 같은 방법들을 사용한다:</p><ul><li>마침표, 느낌표, 물음표, 인용 부호를 포함한 문장만을 사용한다.</li><li>3문장 미만의 페이지는 제외하고, 적어도 5단어 이상 포함된 문장만을 사용한다.</li><li>&ldquo;불순한, 야한, 외설적인 또는 그 외 나쁜 단어 목록"에 있는 단어가 포함된 페이지는 모두 삭제한다.</li><li>스크랩된 페이지의 대다수는 자바스크립트(Javascript)가 활성화 되어야 한다는 경고문을 포함한다. 따라서 자바스크립트 단어를 포함한 모든 라인을 삭제한다.</li><li>일부 페이지는 “lorem ipsum” 플레이스홀더를 포함한다. 따라서 “lorem ipsum”구가 있는 모든 페이지를 삭제한다.</li><li>일부 페이지에는 코드가 포함되어 있다. “{” 문구가 대다수의 프로그래밍 언어(웹에서 많이 사용되는 자바스크립트와 같이)에서 출몰하고 자연 텍스트에서는 나타나지 않기 때문에, “{” 를 포함한 모든 페이지를 삭제한다.</li><li>스크랩된 페이지 중 일부는 위키백과에서 가져온 것이었고, 인용 표시자(e.g. [1], [citation needed], etc.)가 있다. 이러한 표시자를 모두 를 모두 삭제한다.</li><li>많은 페이지에는 보일러플레이트 정책 공지가 있다. &ldquo;terms of use&rdquo;, &ldquo;privacy policy&rdquo;, &ldquo;cookie policy&rdquo;, &ldquo;uses cookies&rdquo;, &ldquo;use of cookies&rdquo;, &ldquo;use cookies"라는 문자열을 포함한 줄은 모두 삭제한다.</li><li>데이터셋 중복을 제거하기 위해, 데이터셋에서 두 번 이상 나타난 3문장 스팬은 하나만 남기고 모두 삭제한다.</li></ul><p>대부분의 작업이 영어 텍스트에 초점을 두고 있기 때문에, 0.99의 확률로 영어로 분류되지 않은 페이지를 제거하기 위해 &ldquo;langdetect"를 사용하였다. 하지만, 이전 데이터 세트의 필터링 방법, 공개 여부, 범위 등이 제한적이라고 판단하여 새로운 데이터 세트를 만들기로 결정하였습니다.</p><p>2019년 4월의 웹 텍스트를 다운로드하고 필터링하여 기본 데이터 세트를 구축하였다. 이 결과, 대부분의 사전 학습 데이터 세트보다 훨씬 크고(750GB), 깨끗하며 자연스러운 영어 텍스트 컬렉션을 만들었다. 이를 &ldquo;Colossal Clean Crawled Corpus(C4)&ldquo;라고 부르며, TensorFlow 데이터 세트의 일부로 공개하였다.</p><h3 id=downstream-tasks>Downstream Tasks</h3><p>이 논문의 목표는 일반적인 언어 학습 능력을 측정하는 것이다. 이를 위해, 다양한 벤치마크를 통해 기계 번역, 질문 응답, 추상적 요약, 텍스트 분류 등의 성능을 연구하였다. 이에는 GLUE와 SuperGLUE 텍스트 분류, CNN/Daily Mail 요약, SQuAD 질문 응답, 그리고 WMT 영어에서 독일어, 프랑스어, 루마니아어로의 번역이 포함되었다. 모든 데이터는 TensorFlow 데이터 세트에서 수집하였다.</p><p>GLUE와 SuperGLUE는 각각 일반적인 언어 이해 능력을 테스트하기 위해 설계된 텍스트 분류 작업들의 모음이다:</p><ul><li>Sentence acceptability judgment (CoLA)</li><li>Sentiment analysis (SST-2)</li><li>Paraphrasing/sentence similarity (MRPC, STS-B, QQP)</li><li>Natural language inference (MNLI, QNLI, RTE, CB)</li><li>Coreference resolution (WNLI and WSC)</li><li>Sentence completion (COPA)</li><li>Word sense disambiguation (WIC)</li><li>Question answering (MultiRC, ReCoRD, BoolQ)</li></ul><p>GLUE와 SuperGLUE 벤치마크의 데이터 세트를 사용하며, 모든 작업들을 하나의 작업으로 취급하여 데이터 세트를 결합하기 위해 미세 조정을 진행하였다. 또한, SuperGLUE 작업에는 Definite Pronoun Resolution (DPR) 데이터 세트도 포함시켰다.</p><p>CNN/Daily Mail 데이터 세트는 텍스트 요약 작업으로 적용되었고, SQuAD는 일반적인 질문 응답 벤치마크이다. WMT 영어-독일어, 영어-프랑스어, 영어-루마니아어 번역에는 각각 표준 훈련 데이터와 검증 세트를 사용한다. 모든 사전 학습은 영어 데이터로만 진행되며, 모델이 새로운 언어의 텍스트를 생성하도록 배우기 위해 번역 학습이 필요하다.</p><h3 id=input-and-output-format>Input and Output Format</h3><p>모든 작업을 &ldquo;text-to-text&rdquo; 형식으로 표현하여 단일 모델을 훈련시킨다. 이 방식은 사전 학습과 미세 조정에 대해 일관된 훈련 목표를 제공한다. 모델은 작업에 관계없이 maximum likelihood 목표로 훈련되며, 수행해야 할 작업을 지정하기 위해 원래 입력 시퀀스 앞에 작업 특정 텍스트 접두어(prefix)를 추가한다.</p><p>Text-to-text 프레임워크는 다양한 NLP 작업을 통일된 형식으로 변환한다. McCann et al이 제안한 &ldquo;Natural Language Decathlon"과 비슷하지만, 이 논문에서는 각 작업을 개별적으로 미세조정하고 짧은 작업 접두어를 사용한다. 또한 전이 학습에 초점을 맞추며, 기계 번역과 추상적 요약 등의 생성적 작업을 처리할 수 있는 프레임워크를 제안한다.</p><p>대부분의 작업을 text-to-text 형식으로 쉽게 변환했으며, 유사성 점수를 예측하는 STS-B는 점수를 반올림하고 숫자 문자열로 변환하여 처리하였다. 이를 통해 STS-B 회귀 문제를 21 클래스 분류 문제로 재구성하였다.</p><p>또한, Winograd 작업과 WSC 작업에서는 모호한 대명사를 강조하고, 모델이 대명사가 가리키는 명사를 예측하도록 훈련시켰다. DPR 데이터 세트는 대략 1,000개의 대명사 해결 예제를 추가하여 사용하였다.</p><p>WNLI의 훈련 및 검증 세트는 WSC와 많이 중복되므로, 훈련 데이터로의 유출을 방지하기 위해 WNLI에서 훈련하지 않았으며, 평균 GLUE 점수에도 포함시키지 않았다.</p><hr><h2 id=experiments>Experiments</h2><p>한 번에 하나씩 설정을 변경하면서 체계적으로 기여도를 연구하였다. 예를 들어, 나머지 실험 파이프라인을 고정하고 다양한 비지도 목표의 성능을 측정했다. 이 방법은 이차 효과를 놓칠 수 있지만, 모든 요인의 조합을 탐색하는 것은 비용이 많이 든다. 미래의 연구에서는 다양한 접근법의 조합을 더 철저하게 고려하는 것이 유익할 것으로 예상된다.</p><p>이 논문의 목표는 다양한 작업에 대해 다양한 접근법을 비교하는 것으로, 가능한 한 많은 요소를 고정하려고 한다. 이를 위해, 기존의 접근법을 정확하게 따르지는 않았다. 예를 들어, BERT와 같은 encoder-only 모델은 생성 작업에는 적합하지 않다. 따라서 우리가 고려하는 모델 중 어느 것도 BERT와 정확히 같지 않다. 대신, BERT의 목표와 유사한 목표를 고려하고, BERT와 유사하게 작동하는 모델 아키텍처를 고려하였다.</p><h3 id=baseline>Baseline</h3><p>간단한 denoising 목표를 사용하여 표준 Transformer를 사전 학습하고, 각 downstream task에서 별도로 미세 조정을 진행한다.</p><h4 id=model-1>Model</h4><p>T5는 standard encoder-decoder Transformer를 사용한다. 많은 NLP 전이 학습 방법이 single “stack” 구조를 사용하지만, 이 연구에서는 standard encoder-decoder 구조가 생성과 분류 작업에서 좋은 결과를 얻는다는 것을 확인하였다.</p><p>$BERT_BASE$와 유사한 크기와 구성의 인코더와 디코더로 설계되었다. 인코더와 디코더는 각각 12개의 블록으로 이루어져 있으며, 이 블록들은 self-attention, encoder-decoder attention, feed-forward network를 포함하고 있다. 모델은 총 약 2억 2천만 개의 parameter를 가지고 있으며, 모든 부분에서 0.1의 드롭아웃 확률을 사용하여 정규화된다.</p><h4 id=training>Training</h4><p>모든 작업은 text-to-text로 구성되며, 이를 통해 standard maximum likelihood를 사용하여 학습한다. 최적화는 AdaFactor를 사용하고, 테스트 시에는 가장 높은 확률의 logit을 선택하는 greedy decoding을 사용한다.</p><p>각 모델은 C4에서 524,288 단계동안 사전 학습 후 미세 조정을 진행한다. 최대 시퀀스 길이는 512이며, 배치 크기는 128 시퀀스이다. 배치는 대략 65,536 토큰을 포함하도록 한다. 이는 총 34B 토큰에 대한 사전 학습에 해당하며, BERT나 RoBERTa에 비해 상당히 적다. 하지만 이런 방식을 사용하면 합리적인 계산 비용으로 충분한 사전 학습을 할 수 있다. 사전 학습 동안 데이터는 반복하지 않는다.</p><p>사전 학습 동안, &ldquo;inverse square root&rdquo; learning rate schedule을 사용한다. 초기 $10^4$ 단계 동안 learning rate를 0.01로 유지한 후 지수적으로 감소시킨다. triangular learning rate를 실험해 봤지만, 학습 단계의 총 수를 미리 알아야 하므로, 더 일반적인 inverse square root schedule을 선택하였다.</p><p>모든 작업에 대해 262,144 단계 동안 모델을 미세 조정한다. 이는 대규모와 소규모 데이터 세트를 가진 작업 사이의 균형을 위해 선택되었다. 미세 조정 시 128개의 길이 512 시퀀스를 가진 배치를 사용하고, 학습률은 0.001로 유지한다. 5,000step마다 체크포인트를 저장하며, 가장 높은 검증 성능을 보인 체크포인트의 결과를 보고한다. 여러 작업에 미세 조정된 모델의 경우, 각 작업마다 최적의 체크포인트를 독립적으로 선택한다.</p><h4 id=vocabulary>Vocabulary</h4><p>SentencePiece를 사용하여 텍스트를 WordPiece 토큰으로 인코딩하며, 32,000개의 어휘를 사용한다. T5 모델이 다른 언어를 처리할 수 있도록, 영어, 독일어, 프랑스어, 루마니아어 데이터를 혼합하여 SentencePiece 모델을 훈련시켰다. 이 어휘는 모델의 입력과 출력에 모두 사용되며, 미리 결정된 고정된 언어 세트만 처리할 수 있다.</p><h4 id=unsupervised-objective>Unsupervised Objective</h4><p><img src=/p/t5/images/figure2.png width=908 height=322 srcset="/p/t5/images/figure2_hud0a0f0860146969ba93fdd537c6f86ff_60008_480x0_resize_box_3.png 480w, /p/t5/images/figure2_hud0a0f0860146969ba93fdd537c6f86ff_60008_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=281 data-flex-basis=676px></p><p>레이블이 없는 데이터를 활용하여 모델을 사전 학습하는데는, 레이블이 필요하지 않지만 일반화 가능한 지식을 모델에게 가르치는 목표가 필요하다. 최근 &ldquo;denoising&rdquo; 또는 &ldquo;masked language modeling"이라는 목표가 효과적이라는 것이 밝혀졌다. 이는 모델이 입력에서 누락되거나 손상된 토큰을 예측하도록 하는 방식이다. 이에 영감을 받아, 입력 시퀀스에서 무작위로 선택한 15%의 토큰을 드롭아웃하는 목표를 설정하였다. 이 목표는 사전 훈련의 계산 비용을 줄이는 데 도움이 된다.</p><h4 id=baseline-performance>Baseline Performance</h4><p>이상적으로는 모든 실험을 여러 번 반복해야 하지만, 실험의 수가 많으면 비용이 높다. 대신, 기본 모델을 10번 새로 학습하고, 이 실행들의 분산이 각 실험 변형에 적용될 것으로 가정한다. 또한, 사전 학습 없이 모델을 218 step 동안 학습한 후 성능을 측정하여, 사전 학습이 얼마나 도움이 되는지 파악한다.</p><p>GLUE와 SuperGLUE는 모든 하위 작업의 평균 점수를, 번역 작업은 SacreBLEU에서 제공하는 BLEU 점수를 확인한다. WMT 영어에서 독일어, 프랑스어, 루마니아어로의 점수를 각각 EnDe, EnFr, EnRo라 표기한다. CNN/Daily Mail과 SQuAD는 상관성이 높은 지표만 확인한다.</p><p><img src=/p/t5/images/table1.png width=1106 height=174 srcset="/p/t5/images/table1_hub03ae50202d8dc9ff0432f7515727b68_41938_480x0_resize_box_3.png 480w, /p/t5/images/table1_hub03ae50202d8dc9ff0432f7515727b68_41938_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=635 data-flex-basis=1525px></p><p>T5 모델은 $BERT_{BASE}$와 비슷한 성능을 보여준다(SQuAD에서 80.88, MNLI-matched에서 84.24). 하지만 T5 모델은 encoder-decoder 모델로, 사전 학습 단계가 더 적어 직접 비교는 어렵다. 대부분의 벤치마크에서 사전 학습이 성능을 크게 향상시키는 것을 확인했고, WMT 영어에서 프랑스어로의 작업을 통해 high-resource regime 상태에서의 전이 학습을 테스트하였다. 데이터가 제한된 작업에서 사전 학습이 얼마나 성능을 향상시키는지 강조하는 동시에, 전이 학습의 주요 이점 중 하나로 데이터 효율성의 개선을 강조한다.</p><p>대부분의 작업에서 표준 편차는 작업의 기준 점수의 1% 미만이다. 하지만 GLUE와 SuperGLUE 벤치마크의 CoLA, CB, COPA와 같은 low-resource 작업에서는 이 규칙이 적용되지 않는다. 예를 들어, CB 작업에서 기준 모델의 평균 F1 점수는 91.22이고 표준 편차는 3.237이었다. 이런 변동성은 검증 세트의 예제 수가 적은 것이 원인일 수 있다. GLUE와 SuperGLUE 점수는 각 벤치마크의 작업 점수의 평균으로 계산되기 때문에 이러한 높은 변동성 때문에 이 점수만으로 모델을 비교하는 것은 어려울 수 있다.</p><h3 id=architectures>Architectures</h3><p>Transformer는 처음에는 encoder-decoder 구조로 소개되었지만, 최근 NLP 전이 학습 연구에서는 다른 구조를 더 많이 사용하고 있다.</p><h4 id=model-structures>Model Structures</h4><p><img src=/p/t5/images/figure3.png width=954 height=382 srcset="/p/t5/images/figure3_hu58b7a3434dc501afb6d7e3563e21094b_77654_480x0_resize_box_3.png 480w, /p/t5/images/figure3_hu58b7a3434dc501afb6d7e3563e21094b_77654_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=249 data-flex-basis=599px></p><p>아키텍처를 구분하는 주요 요소는 모델에서 사용하는 &ldquo;mask"이다. Transformer의 self-attention 연산은 시퀀스를 입력받아 동일한 길이의 새로운 시퀀스를 출력한다. 각 출력 항목은 입력 항목의 weighted average를 계산해 생성된다. attention mask는 특정 가중치를 0으로 만들어 특정 출력 시간에서 입력 항목에 attention을 기울일 수 있는 범위를 제한한다. 예를 들어, causal mask는 $j > i$인 경우 가중치를 0으로 만든다.</p><p><img src=/p/t5/images/figure4.png width=1016 height=420 srcset="/p/t5/images/figure4_hue70c5b5abebaed2b9ecd54b934dd8154_113297_480x0_resize_box_3.png 480w, /p/t5/images/figure4_hue70c5b5abebaed2b9ecd54b934dd8154_113297_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=241 data-flex-basis=580px></p><p>첫 번째로 고려하는 모델은 encoder-decoder Transformer로, 입력 시퀀스를 받는 encoder와 새로운 출력 시퀀스를 만드는 decoder 두 계층으로 구성되어 있다.</p><p>encoder는 &ldquo;fully-visible&rdquo; attention mask를 사용한다. 이 마스킹은 출력의 각 항목을 만들 때 입력의 모든 항목에 attention을 기울일 수 있게 해준다. 이 마스킹은 &ldquo;prefix&rdquo; 즉, 예측을 만들 때 사용되는 일부 컨텍스트에 주의를 기울일 때 적합하다. BERT도 이와 같은 마스킹 패턴을 사용하며, 특별한 &ldquo;classification&rdquo; 토큰을 입력에 추가한다. 이 토큰에 해당하는 BERT의 출력은 입력 시퀀스를 분류하는 예측을 하는데 사용된다.</p><p>Transformer의 decoder에서 self-attention 연산은 &ldquo;causal&rdquo; 마스킹 패턴을 사용한다. 출력 시퀀스의 $i$번째 항목을 생성할 때, 인과적 마스킹은 모델이 입력 시퀀스의 $j$번째 항목$(j > i)$에 attention을 기울이는 것을 방지한다. 이는 모델이 출력을 생성하는 동안 &ldquo;미래를 보는&rdquo; 것을 방지하기 위해 훈련 중에 사용된다.</p><p>언어 모델은 text-to-text 작업에서 입력과 목표를 연결함으로써 사용될 수 있지만, causal 마스킹 때문에 입력 시퀀스의 특정 항목이 그 이전 항목에만 의존하는 문제가 있다. 이 문제는 Transformer 기반 언어 모델에서 마스킹 패턴을 변경함으로써 해결할 수 있으며, 시퀀스의 접두사 부분에서 완전히 보이는 마스킹을 사용하면 이 문제를 피하면서도 다양한 text-to-text 작업에 효과적일 수 있다. 이 방식은 encoder와 decoder 간에 파라미터를 공유하는 encoder-decoder 모델과 유사하며, 입력과 목표 시퀀스에 걸쳐 전체 attention을 적용한다.</p><p>prefix LM은 BERT와 비슷하게 작동하지만, 분류 작업을 수행하기 위해 Transformer decoder의 출력 레이어에 분류기를 통합한다. 이 모델은 전체 입력을 보고 예측을 출력함으로써 분류 작업을 수행한다.</p><h4 id=comparing-different-model-structures>Comparing Different Model Structures</h4><p>아키텍처를 비교하려면, 각 모델이 같은 수의 parameter를 가지거나, 같은 양의 계산을 필요로 하는 등 의미 있는 방식으로 동일해야 한다. encoder와 decoder가 각각 L개의 레이어를 가진 encoder-decoder 모델은, 2L개의 레이어를 가진 언어 모델과 대략 같은 수의 parameter를 가진다. 그러나 계산 비용 면에서는, L개의 레이어를 가진 언어 모델과 동일하다. 이는 언어 모델이 입력과 출력 시퀀스 모두를 처리해야 하지만, encoder-decoder 모델은 각각 입력과 출력 시퀀스만을 처리하기 때문이다.</p><p>비교를 위해, encoder-decoder 모델의 여러 구성을 고려하였다. $BERT_{BASE}$ 크기의 레이어 스택에서 레이어와 parameter의 수를 각각 L과 P로, 주어진 입력-타겟 쌍 처리에 필요한 FLOPs의 수를 M으로 표현하겠습니다. 이를 바탕으로 모델들을 비교한다:</p><ul><li>encoder와 decoder에 각각 L 레이어가 있는 encoder-decoder 모델. 이 모델은 2P의 parameter와 M FLOPs의 계산 비용을 가진다.</li><li>동일한 모델이지만, 인코더와 디코더 간에 parameter가 공유되어, P의 parameter와 M-FLOP의 계산 비용을 가진다.</li><li>encoder와 decoder에 각각 L/2 레이어가 있는 encoder-decoder 모델로, P의 parameter와 M/2-FLOP의 비용을 가진다.</li><li>L 레이어와 P parameter를 가지며 M FLOPs의 계산 비용이 발생하는 decoder-only 언어 모델.</li><li>같은 아키텍처를 가지지만, 입력에 대한 fully-visible self-attention을 가진 decoder-only prefix LM.</li></ul><h4 id=objectives>Objectives</h4><p>비지도 학습 목표로 기본 언어 모델링과 denoising 목표를 고려하였다. 언어 모델링은 사전 학습 목표로서의 역사적 사용과 모델 아키텍처에 대한 적합성 때문에 포함되었다. 예측 전에 접두사를 입력하는 모델들에 대해, 레이블이 없는 데이터에서 텍스트를 샘플링하고 랜덤한 지점에서 접두사와 타겟으로 분할한다. 표준 언어 모델은 전체 텍스트를 예측하도록 훈련되며, text-to-text 모델을 위한 비지도 denoising 목표는 입력과 타겟을 연결하여 사용한다.</p><h4 id=results>Results</h4><p><img src=/p/t5/images/table2.png width=1330 height=404 srcset="/p/t5/images/table2_huf6638c8c2bc117ff25ac7c6022eeb34d_123609_480x0_resize_box_3.png 480w, /p/t5/images/table2_huf6638c8c2bc117ff25ac7c6022eeb34d_123609_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=329 data-flex-basis=790px></p><p>모든 작업에서 denoising 목표를 가진 encoder-decoder 구조가 가장 좋은 성능을 보여주었다. 이 구조는 parameter 수는 가장 많지만 계산 비용은 decoder-only 모델과 같다. encoder와 decoder 간에 parameter를 공유하는 것도 거의 동등한 성능을 보여주었다. 반면, encoder와 decoder의 레이어 수를 줄이면 성능이 크게 저하되었다. denoising 목표를 가진 공유 encoder-decoder 구조는 decoder-only prefix LM 모델보다 성능이 좋았다. 마지막으로, denoising 목표를 사용하는 것이 언어 모델링 목표보다 항상 더 나은 성능을 가져다 준다는 사실을 확인하였다.</p><h3 id=unsupervised-objectives>Unsupervised Objectives</h3><p>비지도 학습 목표의 선택은 모델이 downstream task에 적용할 일반 지식을 획득하는 방법을 제공하므로 중요하며, 이로 인해 다양한 사전 학습 목표가 개발되었다. 많은 경우에 기존의 목표를 그대로 복제하지 않고, text-to-text encoder-decoder 프레임워크에 맞게 수정하거나, 여러 공통 접근법의 개념을 결합한 목표를 사용한다.</p><p><img src=/p/t5/images/table3.png width=1524 height=288 srcset="/p/t5/images/table3_hu4cef11ab70bdbad4421eb2667d9e4b35_103192_480x0_resize_box_3.png 480w, /p/t5/images/table3_hu4cef11ab70bdbad4421eb2667d9e4b35_103192_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=529 data-flex-basis=1270px></p><p>라벨이 없는 텍스트 데이터 세트에서 토큰화된 텍스트 범위에 해당하는 토큰 ID의 시퀀스를 처리한다. 토큰 시퀀스는 입력 시퀀스와 목표를 생성하고, 모델은 이를 사용해 maximum likelihood로 목표 시퀀스를 예측하도록 학습한다.</p><h4 id=disparate-high-level-approaches>Disparate High-Level Approaches</h4><p>세 가지 다른 접근법을 사용한 기법들을 비교한다. 첫 번째로, &ldquo;prefix language modeling&rdquo; 목표를 사용하며, 이는 텍스트를 두 부분으로 나눠 encoder 입력과 decoder 예측 대상으로 사용한다. 두 번째로, BERT의 &ldquo;masked language modeling"에서 영감을 받은 목표를 사용하며, 이는 텍스트의 토큰 15%를 손상시키고, 이 중 90%는 마스크 토큰, 10%는 랜덤 토큰으로 대체한다. 세 번째로, &ldquo;deshuffling&rdquo; 목표를 사용하며, 이는 토큰의 순서를 섞은 후 원래 순서를 복원하는 것을 목표로 한다.</p><p><img src=/p/t5/images/table4.png width=1148 height=170 srcset="/p/t5/images/table4_hucd8c36f3593092fa88fcbef0571dc050_48099_480x0_resize_box_3.png 480w, /p/t5/images/table4_hucd8c36f3593092fa88fcbef0571dc050_48099_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=675 data-flex-basis=1620px></p><p>전체적으로, BERT 스타일 목표가 가장 뛰어난 성능을 보이지만, prefix language modeling 목표도 번역 작업에서 유사한 성능을 보여준다. 반면에 deshuffling 목표는 다른 두 목표보다 성능이 상당히 떨어진다.</p><h4 id=simplifying-the-bert-objective>Simplifying the BERT Objective</h4><p>BERT 스타일의 denoising 목표는 원래 분류와 범위 예측을 위해 학습된 encoder-only 모델의 사전 학습 기법으로 제안되었다. 따라서 encoder-decoder text-to-text 설정에서 더 나은 성능을 내거나 더 효율적이게 만들 수 있도록 조정하는 것이 가능할 수 있다.</p><p>BERT 스타일 목표의 간단한 변형을 고려하며, 이는 무작위 토큰 교환 단계를 생략한다. 그 결과, 입력의 15% 토큰을 마스크 토큰으로 바꾸고, 모델은 원래 손상되지 않은 시퀀스를 재구성하도록 학습한다. 이를 &ldquo;MASS&rdquo; 목표라고 부릅니다. 또한, decoder에서 긴 시퀀스 자체에 대한 attention를 피할 수 있는 방법을 탐색한다. 이를 위해, 손상된 토큰들을 모두 마스크 토큰으로 대체하거나, 손상된 토큰을 입력 시퀀스에서 완전히 삭제하는 두 가지 전략을 고려한다.</p><p><img src=/p/t5/images/table5.png width=1164 height=206 srcset="/p/t5/images/table5_hu25f2653fef6f13a93df98915514a50bb_63030_480x0_resize_box_3.png 480w, /p/t5/images/table5_hu25f2653fef6f13a93df98915514a50bb_63030_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=565 data-flex-basis=1356px></p><p>원래의 BERT 스타일 목표와 세 가지 대안의 비교는 모든 변형이 비슷하게 수행된다는 것을 보여준다. 예외적으로, 손상된 토큰을 완전히 삭제하는 것이 CoLA에서 훨씬 높은 점수 덕분에 GLUE 점수를 약간 향상시켰는데, CoLA가 주어진 문장이 문법적으로 및 구문론적으로 수용 가능한지 분류하는 것을 포함하고 있으며, 토큰이 누락되었는지 판단할 수 있는 능력이 수용 가능성을 감지하는 데 밀접하게 관련되어 있기 때문일 수 있다. 그러나, 토큰을 완전히 삭제하는 것은 SuperGLUE에서 성능이 떨어졌다. 전체 원래 시퀀스를 예측할 필요가 없는 두 가지 변형은 훈련 시간을 단축시키는 장점이 있다.</p><h4 id=varying-the-corruption-rate>Varying the Corruption Rate</h4><p><img src=/p/t5/images/table6.png width=990 height=212 srcset="/p/t5/images/table6_hu60faf8658ec9e582286a0ecbf3ba4c0c_48105_480x0_resize_box_3.png 480w, /p/t5/images/table6_hu60faf8658ec9e582286a0ecbf3ba4c0c_48105_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=466 data-flex-basis=1120px></p><p>지금까지 BERT에서 사용된 15%의 토큰 손상률을 사용하였다. 그러나 text-to-text 프레임워크가 BERT와 다르므로 다른 손상률이 더 효과적인지 테스트해 보았다. 10%, 15%, 25%, 50%의 손상률을 비교했지만, 손상률이 모델 성능에 큰 영향을 미치지는 않았다. 단, 50%의 가장 높은 손상률은 GLUE와 SQuAD에서 성능 저하를 가져왔다. 또한, 높은 손상률은 학습 속도를 느리게 만드는 긴 대상을 만드는 경향이 있다. 따라서 BERT의 기준에 따라 앞으로 15%의 손상률을 사용할 것이다.</p><h4 id=corrupting-spans>Corrupting Spans</h4><p>예측 대상을 짧게 하여 학습 속도를 높이려고 한다. 지금까지의 방법은 각 입력 토큰을 독립적으로 손상시킬지 결정하였고, 연속된 토큰이 손상될 경우 이를 &ldquo;span"으로 취급하여 단일 마스크 토큰으로 대체하였다. 이 방식은 레이블이 없는 텍스트 데이터를 짧은 시퀀스로 변환하지만, 항상 많은 수의 손상된 토큰이 연속적으로 나타나지는 않는다. 따라서 토큰의 span을 특정하여 손상시키는 방식을 사용하면 더 큰 속도 향상을 얻을 수 있습니다. 이러한 방법은 BERT의 사전 학습 목표로도 사용되어 성능 향상을 가져왔다.</p><p>토큰의 연속적인 span을 손상시키는 목표를 테스트하기 위해, 손상시킬 토큰의 비율과 손상된 span의 총 수를 parameter로 사용한다. 예를 들어, 500개의 토큰 시퀀스에서 15%의 토큰을 손상시키고 총 span이 25개가 되도록 지정하면, 손상된 토큰의 총 수는 75개이고 평균 span 길이는 3이 된다. 이 방식은 원래의 시퀀스 길이와 손상률에 따라 span의 길이나 총 span 수를 조절할 수 있다.</p><p><img src=/p/t5/images/table7.png width=978 height=238 srcset="/p/t5/images/table7_huae5c3427b58561a089d0c71ef313c023_55278_480x0_resize_box_3.png 480w, /p/t5/images/table7_huae5c3427b58561a089d0c71ef313c023_55278_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=410 data-flex-basis=986px></p><p>span 손상 목표와 독립 동일 분포(i.i.d) 손상 목표를 비교한 결과, 이들 사이에는 큰 차이가 없었다. 하지만 평균 span 길이가 10인 경우에는 일부에서 다른 값들보다 성능이 약간 떨어졌다. 반면에 평균 span 길이가 3인 경우에는 대부분의 비번역 벤치마크에서 i.i.d. 목표를 약간 능가하였다. 또한 span 손상 목표는 평균적으로 더 짧은 시퀀스를 생성함으로써 학습 속도를 빠르게 할 수 있었다.</p><h4 id=discussion>Discussion</h4><p><img src=/p/t5/images/figure5.png width=722 height=378 srcset="/p/t5/images/figure5_hu64e6cb9f6d88cd1de9cb8c348334d5db_76782_480x0_resize_box_3.png 480w, /p/t5/images/figure5_hu64e6cb9f6d88cd1de9cb8c348334d5db_76782_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=191 data-flex-basis=458px></p><p>denoising 목표가 언어 모델링 및 deshuffling보다 사전 학습에 더 효과적이었다. 또한 denoising 목표의 다양한 변형 사이에는 큰 차이가 없었다. 그러나 목표의 선택이나 parameter화는 시퀀스 길이와 학습 속도에 영향을 미친다. 따라서 denoising 목표의 선택은 주로 계산 비용에 기반해 이루어져야 한다. 또한, 유사한 목표에 대한 추가적인 탐색은 큰 이익을 가져오지 않을 수 있으며, 레이블이 없는 데이터를 활용하는 새로운 방법을 탐색하는 것이 더 유익할 수 있다.</p><h3 id=pre-training-data-set>Pre-training Data set</h3><p>사전 학습 데이터 세트는 전이 학습 파이프라인의 핵심 요소이지만, 새로운 데이터 세트는 종종 중요한 기여로 인식되지 않고, 사전 학습된 모델과 코드와 함께 공개되지 않는다. 그 결과, 다양한 사전 학습 데이터 세트의 비교는 부족하고 &ldquo;표준&rdquo; 데이터 세트도 없다. 최근에는 큰 데이터 세트와 작은 기존 데이터 세트에서의 사전 학습을 비교한 연구가 있다.</p><h4 id=unlabeled-data-sets>Unlabeled Data Sets</h4><p>C4 제작 과정에서, Common Crawl로부터 추출한 웹 텍스트를 필터링하기 위한 다양한 방법을 개발하였다. 이 필터링이 다른 방법과 비교하여 downstream task에서 성능 향상을 가져오는지 측정하려 한ㄴ다. 이를 위해 다양한 데이터 세트에서 사전 학습한 후의 기준 모델 성능을 비교하였다.</p><p><strong>C4</strong> 기준이 되는 데이터셋으로, 레이블 없는 데이터 세트에서 사전 훈련하는 것을 고려한다.</p><p><strong>Unfiltered C4</strong> C4를 생성할 때 사용한 휴리스틱 필터링의 효과를 측정하기 위해, 필터링을 생략한 C4의 대체 버전을 만들었다. 하지만, 영어 텍스트 추출을 위해 langdetect는 여전히 사용되며, 이로 인해 &ldquo;unfiltered&rdquo; 버전도 어느 정도 필터링이 포함된다.</p><p><strong>RealNews-like</strong> 최근 연구에서는 뉴스 웹사이트에서 추출한 텍스트 데이터를 사용하였다. 이를 비교하기 위해, C4를 필터링하여 &ldquo;RealNews&rdquo; 데이터 세트에서 사용된 도메인의 콘텐츠만 포함하도록 한 새로운 레이블 없는 데이터 세트를 생성하였다. C4에서 사용된 필터링 방법을 유지하되, 비뉴스 콘텐츠는 모두 제외하였다.</p><p><strong>WebText-like</strong> WebText 데이터 세트는 Reddit에 제출된 웹페이지 중 점수가 3점 이상인 콘텐츠만 사용했다. 비교 가능한 데이터 세트를 만들기 위해, C4에서 OpenWebText 목록에 없는 URL의 콘텐츠를 모두 제거하였다. 하지만, 대부분의 페이지가 Reddit에 나타나지 않아, 결과적으로 콘텐츠가 많지 않았다. 그래서, 2018년 8월부터 2019년 7월까지의 Common Crawl 데이터를 다운로드하여 필터링을 적용하였고, 이를 통해 원래의 WebText 데이터 세트와 비교 가능한 17GB의 데이터 세트를 생성하였다.</p><p><strong>Wikipedia</strong> Wikipedia는 엄격한 품질 가이드라인을 준수하는 수백만 개의 협업 글로 이루어져 있다. 이러한 특성 때문에 Wikipedia는 청결하고 자연스러운 텍스트의 신뢰성 있는 출처로 활용되었다. 기사의 마크업이나 참조 섹션을 생략한 TensorFlow Datasets의 영어 Wikipedia 텍스트 데이터를 사용하고 있다.</p><p><strong>Wikipedia + Toronto Books Corpus</strong> Wikipedia의 사전학습 데이터를 사용하는 단점은 자연어 텍스트의 한 도메인만을 대표한다는 것이다. 이를 보완하기 위해 BERT는 Wikipedia 데이터와 전자책에서 추출한 텍스트를 담은 Toronto Books Corpus를 결합하였다.</p><p><img src=/p/t5/images/table8.png width=1116 height=266 srcset="/p/t5/images/table8_hub5142a928751920f9041e3dd3f39acdd_75926_480x0_resize_box_3.png 480w, /p/t5/images/table8_hub5142a928751920f9041e3dd3f39acdd_75926_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=419 data-flex-basis=1006px></p><p>사전 학습 데이터 세트의 도메인이 제한된 경우, 다양한 데이터 세트를 사용한 것보다 성능이 뛰어날 수 있다. 특히, 해당 도메인과 관련된 작업에서 성능 향상이 두드러진다. 하지만, 이 방법은 모든 도메인의 언어 작업에 빠르게 적응하는 모델을 만드는 목표와는 약간 다르다.</p><p>단일 도메인에서만 사전 학습을 하는 것의 단점은 결과적으로 데이터 세트가 작아진다. WebText와 유사한 변형은 C4 데이터 세트와 같거나 더 좋은 성능을 보였지만, Reddit 기반 필터링은 더 많은 데이터에도 불구하고 C4보다 훨씬 작은 데이터 세트를 만들었다.</p><h4 id=pre-training-data-set-size>Pre-training Data set Size</h4><p>제한된 레이블 없는 데이터 세트 크기의 영향을 테스트하기 위해, C4를 인공적으로 줄인 버전에서 베이스라인 모델을 사전 학습시켰다. 이 때, 다양한 크기의 축소된 C4 변형에서 학습을 진행하였으며, 이는 사전 학습 과정에서 데이터 세트를 각각 64, 256, 1,024, 4,096번 반복하는 것을 의미한다.</p><p><img src=/p/t5/images/table9.png width=1122 height=240 srcset="/p/t5/images/table9_hub7a867d791705562125ad072f0ae3b43_56330_480x0_resize_box_3.png 480w, /p/t5/images/table9_hub7a867d791705562125ad072f0ae3b43_56330_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=467 data-flex-basis=1122px></p><p>데이터 세트 크기가 줄어들면서 성능이 저하되는 것을 확인할 수 있다. 이는 모델이 사전 학습 데이터를 기억하기 시작하면서 발생하는 것으로 보인다. 이를 검증하기 위해 각 데이터 세트 크기에 대한 학습 손실을 그렸고, 데이터 세트 크기가 줄어들면서 학습 손실이 크게 감소하는 것을 확인하였다. 이는 모델이 데이터를 기억하고 있음을 나타내는 증거일 수 있다.</p><p><img src=/p/t5/images/figure6.png width=738 height=426 srcset="/p/t5/images/figure6_hub75381f4df7e5bfa5754f4d164a6e5ed_71302_480x0_resize_box_3.png 480w, /p/t5/images/figure6_hub75381f4df7e5bfa5754f4d164a6e5ed_71302_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=173 data-flex-basis=415px></p><p>사전 학습 데이터 세트가 64번만 반복될 때, 이러한 효과는 제한적이라는 것을 확인하였다. 이는 일정량의 사전 학습 데이터 반복이 해롭지 않을 수 있음을 나타낸다. 추가적인 사전 학습이 유익하고 레이블이 없는 추가 데이터를 쉽게 얻을 수 있으므로, 가능하면 큰 사전 훈련 데이터 세트를 사용하는 것이 좋다. 더 큰 모델은 작은 사전 학습 데이터 세트에 과적합되는 경향이 더욱 강하게 나타난다.</p><h3 id=training-strategy>Training Strategy</h3><h4 id=fine-tuning-methods>Fine-tuning Methods</h4><p>초기 연구에서는 사전 학습된 모델의 문장 임베딩을 사용하는 작은 분류기의 parameter만 미세 조정하는 것을 제안하였다. 하지만 이 방법은 encoder-decoder 모델에는 적용하기 어렵다. 대신, 모델의 일부 parameter만 업데이트하는 두 가지 대안적인 미세 조정 방법을 고려한다.</p><p>&ldquo;adapter layers"는 원래 모델의 대부분을 고정하고 미세 조정하는 방법이다. Transformer의 각 블록에 dense-ReLU-dense 블록 형태의 adapter layer를 추가하며, 이 layer는 출력 차원이 입력과 같도록 설계된다. 미세 조정 시, adapter layer와 layer normalization parameter만 업데이트되며, 전방향 네트워크의 내부 차원 $d$는 신규 parameter의 수를 결정하는 주요 hyperparameter이다.</p><p>&ldquo;gradual unfreezing"은 시간이 지남에 따라 모델의 parameter를 점차 미세 조정하는 방식이다. 미세 조정 시작 시 최종 층의 parameter만 업데이트하고, 일정 업데이트 후에는 이전 층의 parameter도 포함시키는 방식으로 진행된다. 이 방법은 encoder와 decoder의 층을 동시에 상단부터 점진적으로 언프리징하며, 미세 조정 과정은 12개의 단계로 나누어 진행된다. 이 방식은 데이터 세트 크기의 다양성과 복합 작업의 존재 때문에 채택되었다.</p><p><img src=/p/t5/images/table10.png width=1078 height=266 srcset="/p/t5/images/table10_hu0ed6c9e3c0f7f8b5ed49c577b04da6e5_72206_480x0_resize_box_3.png 480w, /p/t5/images/table10_hu0ed6c9e3c0f7f8b5ed49c577b04da6e5_72206_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=405 data-flex-basis=972px></p><p>adapter layers는ㄴ 작업 크기에 따라 차원을 적절히 조정하면 parameter가 적은 상태에서도 미세 조정이 가능하다는 것을 보여준다. 반면에, gradual unfreezing은 미세 조정 시간을 단축시키지만, 모든 작업에서 성능이 약간 떨어진다는 결과를 보여주었다. 이를 통해 언프리징 일정을 더 신중하게 조정하면 더 나은 결과를 얻을 수 있을 것으로 예상된다.</p><h4 id=multi-task-learning>Multi-task Learning</h4><p>Multi-task Learning은 여러 작업을 동시에 학습하는 방법으로, 하나의 모델이 다양한 작업을 수행하도록 학습한다. 이 방법은 데이터 세트를 혼합하여 레이블이 없는 데이터에서도 학습이 가능하다. 중요한 점은 모델이 각 작업에서 적절한 양의 데이터를 학습하도록 하는 것이며, 이는 데이터 세트 크기, 작업 학습의 난이도, 정규화 등에 따라 달라진다. 또한, 한 작업에서의 성과가 다른 작업의 성능을 저해하는 문제를 고려하여, 데이터 비율 설정 전략을 연구하고 있다.</p><p><strong>Examples-proportional mixing</strong> 모델이 작업에 overfit되는 속도는 작업의 데이터 세트 크기에 따라 결정된다. 그래서 데이터 세트 크기에 비례하여 샘플링하는 것이 일반적이다. 하지만, 어떤 작업은 데이터 크기가 월등히 크기 때문에, 이 방법을 사용하면 레이블이 없는 데이터가 대부분이 되고 모든 지도 작업이 undertrain 되는 문제가 발생한다. 이를 해결하기 위해, 비율을 계산하기 전에 데이터 세트 크기에 인위적인 &ldquo;limit"을 설정한다. 각 작업에서 샘플하는 확률은 작업의 데이터 세트 크기와 인위적인 제한 작은 값에 비례하도록 설정된다.</p><p><strong>Temperature-scaled mixing</strong> 데이터 세트 크기의 큰 차이를 완화하는 다른 방법은 혼합 비율의 &ldquo;temperature"를 조정하는 것이다. 이 방식은 다국어 BERT에서 적용되어, 자원이 적은 언어에 대한 충분한 학습을 보장하였다. 이는 각 작업의 혼합 비율을 1/temperature로 거듭제곱하고, 이 비율이 합쳐져 1이 되도록 재정규화하는 방식으로 이루어진다. 온도가 증가하면 비율은 동등 혼합에 가까워진다. 가장 큰 데이터 세트의 혼합 비율이 감소하는 것을 방지하기 위해 데이터 세트 크기 제한을 큰 값으로 설정한다.</p><p><strong>Equal mixing</strong> 각 작업에서 예제를 동일한 확률로 뽑는다. 각 배치의 예제는 학습 데이터 세트 중 무작위로 선택된다. 이 방법은 low-resource 작업에 빠르게 overfit되고 high-resource 작업에 underfit되기 때문에 최적의 전략이 아닐 가능성이 크다. 이 점은 비율 설정이 최적이 아닐 때 발생할 수 있는 문제를 보여주는 참고점이다.</p><p>이러한 mixing 전략을 기본선인 사전 학습 후 미세 조정 결과와 동일한 기준으로 비교하기 위해, 총 스텝 수가 같은 multi-task Learning 모델을 학습시킨다: $2^{19} + 2^{18} =$ 786,432.</p><p><img src=/p/t5/images/table11.png width=1156 height=410 srcset="/p/t5/images/table11_hu7c72fa05249237ddf7e85e8bbb090e64_128090_480x0_resize_box_3.png 480w, /p/t5/images/table11_hu7c72fa05249237ddf7e85e8bbb090e64_128090_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=281 data-flex-basis=676px></p><p>일반적으로, multi-task Learning은 대부분의 작업에서 사전 학습 후 미세 조정보다 성능이 떨어진다. &ldquo;equal&rdquo; mixing 전략은 특히 성능이 크게 저하되며, 이는 작업에 따른 데이터의 불균형 때문일 수 있다. examples-proportional mixing에서는 대부분의 작업에 대해 모델이 최적의 성능을 얻는 &ldquo;sweet spot&rdquo; $K$ 값이 있다. 또한, temperature-scaled mixing은 대부분의 작업에서 합리적인 성능을 얻는 수단을 제공한다. 별도의 모델이 각각의 작업에 대해 훈련된 것보다 multi-task 모델이 더 나은 성능을 보이지 못한 것은 이전 연구에서도 관찰된 바 있다.</p><h4 id=combining-multi-task-learning-with-fine-tuning>Combining Multi-Task Learning with Fine-Tuning</h4><p>multi-task Learning의 개선된 버전을 연구하고 있다. 이 방법은 모든 작업에 대해 모델을 사전 학습하고, 각각의 작업에 대해 미세 조정하는 방식으로, 이 방식은 &ldquo;MT-DNN"에서 사용되었으며, GLUE 및 기타 벤치마크에서 state-of-the-art를 달성하였다.</p><p>이 접근법의 세 가지 변형을 고려한다: 첫 번째는 모든 작업을 사전 학습하고 각 작업에 대해 미세 조정하는 것, 두 번째는 하나의 작업을 제외하고 사전 학습한 후 제외된 작업에 대해 미세 조정하는 것, 세 번째는 감독 작업만을 사전 학습하는 것이다. 이 모든 변형에서는 일정 단계 동안 사전 학습 후 미세 조정을 진행하였다.</p><p><img src=/p/t5/images/table12.png width=1236 height=234 srcset="/p/t5/images/table12_hua134220b52c750cb2e15f0b84a5494fc_73598_480x0_resize_box_3.png 480w, /p/t5/images/table12_hua134220b52c750cb2e15f0b84a5494fc_73598_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=528 data-flex-basis=1267px></p><p>multi-task 사전 학습 후 미세 조정을 한 결과가 기준선과 비교해도 비슷한 성능을 보여주었다. 이는 multi-task 학습 후 미세 조정이 다른 mixing 비율 간의 트레이드오프를 완화하는 데 도움이 될 수 있음을 보여준다. 또한, &ldquo;leave-one-out&rdquo; 학습 방식의 성능은 약간만 떨어졌고, 이는 다양한 작업에 대해 학습한 모델이 새로운 작업에도 적응할 수 있음을 시사한다. 그러나, supervised multi-task 사전 학습은 번역 작업을 제외하고는 성능이 떨어졌다. 이는 번역 작업이 사전 학습에서 덜 이익을 보며, 비지도 사전 학습이 다른 작업에서 중요함을 시사한다.</p><h3 id=scaling>Scaling</h3><p>&ldquo;bitter lesson"은 계산을 늘리는 일반적인 방법이 인간의 전문성에 의존하는 방법보다 우월하다는 주장이다. 이는 자연어 처리의 전이 학습에도 적용될 수 있으며, 규모를 확대하는 것이 더 신중한 설계보다 성능을 향상시킴을 보여주었다. 이 논문에서는 &ldquo;4배 더 많은 컴퓨팅 파워를 얻었다면 어떻게 사용해야 할까?&ldquo;라는 주제로, 규모를 확대하는 다양한 방법을 비교한다.</p><p>220M의 parameter를 가진 기준 모델로 시작한다. 이 모델은 &ldquo;$BERT_{BASE}$&ldquo;와 유사한 크기의 encoder와 decoder를 가지고 있다. 모델 크기를 증가시키기 위해, &ldquo;$BERT_{LARGE}$&ldquo;의 가이드라인을 따라 두 가지 변형을 만들어내었다: encoder와 decoder 각각에 16층과 32층을 가진 모델이다. 이들은 원래 모델보다 매개변수가 2배와 4배 많으며, 계산 비용도 2배와 4배이다. 이 모델들을 사용하여 4배의 계산을 사용하는 세 가지 방법을 고려한다: 4배 많은 step 학습, 2배 큰 모델로 2배 많은 step 학습, 그리고 &ldquo;baseline&rdquo; 학습 step에 대해 4배 큰 모델 학습.</p><p>데이터를 4배 더 처리하는 방법 중 하나는 배치 크기를 4배로 늘리는 것이다. 이는 학습 속도를 빠르게 하지만, 4배 많은 학습 step을 사용하는 것과 다른 결과를 가져올 수 있어 이를 비교하기 위한 추가 실험을 진행하였다. 또한, 추가 계산을 활용하는 다른 방법으로는 모델의 앙상블을 사용하는 것이 일반적이다. 이를 비교하기 위해, 4개의 별도로 학습된 모델의 앙상블 성능을 평가했으며, 하나의 모델을 사전 학습하고 이를 4배로 미세 조정하는 비용 절감 방법도 함께 고려하였다.</p><p><img src=/p/t5/images/table13.png width=1130 height=296 srcset="/p/t5/images/table13_hu2213d3324791a2e622eacc00b289ce4d_82725_480x0_resize_box_3.png 480w, /p/t5/images/table13_hu2213d3324791a2e622eacc00b289ce4d_82725_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=381 data-flex-basis=916px></p><p>학습 시간과 모델 크기를 증가시키면 성능이 개선되며, 특히 모델 크기 증가와 앙상블 방법이 더 큰 향상을 가져왔다. 그러나 앙상블 방법은 SuperGLUE에서는 큰 효과를 보이지 못했다. 또한, 스케일링 방법 선택 시, 큰 모델의 미세 조정과 추론 비용, 작은 모델의 학습 시간, 그리고 앙상블의 계산 비용 등을 고려해야 한다. 따라서 모델의 최종 사용을 고려하는 것이 중요하다.</p><h3 id=putting-it-all-together>Putting It All Together</h3><p>자연어 처리 벤치마크에서 얼마나 성능을 끌어올릴 수 있는지 확인하기 위해, baseline 학습 접근법으로 시작하여 다음과 같은 변경을 만든다:</p><p><strong>Objective</strong> 기본 모델의 노이즈 제거 목표를 SpanBERT에서 영감을 받은 span-corruption 목표로 교체하였다. 평균 span 길이 3을 사용하고 원래 시퀀스의 15%를 손상시켰는데, 이 방법은 목표 시퀀스 길이가 짧아 계산 효율성이 높으며, 약간 더 나은 성능을 보여주었다.</p><p><strong>Longer training</strong> 기본 모델은 작은 양의 사전 학습을 사용하지만, C4 데이터셋의 크기 때문에 데이터를 반복하지 않고도 더 오래 학습할 수 있다. 추가적인 사전 학습이 도움이 되며, 배치 크기와 학습 단계 수를 늘리는 것이 이에 도움이 되는 것을 확인하였다. 약 1M 개의 사전 학습 토큰에 대해 모델을 사전 학습하였고, 몇 가지 작은 데이터셋에서는 C4보다 더 좋은 성능을 보였지만, 이 작은 데이터셋들은 1M 토큰의 사전 학습 과정에서 수백 번 반복될 만큼 충분히 작기 때문에, C4 데이터셋을 계속 사용하기로 결정했다.</p><p><strong>Model sizes</strong> 기본 모델 크기를 확장하면 성능이 향상된다는 것을 확인 했지만, 컴퓨팅 자원이 제한된 상황에서는 작은 모델이 유용할 수 있다. 이를 고려하여, 다양한 크기의 모델을 학습시킨다:</p><ul><li><strong>Base</strong> 이 모델은 대략 220M 개의 parameter를 가지고 있다.</li><li><strong>Small</strong> 기본 모델을 축소시키기 위해 512의 $d_{model}$, 2,048의 $d_{ff}$, 8개의 attention head, 그리고 encoder와 decoder 각각에 6개의 layer를 사용한다. 이 모델은 대략 60M 개의 parameter를 가지고 있다.</li><li><strong>Large</strong> 기본 모델이 $BERT_{BASE}$ 크기의 encoder와 decoder를 사용하기 때문에, $BERT_{LARGE}$와 비슷한 크기와 구조를 가진 encoder와 decoder를 가진 변형을 고려하였다. 이 변형은 약 770M 개의 parameter를 가지고 있다.</li><li><strong>3B and 11B</strong> 더 큰 모델을 사용할 때 가능한 성능을 탐색하기 위해 두 가지 추가 변형을 고려하였다. 두 경우 모두에서 $d_{model} = 1024$, 24개 layer의 encoder와 decoder, 그리고 $d_{ff} = 128$을 사용하였다. &ldquo;3B&rdquo; 변형은 $d_{ff} =$ 16,384와 32개의 attention head를 사용하여 약 2.8B의 parameter를 생성했고, &ldquo;11B&rdquo; 변형은 $d_{ff} =$ 65,536과 128개의 attention head를 사용하여 약 11B개의 parameter를 가진 모델을 생성하였다.</li></ul><p><strong>Multi-task pre-training</strong> 비지도 작업과 지도 작업의 다양한 사전 학습된 모델이 비지도 작업만으로 학습된 모델만큼 잘 작동한다는 것을 확인하였다. 이 방법은 학습 기간 동안 성능을 지속적으로 모니터링 할 수 있어 유용하다. 따라서, 최종 실험에서 이 multi-task 사전 학습 방식을 사용했다. 또한, 더 크고 오래 훈련된 모델은 레이블이 없는 데이터의 더 큰 비율에서 이익을 얻을 것으로 예상했다. 이를 바탕으로, 레이블이 없는 데이터를 위해 특정한 인공 데이터 세트 크기를 사용했고, 모든 모델 변형에 대해 WMT English to French 및 WMT English to German 데이터 세트의 크기를 사전 학습 동안 1M 예제로 제한하였다.</p><p><strong>Fine-tuning on individual GLUE and SuperGLUE tasks</strong> GLUE와 SuperGLUE에서 미세 조정할 때, 모든 데이터 세트를 합쳐서 한 번에 모델을 미세 조정하였다. 이 방식은 연구를 단순화하지만, 일부 작업에서는 성능이 약간 떨어진다는 것을 발견하였다. 개별 작업에 미세 조정하는 것은 low-resource 작업에 빠르게 overfit될 위험이 있다. 그래서 각 GLUE와 SuperGLUE 작업에 대한 미세 조정 시 작은 배치 크기를 사용하고, overfit되기 전에 모델의 parameter에 접근할 수 있도록 1,000 단계마다 체크포인트를 저장하였다.</p><p><strong>Beam search</strong> 이전 결과는 모두 greedy decoding을 사용하여 보고되었다. 그러나 긴 출력 시퀀스 작업에서는 beam search로 성능이 향상되었다. WMT 번역과 CNN/DM 요약 작업에서는 beam width 4와 길이 패널티 $\alpha = 0.6$을 사용하였다.</p><p><strong>Test set</strong> 최종 실험에서는 validation set가 아닌 test set 결과를 보고한다. CNN/Daily Mail은 standard test set를, WMT 작업은 각 언어 쌍에 대한 특정 newstest를 사용했다. GLUE와 SuperGLUE는 벤치마크 평가 서버를 통해 test set 점수를 계산했다. SQuAD의 경우, 벤치마크 서버의 컴퓨팅 자원이 부족해 가장 큰 모델에서의 예측을 얻지 못했으므로, 검증 세트 성능을 계속 보고하게 되었다. 하지만 SQuAD test set에서 가장 높은 성능을 보인 모델이 검증 세트 결과도 보고했으므로, state-of-the-art의 기술과 비교 가능하다.</p><p>위에서 언급한 변경사항들을 제외하고, baseline과 같은 학습 절차와 hyperparameter를 사용한다.</p><p><img src=/p/t5/images/table14.png width=1118 height=1358 srcset="/p/t5/images/table14_hu9a784fc3b3eaf96fb53a769d5658efb8_304457_480x0_resize_box_3.png 480w, /p/t5/images/table14_hu9a784fc3b3eaf96fb53a769d5658efb8_304457_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=82 data-flex-basis=197px></p><p>전반적으로, 24개의 작업 중 18개에서 state-of-the-art를 달성하였다. 가장 큰 모델(11B parameter)이 모든 작업에서 가장 우수한 성능을 보였다. T5-3B 모델은 몇몇 작업에서 이전 state-of-the-art를 능가했지만, 11B parameter로 모델 크기를 확장하는 것이 state-of-the-art를 달성하는 데 가장 중요했다.</p><p>T5는 평균 GLUE 점수에서 90.3의 state-of-the-art를 달성하였고, 특히 자연어 추론 작업에서 이전 state-of-the-art 보다 월등히 높은 성능을 보여주었다. 그러나 이 성능은 여러 모델의 앙상블과 대량의 계산을 활용한 결과였다. SQuAD에서는 Exact Match 점수에서 이전 최고 성능을 1점 이상 능가하였으며, SuperGLUE에서는 평균 점수를 크게 향상시켰지만, 일부 작업에서는 여전히 인간의 성능에 미치지 못했다. WMT 번역 작업에서는 state-of-the-art를 달성하지 못했고, CNN/Daily Mail에서는 state-of-the-art를 달성했지만, 요약의 일관성과는 반드시 연결되지 않았다. 이 모든 결과는 앙상블, 외부 데이터 세트 활용 등 다양한 방법을 통해 성능을 향상시키고 있음을 보여준다.</p><p>T5는 실험 연구의 통찰력과 큰 규모를 결합하여 강력한 성능을 보여준다. baseline 모델의 사전 훈련량 또는 크기를 증가시키면 상당한 향상이 있었고, 이를 바탕으로 T5의 성능 향상에 얼마나 기여했는지 측정하고자 하였다. 이를 위해 표준 baseline 모델, 1 trillion 토큰으로 훈련된 모델 및 T5-Base를 비교하는 실험을 수행하였다. 이 두 모델의 성능 비교를 통해, 체계적인 연구에서 얻은 통찰력이 어떤 영향을 미쳤는지 구체적으로 측정할 수 있다.</p><p><img src=/p/t5/images/table15.png width=942 height=176 srcset="/p/t5/images/table15_hu3181bf2f435ab289c1044f5a8f3acab4_38762_480x0_resize_box_3.png 480w, /p/t5/images/table15_hu3181bf2f435ab289c1044f5a8f3acab4_38762_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=535 data-flex-basis=1284px></p><p>세 가지 모델 구성의 성능은 T5-Base가 모든 downstream task에서 baseline-1T을 월등히 능가함을 보여준다. 이는 T5의 성공에 크기 뿐만 아니라 다른 비확장 요소들도 기여하고 있음을 나타낸다. 추가적인 사전 학습은 모델의 성능을 향상시키는 데 도움이 된다.</p><hr><h2 id=reflection>Reflection</h2><p>이 분야의 더 나은 발전을 위해 효과적인 접근법을 제안하고자 한다.</p><h3 id=takeaways>Takeaways</h3><p><strong>Text-to-text</strong> Text-to-text 프레임워크는 다양한 텍스트 작업에 대해 단일 모델을 훈련시키는 간단한 방법을 제공한다. 이 방법은 생성, 분류, 회귀 작업 등에 성공적으로 적용될 수 있다. 간결함에도 불구하고, 이 프레임워크는 과제별 구조와 비교할 만한 성능을 보여주고, 규모와 결합하면 state-of-the-art를 달성한다.</p><p><strong>Architectures</strong> NLP의 전이 학습에서 Transformer의 구조적 변형을 고려했지만, 원래의 encoder-decoder 형태가 text-to-text 프레임워크에서 가장 효과적이었다. encoder-decoder 모델은 더 많은 parameter를 사용하지만, 계산 비용은 비슷하다. encoder와 decoder에서 parameter를 공유하면 전체 parameter 수가 절반으로 줄어들지만 성능 저하는 별로 없다.</p><p><strong>Unsupervised objectives</strong> 대부분의 &ldquo;denoising&rdquo; 목표, 즉 임의로 손상된 텍스트를 재구성하는 학습은 text-to-text 설정에서 비슷한 성능을 보였다. 따라서, 계산 효율성을 위해 짧은 대상 시퀀스를 생성하는 목표를 사용하는 것이 좋다.</p><p><strong>Data sets</strong> Common Crawl 웹 덤프에서 정리한 &ldquo;Colossal Clean Crawled Corpus (C4)&ldquo;를 소개하였다. 레이블이 없는 데이터로 학습하면 몇몇 downstream task에서 성능이 향상될 수 있지만, 데이터셋 크기가 줄어들 수 있다. 레이블이 없는 데이터셋이 작아서 여러 번 반복되면 성능이 저하될 수 있으므로, 크고 다양한 데이터셋인 C4의 사용이 중요하다는 것을 보여주었다.</p><p><strong>Training strategies</strong> 사전 학습된 모델의 모든 parameter를 미세 조정하는 방식이 비록 비용이 많이 들지만 더 우수한 성능을 보여주었다. 여러 작업을 동시에 학습하는 방법을 시도했지만, 특정 작업에 대한 학습 비율을 설정하는 전략을 찾지 못하였다. 하지만, 여러 작업의 혼합에서 사전 학습 후 미세 조정하는 것이 비지도 사전 학습과 비슷한 성능을 보여주었다.</p><p><strong>Scaling</strong> 추가 계산을 활용하는 다양한 전략을 비교한 결과, 각 방법이 성능을 크게 향상시켰으나, 더 많은 데이터로 작은 모델을 학습하는 것이 종종 더 적은 단계로 큰 모델을 학습하는 것보다 성능이 떨어졌다. 그러나 모델의 앙상블은 단일 모델보다 더 좋은 결과를 제공하였고, 같은 baseline 모델에서 미세 조정한 앙상블은 모든 모델을 별도로 학습하는 것보다는 성능이 떨어졌지만, 단일 모델보다는 훨씬 더 우수하였다.</p><p><strong>Pushing the limits</strong> state-of-the-art를 얻기 위해 큰 모델(최대 11B 개의 parameter)을 학습시켰다. 이를 위해 C4 데이터 세트에서 텍스트를 추출하고, 노이즈를 제거하는 목표를 적용하였다. 또한, 1 trillion 이상의 토큰에 대해 학습을 진행하였고, 결과를 쉽게 복제하고 확장하고 적용하기 위해 우리의 코드, C4 데이터 세트, 그리고 각 T5 변형에 대한 사전 학습된 모델 가중치를 공개하였다.</p><h3 id=outlook>Outlook</h3><p><strong>The inconvenience of large models</strong> 큰 모델이 더 좋은 성능을 내는 경향이 있다는 것이 중요한 결과로 나타났다. 하지만 client-side inference이나 federated learning과 같이 작은 모델이 도움이 되는 경우도 있다. low-resource 작업에서 좋은 성능을 얻는 것이 전이 학습의 한 가지 유익한 사용처이다. 따라서 저렴한 모델로 더 강한 성능을 달성하는 방법에 대한 연구를 지지한다. 이런 연구로는 distillation, parameter sharing, 그리고 conditional computation이 있다.</p><p><strong>More efficient knowledge extraction</strong> 사전 학습의 목표는 모델에 &ldquo;knowledge"를 제공하여 downstream task의 성능을 향상시키는 것이다. 현재 일반적으로 사용되는 방법은 텍스트의 오염된 부분을 복원하도록 학습시키는 것인데, 이 방법이 모델에 일반 지식을 가르치는 가장 효율적인 방법이 아닐 수도 있다. 더 효율적인 방법으로는, 실제 텍스트와 기계 생성 텍스트를 구분하도록 모델을 사전 학습시키는 방법이 있다.</p><p><strong>Formalizing the similarity between tasks</strong> 도메인 데이터에 대한 사전 학습이 downstream task의 성능을 향상시키는 것을 확인하였다. 레이블이 없는 데이터 소스를 선택하는 데에 더 원칙적인 접근을 가능하게 하기 위해, 사전 학습과 downstream task 사이의 &ldquo;similarity"에 대한 엄밀한 개념을 정립하는 것이 필요하다. 이는 컴퓨터 비전 분야에서 이미 일부 연구가 이루어지고 있다. 또한, 작업 간의 관련성에 대한 더 나은 이해는 지도 사전 학습 작업을 선택하는 데에도 도움이 될 수 있다.</p><p><strong>Language-agnostic models</strong> 영어로만 사전 학습한 결과가 번역 작업에서 최고 수준의 성과를 내지 못하였다. 이를 해결하기 위해, 어떤 언어의 텍스트든 좋은 성능으로 NLP 작업을 수행할 수 있는 언어에 구애받지 않는 모델을 더 연구하려고 한다. 이는 세계 인구 대다수의 모국어가 영어가 아닌 점을 고려하면 매우 중요한 이슈이다.</p><p>이 논문은 최근 NLP에 대한 전이 학습에 대해 연구하였다. 이 연구가 시작되기 전, 학습 기반 방법이 효율성을 증명받지 못 한 상황에서 이러한 진보가 돌파구를 만들어 주었으며, 특히 전이 학습에 어려운 SuperGLUE 벤치마크에서 거의 인간 수준의 성능을 달성하였다. 이 결과는 우리의 text-to-text 프레임워크, 새로운 C4 데이터셋, 그리고 체계적인 연구에서의 통찰력의 결합에서 비롯된다.</p><hr><h2 id=reference>Reference</h2><ul><li><a class=link href=https://arxiv.org/pdf/1910.10683.pdf target=_blank rel=noopener>Paper</a></li><li><a class=link href=https://github.com/google-research/text-to-text-transfer-transformer target=_blank rel=noopener>Github</a></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/nlp/>NLP</a>
<a href=/tags/llm/>LLM</a></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>관련 글</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/palm-2/><div class=article-details><h2 class=article-title>PaLM 2</h2></div></a></article><article><a href=/p/dromedary/><div class=article-details><h2 class=article-title>Dromedary</h2></div></a></article><article><a href=/p/pythia/><div class=article-details><h2 class=article-title>Pythia</h2></div></a></article><article><a href=/p/gpt-4/><div class=article-details><h2 class=article-title>GPT-4</h2></div></a></article><article><a href=/p/palm-e/><div class=article-details><h2 class=article-title>PaLM-E</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=KurtKim/kurtkim.github.io issue-term=pathname crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2024 K2H'log</section><section class=powerby><a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>로 만듦<br><a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>의 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.17.0>Stack</a></b> 테마 사용 중</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"}),MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}})</script></body></html>