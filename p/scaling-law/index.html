<!doctype html><html lang=ko-kr dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='Scaling Laws for Neural Language Models'><title>Scaling Law</title>
<link rel=canonical href=https://kurtkim.github.io/p/scaling-law/><link rel=stylesheet href=/scss/style.min.ff300df33b80e2ac49809c825614392ed1c7b27591d65d3c4043602cd162e25f.css><meta property='og:title' content='Scaling Law'><meta property='og:description' content='Scaling Laws for Neural Language Models'><meta property='og:url' content='https://kurtkim.github.io/p/scaling-law/'><meta property='og:site_name' content="K2H'log"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='NLP'><meta property='article:tag' content='LLM'><meta property='article:published_time' content='2023-12-22T00:00:00+00:00'><meta property='article:modified_time' content='2023-12-22T00:00:00+00:00'><meta name=twitter:title content="Scaling Law"><meta name=twitter:description content="Scaling Laws for Neural Language Models"><link rel="shortcut icon" href=favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="메뉴 여닫기">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/k2h_hud72815e7fea33e555ee8ed75e79e7624_40760_300x0_resize_q75_box.jpg width=300 height=306 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>K2H'log</a></h1><h2 class=site-description>넓고 얕은 지식을 위한</h2></div></header><ol class=social-menu><li><a href=https://github.com/kurtkim/ target=_blank title=1 rel=me><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li><a href=https://www.linkedin.com/in/kyeong-hun-kim-430ba075/ target=_blank title=2 rel=me><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li><li><a href=https://www.instagram.com/kurt_k2h/ target=_blank title=3 rel=me><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/></svg></a></li><li><a href=https://brunch.co.kr/@bigevlt target=_blank title=4 rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-pencil-minus" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 20h4L18.5 9.5a2.828 2.828.0 10-4-4L4 16v4"/><path d="M13.5 6.5l4 4"/><path d="M16 19h6"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://kurtkim.github.io/ selected></option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>다크 모드</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">목차</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#abstract>Abstract</a></li><li><a href=#introduction>Introduction</a><ol><li><a href=#summary>Summary</a></li><li><a href=#summary-of-scaling-laws>Summary of Scaling Laws</a></li><li><a href=#notation>Notation</a></li></ol></li><li><a href=#background-and-methods>Background and Methods</a><ol><li><a href=#parameter-and-compute-scaling-of-transformers>Parameter and Compute Scaling of Transformers</a></li><li><a href=#training-procedures>Training Procedures</a></li><li><a href=#datasets>Datasets</a></li></ol></li><li><a href=#empirical-results-and-basic-power-laws>Empirical Results and Basic Power Laws</a><ol><li><a href=#approximate-transformer-shape-and-hyperparameter-independence>Approximate Transformer Shape and Hyperparameter Independence</a></li><li><a href=#performance-with-non-embedding-parameter-count-n>Performance with Non-Embedding Parameter Count $N$</a></li><li><a href=#comparing-to-lstms-and-universal-transformers>Comparing to LSTMs and Universal Transformers</a></li><li><a href=#generalization-among-data-distributions>Generalization Among Data Distributions</a></li><li><a href=#performance-with-dataset-size-and-compute>Performance with Dataset Size and Compute</a></li></ol></li><li><a href=#charting-the-inﬁnite-data-limit-and-overﬁtting>Charting the Inﬁnite Data Limit and Overﬁtting</a><ol><li><a href=#proposed-ln-d-equation>Proposed $L(N, D)$ Equation</a></li><li><a href=#results>Results</a></li></ol></li><li><a href=#scaling-laws-with-model-size-and-training-time>Scaling Laws with Model Size and Training Time</a><ol><li><a href=#adjustment-for-training-at-b_critl>Adjustment for Training at $B_{crit}(L)$</a></li><li><a href=#results-for-ln-s-min-and-performance-with-model-size-and-compute>Results for $L(N, S min)$ and Performance with Model Size and Compute</a></li><li><a href=#lower-bound-on-early-stopping-step>Lower Bound on Early Stopping Step</a></li></ol></li><li><a href=#optimal-allocation-of-the-compute-budget>Optimal Allocation of the Compute Budget</a><ol><li><a href=#optimal-performance-and-allocations>Optimal Performance and Allocations</a></li><li><a href=#predictions-from-ln-s_min>Predictions from $L(N, S_{min})$</a></li><li><a href=#contradictions-and-a-conjecture>Contradictions and a Conjecture</a></li></ol></li><li><a href=#related-work>Related Work</a></li><li><a href=#discussion>Discussion</a></li><li><a href=#reference>Reference</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/paper-review/>Paper Review</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/scaling-law/>Scaling Law</a></h2><h3 class=article-subtitle>Scaling Laws for Neural Language Models</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Dec 22, 2023</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>20 분 정도</time></div></footer></div></header><section class=article-content><h2 id=abstract>Abstract</h2><p>언어 모델 성능에 대한 연구에서, 모델 크기, 데이터셋 크기, 학습에 사용된 컴퓨팅 양이 교차 엔트로피 손실을 멱법칙으로 스케일링한다는 것을 발견하였다. 네트워크의 폭이나 깊이 같은 다른 세부 사항은 큰 영향을 미치지 않는다. 큰 모델은 표본 효율이 뛰어나며, 최적의 컴퓨팅 효율은 상대적으로 적은 데이터에 큰 모델을 학습시키는 것을 포함한다. 이 모든 관계를 통해, 고정된 컴퓨팅 예산의 최적 할당을 결정할 수 있다.</p><hr><h2 id=introduction>Introduction</h2><p>언어는 인공지능 연구에 중요한 분야로, 대부분의 추론 작업을 효과적으로 수행할 수 있다. 세계의 텍스트는 비지도 학습을 위한 풍부한 데이터를 제공하며, 최근 딥러닝은 언어 모델링에 있어 빠른 발전을 보이고 있다. state-of-the-art 모델들은 많은 특정 작업에서 인간 수준의 성능에 근접하고 있으며, 이는 일관된 멀티패러그래프 작성에도 해당된다.</p><p>언어 모델링 성능은 모델 구조, 모델 크기, 학습에 사용된 컴퓨팅 파워, 학습 데이터의 양 등 여러 요소에 의존하며, 이 연구에서는 이러한 요소들이 언어 모델링 손실에 어떻게 영향을 미치는지를 transformer 구조를 중심으로 실증적으로 조사한다. 언어 작업의 성능 범위가 넓어서, 규모에 따른 추세를 좀 더 광범위하게 연구할 수 있다.</p><p>교육 시간, 문맥 길이, 데이터셋 크기, 모델 크기 등의 여러 요인에 따른 성능 변화를 관찰할 예정이다.</p><h3 id=summary>Summary</h3><p>Transformer 언어 모델에 대한 주요 발견은 다음과 같다:</p><p><img src=/p/scaling-law/images/figure1.png width=1192 height=374 srcset="/p/scaling-law/images/figure1_hu424f1e66fa0f691b27459c26f82b23e8_111743_480x0_resize_box_3.png 480w, /p/scaling-law/images/figure1_hu424f1e66fa0f691b27459c26f82b23e8_111743_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=318 data-flex-basis=764px></p><p><strong>Performance depends strongly on scale, weakly on model shape:</strong> 모델의 성능은 주로 모델 매개변수의 수, 데이터셋 크기, 그리고 사용된 컴퓨팅의 양에 의존하며, 다른 구조적 요소들은 성능에 상대적으로 적은 영향을 미친다.</p><p><strong>Smooth power laws:</strong> $N$, $D$, $C$ 세 가지 스케일 요인이 파워와 관련이 있고, 이는 6배 이상의 크기 차이를 보인다. 상위 범위에서는 성능 향상의 감소를 보지 못했지만, 최종적으로는 성능이 안정화되어 손실이 0에 다다를 것이다.</p><p><strong>Universality of overfitting:</strong> $N$과 $D$를 동시에 확장하면 성능이 예상대로 개선되지만, 둘 중 하나만 증가시키면 손실이 줄어든다. 성능 손실은 $N$과 $D$의 비율에 따라 예측 가능하며, 모델 크기를 8배 증가할 때마다 데이터를 약 5배 증가시키면 손실을 피할 수 있다.</p><p><strong>Universality of training:</strong> 학습 곡선은 모델 크기에 거의 영향을 받지 않는 power-law를 따르며, 이를 통해 학습 초기부의 곡선을 확장해 더 오래 학습했을 때의 손실을 대략적으로 예측할 수 있다.</p><p><strong>Transfer improves with test performance:</strong> 다른 분포의 텍스트에서 모델을 평가하면, 학습 검증 세트의 결과와 강하게 상관되며 일정한 손실이 발생한다. 이는 다른 분포로 전이할 때 일정한 패널티가 있지만, 그 외의 성능 향상은 학습 세트에서와 비슷하게 이루어진다.</p><p><strong>Sample efﬁciency:</strong> 큰 모델은 작은 모델에 비해 최적화 단계와 데이터 포인트를 더 적게 사용하면서도 동일한 성능을 달성하는 샘플 효율성이 더 높다.</p><p><strong>Convergence is inefﬁcient:</strong> 고정된 컴퓨팅 예산 내에서, 모델 크기나 사용 가능한 데이터에 제한이 없다면, 매우 큰 모델을 학습시키고 조기에 중단함으로써 최적의 성능을 얻는다. 이런 방식은 작은 모델을 완전히 수렴시키는 것보다 샘플 효율성이 훨씬 높으며, 데이터 요구사항은 학습 컴퓨팅에 따라 매우 천천히 증가한다.</p><p><strong>Optimal batch size:</strong> 이 모델들을 학습시키는 이상적인 batch size는 손실의 거듭제곱 정도이며, 가장 큰 모델의 경우 수렴 시점에서 약 1M-2M 토큰이다.</p><p>모델 크기, 데이터, 컴퓨팅을 적절히 확장할수록 언어 모델링 성능이 부드럽게 향상되며, 더 큰 언어 모델이 현재의 모델보다 성능과 샘플 효율성이 더 높을 것으로 예상한다.</p><p><img src=/p/scaling-law/images/figure2.png width=1178 height=498 srcset="/p/scaling-law/images/figure2_hu71d1ba25a4227ce03b793399f1ff538c_219021_480x0_resize_box_3.png 480w, /p/scaling-law/images/figure2_hu71d1ba25a4227ce03b793399f1ff538c_219021_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=236 data-flex-basis=567px></p><p><img src=/p/scaling-law/images/figure3.png width=860 height=400 srcset="/p/scaling-law/images/figure3_hu0e8d390dfed7ece089f591eac5187753_82828_480x0_resize_box_3.png 480w, /p/scaling-law/images/figure3_hu0e8d390dfed7ece089f591eac5187753_82828_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=215 data-flex-basis=516px></p><h3 id=summary-of-scaling-laws>Summary of Scaling Laws</h3><p>Transformer가 언어를 자동 autoregressively하게 모델링하도록 학습된 경우, 테스트 손실은 parameter의 수 $N$, 데이터셋 크기 $D$, 또는 컴퓨팅 예산으 $C_{min}$로만 제한될 때 거듭제곱 법칙을 사용하여 예측할 수 있다.</p><ol><li>parameter의 수가 제한된 모델들이 충분히 큰 데이터셋에서 수렴할 때까지 학습된 경우:</li></ol><p>$$ L(N) = (N)c / N)^{\alpha_N}; \ \alpha_N \sim 0.076, \ N_c \sim 8.8 \times 10^{13} (\text{non-embedding parameters}) $$</p><ol start=2><li>parameter 수가 제한된 모델들은 충분히 큰 데이터셋에서 수렴할 때까지 학습된다.</li></ol><p>$$ L(D) = (D_c / D)^{\alpha_D}; \ \alpha_D \sim 0.095, \ D_c \sim 5.4 \times 10^{13}(\text{tokens}) $$</p><ol start=3><li>컴퓨팅 양이 제한된 상황에서 충분히 큰 데이터셋, 최적 크기의 모델, 그리고 충분히 작은 batch size를 사용하여 학습할 때:</li></ol><p>$$ L(C_{min} = (C_c^{min} / C_{min})^{\alpha_C^{min}}; \ \alpha_C^{min} \sim 0.050, \alpha_C^{min} \sim 3.1 \times 10^8 (\text{PF-days})$$</p><p><img src=/p/scaling-law/images/figure4.png width=1136 height=330 srcset="/p/scaling-law/images/figure4_hue340d1e50bcaf9eea1845a866fa76a74_143167_480x0_resize_box_3.png 480w, /p/scaling-law/images/figure4_hue340d1e50bcaf9eea1845a866fa76a74_143167_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=344 data-flex-basis=826px></p><p>이 관계는 $C_{min}$, $N$, $D$의 크기 순서에 대해 유지되며, 이는 모델 형태와 transformer의 다른 hyperparameter에 매우 약하게 의존한다. 거듭제곱 법칙은 $N$, $D$, $C_{min}$의 확장에 따른 성능 향상의 정도를 지정하며, parameter의 수를 두 배로 늘리면 손실이 약간 줄어드다. $N_c$, $C_c^{min}$, $D_c$의 정확한 수치 값은 어휘 크기와 토큰화에 따라 달라진다.</p><p>데이터 병렬성의 속도와 효율성을 결정하는 중요한 batch size는 $L$에 대해 거듭제곱 법칙을 따른다:</p><p>$$ B_{crit}(L) = {{B_{\ast}}\over{L^{1/\alpha_B}}}, \ B_{\ast} \sim 2 \cdot 10^8 \text{tokens}, \ \alpha_B \sim 0.21 $$</p><p>모델 크기를 증가시킬 때, 데이터셋 크기도 $D \propto N^{{\alpha N}\over{\alpha D}} \sim N^{0.74}$에 따라 선형적으로 증가해야 한다는 것을 알 수 있다. 이는 $N$과 $D$에 대한 동시적인 의존성과 과적합 정도를 결정하는 식으로 결합된다.</p><p>$$ L(N, D) = \big[ \big( {{N_c}\over{N}} \big)^{{\alpha N}\over{\alpha D}} + {{D_c}\over{D}} \big] $$</p><p>다른 생성 모델링 작업에 대한 학습된 log-likelihood를 parameter화 할 수도 있다고 추측한다.</p><p>무한한 데이터 한도에서 모델을 일정한 업데이트 단계동안 학습시키면, 초기 변동기간 후에 학습 곡선은 정확하게 맞출 수 있다.</p><p>$$ L(N, S) = \big( {{N_c}\over{N}} \big)^{{\alpha N}\over{\alpha D}} + \big( {{S_c}\over{S_{min}(S)}} \big)^{\alpha S}$$</p><p>$S_c \approx 2.1 \times 10^3$, $\alpha_S \approx 0.76$이고, $S_{min} (S)$는 최적화 단계(parameter 업데이트)의 최소 가능 수를 나타낸다.</p><p>고정된 컴퓨팅 예산 내에서, 다른 제약 없이 학습시킬 때, 최적의 모델 크기, 배치 크기, 스텝 수, 데이터셋 크기가 성장해야 한다는 예측이 나온다.</p><p>$$ N \propto C^{\alpha_C^{min} / \alpha N}, B \propto C^{\alpha_C^{min} / \alpha B}, S \propto C^{\alpha_C^{min} / \alpha S}, D = B \cdot S $$</p><p>$$ \alpha_C^{min} = 1/ (1/\alpha S + 1 / \alpha B + 1 / \alpha N) $$</p><p>계산 예산 $C$가 증가함에 따라, 주로 큰 모델에 투자가 증가하고, 이로 인해 학습 시간이나 데이터셋 크기는 크게 증가하지 않는다. 이는 큰 모델이 표본 효율성이 더 높아진다는 것을 의미한다. 하드웨어 제약으로 인해 연구자들은 일반적으로 작은 모델을 더 오래 학습시킨다. 최적 성능은 총 컴퓨팅 파워에 의존적이다.</p><p>토큰 당 결과를 분석하며, LSTM과 recurrent Transformer에 대해 간단히 비교한다.</p><h3 id=notation>Notation</h3><ul><li><strong>$L$</strong> cross entropy 손실은 보통 내츄럴 로그로 표현된다. 대체로 이는 컨텍스트 내의 토큰들에 대해 평균된 값으로 보고되지만, 경우에 따라 컨텍스트 내의 특정 토큰에 대한 손실을 보고하는 경우도 있다.</li><li><strong>$N$</strong> vocabulary와 positional embedding을 제외한 모델 parameter 수를 의미한다.</li><li><strong>$C \approx 6NBS$</strong> $B$는 batch size, $S$는 training step 수를 나타내며, non-embedding 학습 계산의 총량을 추정하는데 사용된다. 이 계산량은 PF-day 단위로 표현되며, 1PF-day는 약 $8.64 \times 10^{19}$의 부동소수점 연산에 해당한다.</li><li><strong>$D$</strong> 토큰 단위의 데이터셋 크기</li><li><strong>$B_{crit}$</strong> 중요 배치 크기에서의 학습은 시간과 계산 효율성 사이에서 대략적으로 최적의 균형을 제공한다.</li><li><strong>$C_{min}$</strong> 주어진 손실 값을 달성하기 위해 필요한 최소한의 non-embedding 계산량을 추정한 것으로, 이런 계산량은 모델이 중요 배치 크기보다 작은 배치 크기에서 학습될 때 사용된다.</li><li><strong>$S_{min}$</strong> 주어진 손실 값을 달성하기 위해 필요한 최소 학습 step 수를 추정한 것으로, 이는 모델이 중요 배치 크기보다 큰 배치 크기에서 학습될 때의 학습 step 수 이다.</li><li><strong>$\alpha_X$</strong> 손실 $L(X)$는 $1/X^{\alpha X}$의 형태로 $X$의 거듭제곱에 반비례하며, 여기서 $X$는 $N$, $D$, $C$, $S$, $B$, $C_{min}$ 중 하나이다. 즉, $X$가 커지면 손실은 줄어든다.</li></ul><hr><h2 id=background-and-methods>Background and Methods</h2><p>WebText2라는 확장된 데이터셋을 사용해 언어 모델을 학습한다. 이 모델은 $n_{vocab} = 50257$ 크기의 어휘로 토큰화되며, 1024 토큰 컨텍스트에 대한 cross-entropy 손실을 최적화한다. 주로 decoder-only transformer 모델을 학습시키지만, 비교를 위해 LSTM 모델과 Universal Transformers도 학습시킨다.</p><h3 id=parameter-and-compute-scaling-of-transformers>Parameter and Compute Scaling of Transformers</h3><p>Transformer 아키텍처는 $n_{layer}$(number of layers), $d_{model}$(dimension of the residual stream), $d_ff$(dimension of the intermediate feed-forward layer), $d_{attn}$(dimension of the attention output), 그리고 $n_{heads}$(number of attention heads per layer) 등의 hyperparameter를 사용해 정의된다. 입력 컨텍스트는 대체로 $n_{ctx} = 1024$개의 토큰을 포함한다.</p><p>$$ N \approx 2 d_{model} \ n_{layer} (2 d_{attn} + d_{ff} ) = 12 n_{layer} \ d_{model} $$
$$ \text{with the standard} \ \ d_{attn} = d_{ff} / 4 = d_{model} $$</p><p>embedding matrix $n_{vocab} \ d_{model}$과 positional embedding $n_{ctx} \ d_{model}$에 대한 parameter를 가지고 있지만, &ldquo;모델 크기"를 논의할 때는 이들을 포함하지 않는다. 이 방식은 더욱 깔끔한 스케일링 법칙을 제공한다.</p><p>transformer의 forward pass를 평가하는 것은 다음과 같은 과정을 포함한다.</p><p>$$ C_{forward} \approx 2N + 2 n_{layer} \ n_{ctx} \ d_{model} $$</p><p>add-multiply 연산을 포함하며, 이 중 2배에 해당하는 부분은 행렬 곱셈에 사용되는 multiply-accumulate 연산에서 나온다.</p><p><img src=/p/scaling-law/images/table1.png width=1118 height=392 srcset="/p/scaling-law/images/table1_hu6d2fe3b17d28befb176c467c034373b0_78373_480x0_resize_box_3.png 480w, /p/scaling-law/images/table1_hu6d2fe3b17d28befb176c467c034373b0_78373_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=285 data-flex-basis=684px></p><p>$d_{model}$이 $n_{ctx} / 12$보다 훨씬 큰 모델에서, 토큰 당 컨텍스트 종속적인 계산 비용은 전체 계산의 작은 부분이다. 따라서 학습 계산 추정에는 컨텍스트 종속적인 부분은 포함되지 않는다. backwards pass 고려 시, 학습 토큰 당 비임베딩 계산은 대략 $C \approx 6N$ non-embedding 연산자로 추정된다.</p><h3 id=training-procedures>Training Procedures</h3><p>1024개의 토큰으로 이루어진 512개의 시퀀스 배치를 사용하여 $2.5 \times 10^5$ 단계 동안 모델을 Adam optimizer 도구로 학습시켰다. 메모리 제약으로 인해, 1B 개 이상의 parameter를 가진 가장 큰 모델들은 Adafactor로 훈련되었다. 다양한 learning rate와 스케줄을 실험했으며, 결과는 learning rate 스케줄에 크게 의존하지 않았다. 대부분의 학습은 3000 step의 linear warmup 후 0까지의 cosine decay를 따르는 learning rate 스케줄을 사용하였다.</p><h3 id=datasets>Datasets</h3><p>Reddit의 공유 링크를 웹 스크랩한 WebText 데이터셋의 확장 버전에서 모델을 학습시켰다. 이 데이터셋은 2017년 12월까지의 링크와 2018년 1월부터 10월까지의 링크를 포함하며, 각 링크는 최소 3 카르마를 받았다. 이 데이터셋은 총 20.3M의 문서와 96GB의 텍스트, $1.62 \times 10^{10}$ 단어를 포함하며, 가역적 토크나이저를 적용하여 $2.29 \times 10^{10}$ 토큰을 얻었다. 이 중 일부 토큰은 테스트 셋으로 사용되었고, 추가적으로 다양한 소스의 샘플에 대해서도 테스트를 진행하였다.</p><hr><h2 id=empirical-results-and-basic-power-laws>Empirical Results and Basic Power Laws</h2><p>언어 모델 스케일링을 특성화하기 위해 다음과 같은 요소를 포함한 다양한 모델을 학습시킨다:</p><ul><li>Model size (ranging in size from 768 to 1.5 billion non-embedding parameters)</li><li>Dataset size (ranging from 22 million to 23 billion tokens)</li><li>Shape (including depth, width, attention heads, and feed-forward dimension)</li><li>Context length (1024 for most runs, though we also experiment with shorter contexts)</li><li>Batch size (2 19 for most runs, but we also vary it to measure the critical batch size)</li></ul><h3 id=approximate-transformer-shape-and-hyperparameter-independence>Approximate Transformer Shape and Hyperparameter Independence</h3><p><img src=/p/scaling-law/images/figure5.png width=1176 height=320 srcset="/p/scaling-law/images/figure5_hu5f813134cf4d44c6d9bbeaffd912cc72_92250_480x0_resize_box_3.png 480w, /p/scaling-law/images/figure5_hu5f813134cf4d44c6d9bbeaffd912cc72_92250_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=367 data-flex-basis=882px></p><p>Transformer의 성능은 전체 non-embedding parameter 수 $N$이 고정되어 있을 때, $n_{layer}$, $n_{heads}$, $d_{ff}$와 같은 shape parameter에 대해 매우 약하게 의존한다. 이를 확인하기 위해, 단일 hyperparameter를 변경하면서 동일한 크기의 모델을 학습시켰다. 깊은 Transformer가 얕은 모델의 앙상블처럼 효과적으로 작동한다면, $n_{layers}$의 독립성이 이어질 것이다.</p><h3 id=performance-with-non-embedding-parameter-count-n>Performance with Non-Embedding Parameter Count $N$</h3><p><img src=/p/scaling-law/images/figure6.png width=1086 height=352 srcset="/p/scaling-law/images/figure6_huf01da79a101781de139f218c134e40cf_93600_480x0_resize_box_3.png 480w, /p/scaling-law/images/figure6_huf01da79a101781de139f218c134e40cf_93600_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=308 data-flex-basis=740px></p><p>모델은 전체 WebText2 데이터셋에서 거의 수렴할 때까지 학습되었으며, 과적합은 가장 큰 모델들을 제외하고는 발견되지 않았다.</p><p>non-embedding parameter 수 $N$과의 안정적인 추세를 찾을 수 있으며, 다음과 같이 표현할 수 있다:</p><p>$$ L(N) \approx \big( {{N_c}\over{N}} \big)^{\alpha_N} $$</p><p>$N$의 함수로서의 성능을 연구하는 것이 중요한데, 이를 통해 non-embedding parameter 수와 성능 사이의 추세를 관찰할 수 있다. 반면 총 매개변수 수를 사용하면 추세가 흐릿해진다. 이는 임베딩 행렬의 크기를 줄여도 성능에 영향을 미치지 않는다는 최근의 연구 결과를 지지한다.</p><p>WebText2 데이터셋에서 학습된 이 모델들의 테스트 손실은 다양한 다른 데이터셋에서도 $N$의 거듭제곱 법칙을 따르며, 지수는 거의 동일하다.</p><h3 id=comparing-to-lstms-and-universal-transformers>Comparing to LSTMs and Universal Transformers</h3><p><img src=/p/scaling-law/images/figure7.png width=1180 height=418 srcset="/p/scaling-law/images/figure7_hu4c644a57ba8d19afa54942e652117915_112387_480x0_resize_box_3.png 480w, /p/scaling-law/images/figure7_hu4c644a57ba8d19afa54942e652117915_112387_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=282 data-flex-basis=677px></p><p>LSTM은 문맥 초기에 나타나는 토큰에 대해 Transformer만큼 잘 수행하지만, 나중에 나타나는 토큰에서는 Transformer의 성능을 따라잡지 못하였다. 이는 더 큰 모델들이 패턴을 더 빠르게 인식하는 능력을 개선했다는 것을 나타낸다.</p><p>recurrent Transformer는 parameter를 재사용하여 $N$의 함수로서 약간 더 나은 성능을 보이지만, 이는 parameter 당 추가 계산 비용이 발생한다.</p><h3 id=generalization-among-data-distributions>Generalization Among Data Distributions</h3><p>추가 텍스트 데이터 분포에 대한 모델을 테스트하였다. 모든 모델은 WebText2 데이터셋에서만 학습되었으며, 이러한 다른 데이터 분포에서의 손실은 모델 크기에 따라 부드럽게 개선되었다. 일반화는 거의 전적으로 in-distribution 검증 손실에 의존하며, 학습 기간이나 수렴에 가까움, 모델 깊이에는 의존하지 않았다.</p><h3 id=performance-with-dataset-size-and-compute>Performance with Dataset Size and Compute</h3><p>데이터셋 크기 $D$와 학습 계산 $C$의 함수로서의 테스트 손실에 대한 경험적 추세를 보여준다.</p><p>WebText2 데이터셋의 일부에서 모델을 학습시키고 테스트 손실이 더 이상 감소하지 않을 때 학습을 중단하였다. 이 결과, 테스트 손실은 단순한 거듭제곱 법칙으로 표현될 수 있었다.</p><p>$$ L(D) \approx \big( {{D_c}\over{D}} \big)^{\alpha_D} $$</p><p>학습 중 non-embedding 계산의 총량은 $C = 6NBS$로 추정된다. 주어진 $C$ 값에 대해, 다양한 $N$을 가진 모든 모델을 검토하여 최상의 성능을 내는 모을 찾을 수 있다. 하지만, 모든 모델에 대해 batch size $B$가 고정되어 있기 때문에, 이 결과는 실제로 최적이 아니다.</p><p>결과는 다음과 같이 표현될 수 있다:</p><p>$$ L(C) \approx \big( {{C_c}\over{C}} \big)^{\alpha_C} $$</p><p>데이터 분석 결과, 모델 크기가 커질수록 샘플 효율성이 향상되는 것을 확인할 수 있다.</p><hr><h2 id=charting-the-inﬁnite-data-limit-and-overﬁtting>Charting the Inﬁnite Data Limit and Overﬁtting</h2><p>언어 모델링 성능의 기본적인 스케일링 법칙을 발견하였다. 여기서는 $N$과 $D$를 동시에 변화시키며, $D$ 토큰의 데이터셋에서 학습된 크기 $N$의 모델 성능을 연구한다. 최적으로 학습된 테스트 손실이 스케일링 법칙을 따르며, 이는 모델 크기 증가와 과적합 통제를 위한 데이터 요구량을 안내한다.</p><h3 id=proposed-ln-d-equation>Proposed $L(N, D)$ Equation</h3><p>$$ L(N, D) = \big[ \big( {{N_c}\over{N}} \big)^{{{\alpha N}\over{\alpha D}}} + {{D_c}\over{D}} \big]^{\alpha D} $$</p><p>다음 세가지 원칙을 사용한다:</p><ol><li>어휘 크기나 토큰화의 변화는 전반적인 요소에 의해 손실을 재조정할 것으로 예상된ㄴ다. $L(N, D)$의 parameterization(및 손실의 모든 모델)는 이러한 재조정을 자연스럽게 허용해야 한다.</li><li>$D$를 고정하고 $N$을 무한대로 보내면, 전체 손실은 $L(D)$에 접근해야 한다. 반대로, $N$을 고정하고 $D$를 무한대로 보내면 손실은 $L(N)$에 접근해야 한다.</li><li>$L(N, D)$는 $D = \infty$에서 해석적이어야 하므로, 정수 제곱을 가진 $1/D$의 시리즈 확장을 가질 수 있다. 이 원칙에 대한 이론적 지지는 첫 두 원칙에 비해 상당히 약하다.</li></ol><p>$L(N, D)$는 어휘의 변화에 따라 $N_c$, $D_c$를 재조정할 수 있기 때문에 첫 번째 요구사항을 만족하다. 이는 또한 $N_c$, $D_c$의 값이 본질적인 의미를 가지지 않음을 의미한다.</p><p>테스트 손실이 개선되지 않을 때 학습을 조기에 중단하고, 모든 모델을 동일하게 최적화하기 때문에 큰 모델이 작은 모델보다 성능이 좋을 것으로 예상한다. 그러나 고정된 $D$에서는 어떤 모델도 최선의 손실에 접근할 수 없으며, 고정된 크기의 모델은 용량에 제한된다. 이러한 고려사항은 두 번째 원칙을 동기부여하며, 무한한 $D$와 $N$에서의 $L$ 값은 $L(N, D)$의 모든 parameter를 결정한다.</p><p>세 번째 원칙은 추측적으로, 매우 큰 $D$에서 과적합이 $1/D$로 스케일링될 것으로 예상한ㄴ다. 이는 데이터셋의 분산 또는 신호 대 잡음 비율과 관련이 있다. 이 기대는 모든 부드러운 손실 함수에서 성립해야 하지만, 이는 $1/D$ 보정이 다른 분산 원처보다 우세하다고 가정한다. 이 가정은 경험적으로 확인되지 않아 그 적용 가능성에 대한 확신이 떨어진다.</p><p>세 번째 원칙은 $N$과 $D$의 역할의 비대칭성을 설명한다. 유사한 대칭 표현식이 가능하지만, 이들은 정수 제곱의 $1/D$ 확장을 가지지 않고 추가 parameter가 필요하다.</p><p>$L(N, D)$에 대한 방정식이 데이터를 잘 맞추는 것을 볼 수 있을 것이며, 이것이 $L(N, D)$ 가정에 대한 가장 중요한 정당화이다.</p><h3 id=results>Results</h3><p><img src=/p/scaling-law/images/figure9.png width=1156 height=318 srcset="/p/scaling-law/images/figure9_hu3fe7a6eef047be355bc61d43f414b5c1_96177_480x0_resize_box_3.png 480w, /p/scaling-law/images/figure9_hu3fe7a6eef047be355bc61d43f414b5c1_96177_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=363 data-flex-basis=872px></p><p>모든 모델을 10%의 dropout으로 정규화하고, 테스트 손실을 추적하여 더 이상 감소하지 않을 때 중단한다.</p><p><img src=/p/scaling-law/images/table2.png width=648 height=124 srcset="/p/scaling-law/images/table2_huc2b6c23fdfb164c828d935d097786836_18116_480x0_resize_box_3.png 480w, /p/scaling-law/images/table2_huc2b6c23fdfb164c828d935d097786836_18116_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=522 data-flex-basis=1254px></p><p>데이터셋이 1024배로 크게 줄어든 경우를 제외하고는 우수한 적합성을 보였다. 작은 데이터셋에서는 한 epoch가 40번의 parameter 업데이트로 이루어지며, 이는 언어 모델링의 다른 체제를 나타낼 수 있다. 학습 초기에 과적합이 발생하고, 전체 $L(N, D)$를 적합시키므로 parameter가 Section 4에서 얻은 것과 약간 다르다.</p><p>무한 데이터 한계를 탐색하기 위해, 과적합의 범위를 직접 조사할 수 있다. 가장 큰 모델을 제외하고는 22B 토큰의 전체 WebText2 데이터셋으로 학습시 과적합의 증거가 없으므로, 이를 $D = \infty$의 대표로 볼 수 있다. 이를 바탕으로 유한 $D$를 무한 데이터 한계와 비교할 수 있다.</p><p>$$ δL(N, D) ≡ {{L(N, D)}\over{L(N, \infty)}} -1 $$</p><p>$N$과 $D$의 함수로서 $δL$을 연구한다. 실제로 $δL$이 $N$과 $D$의 특정 조합에만 의존하는 것을 경험적으로 확인할 수 있으며, 이는 스케일링 법칙에서 파생된다.</p><p>$$ δL \approx \big( 1 + \big( {{N}\over{N_c}} \big)^{{\alpha N}\over{\alpha D}} {{D_c}\over{D}} \big)^{\alpha D} -1 $$</p><p>large $D$에서 이 공식이 $1/D$의 제곱의 시리즈 확장을 가지고 있다.</p><p>다른 랜덤 시드로 손실의 변동성이 대략 0.02라는 것을 추정하며, 이는 수렴 임계값 내에서 학습 시 과적합을 피하기 위해 다음을 필요로 한다.</p><p>$$ D \geqslant (5 × 10^3) N^{0.74} $$</p><p>이 관계를 통해, $10^9$개 미만의 parameter를 가진 모델은 22B 토큰의 WebText2 데이터셋에서 최소한의 과적합으로 학습 가능하며, 가장 큰 모델은 약간의 과적합을 겪게 된다. 이 관계는 과적합을 피하면서 데이터셋 크기가 모델 크기에 비례하여 아래선형적으로 증가할 수 있음을 보여준다. 그러나 이것이 항상 최대 계산 효율적인 학습을 의미하는 것은 아니며, 데이터셋과 모델 크기 변화에 따른 정규화 최적화는 아직 이루어지지 않았다.</p><hr><h2 id=scaling-laws-with-model-size-and-training-time>Scaling Laws with Model Size and Training Time</h2><p>모델 크기와 학습 시간에 따른 손실 함수의 스케일링 법칙을 이해하는데 초점을 맞춥니다. 이를 위해 대부분의 모델에 적용할 수 있는 학습 단계를 정의하고, 이를 통해 손실의 모델 크기와 학습 시간 의존성을 적합시키는 방법을 설명합니다. 그리고 이 결과를 바탕으로 학습 시간과 모델 크기를 최적으로 분배하는 방법을 예측하고 검증한다.</p><h3 id=adjustment-for-training-at-b_critl>Adjustment for Training at $B_{crit}(L)$</h3><p>학습에는 critical batch size $B_{crit}$이 존재하며, 이 크기 이하에서는 batch size를 늘려도 컴퓨팅 효율성이 크게 저하되지 않는다. 그러나 $B_{crit}$보다 큰 경우에는 batch size 증가의 효과가 점차 감소한다. 이 결과는 batch size에 따른 학습 시간과 컴퓨팅 변화를 예측하는데 활용할 수 있다. 최적의 효율을 위해선 batch size가 $B_{crit}$에 가깝게 설정되어야 하며, 너무 크거나 작은 batch size는 각각 학습 step과 컴퓨팅 사용을 최소화한다.</p><p>더 구체적으로, 다양한 신경망 작업에 대해 학습 step 수 $S$와 처리된 데이터 예제의 수 $E = BS$는 간단한 관계를 만족시키는 것이 입증되었다.</p><p>$$ \big( {{S}\over{S_{min}}} - 1 \big) \big( {{E}\over{E_{min}}} - 1 \big) = 1 $$</p><p>이는 손실 $L$의 고정된 값에 도달하기 위한 학습을 진행할 때의 상황이다. 여기서 $S_{min}$은 $L$에 도달하기 위해 필요한 최소 단계 수이며, $E_{min}$은 처리해야 할 데이터 예제의 최소 수 이다.</p><p>다음 식은 critical batch size를 정의한다.</p><p>$$ B_{crit}(L) ≡ {{E_{min}}\over{S_{min}}} $$</p><p>이는 손실의 목표 값에 따라 변하는 함수이다. critical batch size에서 학습하면 시간/컴퓨팅의 트레이드오프가 대략적으로 최적화되며, 이는 $2S_{min}$의 학습 step을 필요로 하고 $E = 2E_{min}$의 데이터 예제를 처리한다.</p><p><img src=/p/scaling-law/images/figure10.png width=708 height=456 srcset="/p/scaling-law/images/figure10_hu9ae266059a93b3fe394d199397648cd6_104337_480x0_resize_box_3.png 480w, /p/scaling-law/images/figure10_hu9ae266059a93b3fe394d199397648cd6_104337_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=155 data-flex-basis=372px></p><p>학습 손실에 따른 critical batch size와 gradient noise scale을 보여준다. 이는 모델 크기와 무관하며 손실 $L$에만 의존합니다. 이로 인해 예측이 transformer 언어 모델에도 계속 적용된다. critical batch size는 손실의 power-law으로 적합될 수 있다.</p><p>$$ B_{crit}(L) \approx {{B_{*}}\over{L^{1/\alpha_B}}} $$</p><p>여기서 $B_{*}$는 약 $2 \times 10^8$이고, $\alpha_B$는 약 0.21이다.</p><p>손실이 최소값에 접근할 때 gradient noise scale이 발산할 것으로 예상되어, 이를 추적하도록 $B_{crit}$의 parameterization를 선택하였다. 자연 언어의 엔트로피가 0이 아니므로 $L_{min} > 0$이며, 이는 이 연구에서 달성한 $L$의 값보다 훨씬 작다. 그래서 $B_{crit}$이 $L$이 0으로 접근함에 따라 발산하는 parameterization를 사용하였다.</p><p>$B_{crit}(L)$을 사용하여 batch size $B = 2^19$ 토큰으로 학습하는 동안의 학습 step 수 $S$와 $B ≫ B_{crit}$에서 학습하는 동안의 학습 step 수 사이의 관계를 추정할 것이다. 이는 단순히 다음과 같다.</p><p>$$ S_{min}(S) ≡ {{S}\over{1 + B_{crit}(L) / B}}, (\text{minimum steps, at} B ≫ B_{crit} ) $$</p><p>이는 손실의 목표 값 $L$에 대한 것이다. 이것은 또한 $B ≪ B_{crit}(L)$에서 학습하면서 크기 $N$의 모델로 $L$까지 학습하는데 필요한 컴퓨팅의 critical value를 정의한다. 이는 다음과 같다.</p><p>$$ C_{min}(C) ≡ {{C}\over{1 + B / B_{crit}(L)}}, (\text{minimum compute, at} B ≪ B_{crit} ) $$</p><p>여기서 $C = 6NBS$는 batch size $B$에서 사용되는 (non-embedding) 컴퓨팅을 추정한다.</p><h3 id=results-for-ln-s-min-and-performance-with-model-size-and-compute>Results for $L(N, S min)$ and Performance with Model Size and Compute</h3><p>$S_{min}$을 활용하여, 무한 데이터 한계에서 모델 크기와 학습 시간에 따른 손실의 관계를 간단하게 적합시킨다. 이는 Adam-optimized 학습을 통해 이루어진다.</p><p>$$ L(N, S_{min}) = \big( {{N_c}\over{N}} \big)^{\alpha_N} + \big( {{S_c}\over{S_{min}}} \big)^{\alpha_S} $$</p><p>손실에 대해, learning rate schedule의 warmup period 이후의 모든 학습 단계를 포함하고, parameter를 사용하여 데이터에 적합성을 찾는다:</p><p><img src=/p/scaling-law/images/table3.png width=622 height=118 srcset="/p/scaling-law/images/table3_hu268d2742fb46d5db29d5defd96087964_16884_480x0_resize_box_3.png 480w, /p/scaling-law/images/table3_hu268d2742fb46d5db29d5defd96087964_16884_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=527 data-flex-basis=1265px></p><p>이러한 parameter들을 사용하면, 학습 곡선 적합성을 얻을 수 있다. 이 적합성들이 완벽하지는 않지만, 상당히 설득력 있는 것으로 생각된다.</p><p><img src=/p/scaling-law/images/figure11.png width=1156 height=368 srcset="/p/scaling-law/images/figure11_huaba6e09c37e9ed1cbd0b17fd6168d25c_144701_480x0_resize_box_3.png 480w, /p/scaling-law/images/figure11_huaba6e09c37e9ed1cbd0b17fd6168d25c_144701_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=314 data-flex-basis=753px></p><p>다른 방식으로 데이터와 적합성을 시각화할 수 있는데, 이는 학습에 사용된 전체 non-embedding 계산 또는 단계 수를 고정하고 모델 크기에 따른 테스트 손실을 연구한다.</p><p>손실에 대한 S_{min}의 법칙적 종속성은 최적화 동력학과 손실 풍경 사이의 상호작용을 보여준다. 학습 후반부에 가장 적합성이 좋기 때문에, 법칙이 손실의 hessian 행렬 스펙트럼에 대한 정보를 제공한다. 그 보편성은 hessian 행렬의 고유값 밀도가 모델 크기와 거의 관련이 없음을 나타낸다.</p><h3 id=lower-bound-on-early-stopping-step>Lower Bound on Early Stopping Step</h3><p>$L(N, S_{min})$ 결과는 데이터 제한 학습에서 일찍 멈춰야 하는 단계의 최소 한계를 도출하는데 사용된다. 이는 주어진 모델의 유한 $D$와 무한 $D$ 학습 곡선이 $S_{min} \approx S_{stop}$에 이를 때까지 유사하기 때문이다. 따라서 과적합은 $S_{stop}$에서 학습을 중단하는 수정에 비례할 것이다. 이는 유한 $D$에서 테스트 손실이 더 느리게 감소하므로 $S_{stop}$을 과소평가하게 된다. 이러한 추론은 특정 부등식을 이끈다.</p><p>$$ S_{stop} (N, D) \geqslant {{S_c}\over{[L(N, D) - L(N, \infty)]^{1/\alpha_S}}} $$</p><p>$L(N, \infty)$은 무한한 데이터로 평가된 수렴된 손실이다. 이 부등식은 경험적 데이터와 비교되며, $S_{stop}$과 $L(N, D)$는 경험적이다. $L(N, \infty)$은 $D = \infty$에서 평가된 $L(N, D)$에 대한 적합으로 계산된다.</p><hr><h2 id=optimal-allocation-of-the-compute-budget>Optimal Allocation of the Compute Budget</h2><p>훈련 중 계산에 따른 성능의 경험적 추세를 보면, ﬁxed batch size $B$에서 학습하는 것을 포함하지만, 실제로는 batch size $B_{crit}$에서 더 효율적으로 학습할 수 있다. 손실의 큰 값과 작은 값은 각각 더 적은 샘플이나 단계로 달성될 수 있었으며, 이를 중요한 batch size로 표준화하면 더 깔끔하고 예측 가능한 추세가 나타난다.</p><p>이 섹션에서는 이전의 실수를 조정하고, 모델 크기 $N$과 학습 중 처리된 데이터 양($2B_{crit} S_{min}$) 사이의 최적 컴퓨트 할당을 결정한다. 이는 $L(N, S_{min})$의 방정식을 활용하여 경험적으로 그리고 이론적으로 수행되며, 두 방법이 일치함을 보여줄 예정이다.</p><h3 id=optimal-performance-and-allocations>Optimal Performance and Allocations</h3><p><img src=/p/scaling-law/images/figure13.png width=600 height=402 srcset="/p/scaling-law/images/figure13_huc106e3524a53c639afc310e501f54577_49989_480x0_resize_box_3.png 480w, /p/scaling-law/images/figure13_huc106e3524a53c639afc310e501f54577_49989_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=149 data-flex-basis=358px></p><p>최적으로 할당된 계산에 따른 손실을 연구한다. $C_{min}$을 이용한 새로운 적합이 약간 개선되었다.</p><p><img src=/p/scaling-law/images/figure14.png width=1160 height=388 srcset="/p/scaling-law/images/figure14_huc7327aacde090150335287b2ab103f81_110037_480x0_resize_box_3.png 480w, /p/scaling-law/images/figure14_huc7327aacde090150335287b2ab103f81_110037_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=298 data-flex-basis=717px></p><p>$L(C_{min})$이 주어졌을 때, 주어진 학습 계산량으로 최소 손실을 제공하는 최적 모델 크기 $N(C_{min})$을 찾는 것이 중요하. 이 최적 모델 크기는 법칙적으로 매우 잘 적합함을 확인할 수 있다.</p><p>$$ N(C_{min}) \propto (C_{min})^{0.73} $$</p><p>최적이 아닌 크기의 모델을 훈련시키는 효과를 보여준다.</p><p><img src=/p/scaling-law/images/figure12.png width=1158 height=390 srcset="/p/scaling-law/images/figure12_huac5d1ae62617d5e01a88fb0c11b55330_100191_480x0_resize_box_3.png 480w, /p/scaling-law/images/figure12_huac5d1ae62617d5e01a88fb0c11b55330_100191_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=296 data-flex-basis=712px></p><p>정의에 따르면, $C_{min} ≡ 6NB_{crit} S$이므로, $N(C_{min})$를 사용하여 추가 결과를 도출할 수 있다. 이전 적합 결과 $B \propto L^{−4.8}$ 및 $L \propto C_{min}^{−0.05}$를 바탕으로, $B_{crit} \propto C_{min}^{0.24}라는 결론을 내린다. 이로 인해 최적의 단계 수는 계산량에 따라 매우 느리게 증가할 것으로 예상된다.</p><p>$$ S_{min} \propto (C_{min})^{0.03} $$</p><p>실제로 측정된 지수는 충분히 작아서, 결과는 지수가 0인 경우와도 일관성이 있을 수 있다.</p><p>언어 모델링을 최적의 계산 할당으로 확장하면서, 주로 모델 크기 $N$을 늘리고, $B \propto B_{crit}$를 통해 배치 크기를 증가시키되, 연속적인 단계 수의 증가는 무시해야 한다. 계산 효율적인 학습은 적은 수의 최적화 단계를 사용하므로, 초기 학습 동력학을 가속화하는 추가 작업이 필요할 수 있다.</p><h3 id=predictions-from-ln-s_min>Predictions from $L(N, S_{min})$</h3><p>$L(C_{min})$과 할당 결과는 $L(N, S_{min})$ 방정식을 통해 예측할 수 있다. $L(N, S_{min})$ 방정식을 이용하면, $S_{min} = C_{min}$을 대입하고 학습 계산을 고정한 상태에서 $N$에 따른 손실의 최소값 $6NB$를 찾을 수 있다.</p><p>학습 계산의 함수로서의 손실에 대해서, 우리는 다음을 예측한다.</p><p>$$ L(C_{min}) = \big( {{C_c^{min}}\over{C_{min}}} \big)^{\alpha_C^{min}} $$</p><p>$$ \alpha_C ≡ {{1}\over{1/\alpha_S + 1/\alpha_B + 1/\alpha_N}} \approx 0.054 $$</p><p>또한 다음을 예측한다.</p><p>$$ N(C_{min}) \propto (C_{min})^{\alpha_C^{min} / \alpha_N} \approx (C_{min})^{0.71} $$</p><p>이것 또한 스케일링과 몇 퍼센트 이내로 일치한다. scaling law는 언어 모델링의 성능에 대한 예측적인 프레임워크를 제공한다.</p><h3 id=contradictions-and-a-conjecture>Contradictions and a Conjecture</h3><p>계산, 데이터, 모델 크기의 큰 값에서 직선적인 법칙적 추세로부터의 이탈을 관찰하지 않는다. 그러나, 자연어가 0이 아닌 엔트로피를 가지고 있기 때문에, 추세는 결국 안정화되어야 한다.</p><p>이 섹션에서 서술된 계산 효율적인 학습의 추세는 명백한 모순을 포함하고 있다. 훨씬 큰 규모에서 $L(C_{min})$ scaling law에 의해 예측된 성능은 계산과 함께 학습 데이터 증가가 느리다는 점을 고려하면 가능한 것보다 낮다. 이는 scaling law가 이 지점 이전에 붕괴해야 함을 의미하며, 이 교차점은 transformer 언어 모델이 최대 성능에 도달하는 지점의 추정치를 제공한다는 더 깊은 의미를 가지고 있을 것으로 추측한다.</p><p><img src=/p/scaling-law/images/figure15.png width=1018 height=404 srcset="/p/scaling-law/images/figure15_hu25ae687c6abeabf8501500f350471773_63474_480x0_resize_box_3.png 480w, /p/scaling-law/images/figure15_hu25ae687c6abeabf8501500f350471773_63474_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=251 data-flex-basis=604px></p><p>계산 효율적인 학습에 사용되는 데이터의 양이 계산 예산과 느리게 증가하기 때문에, $L(C_{min})$에 의해 예측된 성능은 결국 $L(D)$ 법칙에 의해 설정된 하한선에 도달한다.</p><p>과적합을 제어하기 위해, 데이터셋 크기를 다음과 같이 조정해야 함을 의미한다.</p><p>$$ D \propto N^{0.74} \propto C_{min}^{0.54} $$</p><p>critical batch size에서 학습하고 학습 중 데이터를 재사용하지 않는 경우, 데이터 사용량이 계산량과 같이 증가한다는 것을 알 수 있다. 이는 계산 효율적인 학습의 데이터 요구사항과 비교된다.</p><p>$$ D(C_{min}) = {{2 C_{min}}\over{6 N (C_{min})}} \approx ( 4 \times 10^{10} \text{tokens} ) (C_{min}/\text{PF-Day})^{0.26} $$</p><p>계산량과 함께 데이터셋 크기가 생산적으로 증가할 수 있는 최대 속도는 단 한 번의 epoch만을 위해 학습하는 것이다. 그러나 이는 데이터셋을 더 느리게 증가시키며, 학습 과정에서 데이터를 재사용하지 않더라도, 계산 효율적인 학습은 결국 과적합 문제에 직면하게 될 것이라는 것을 암시한다.</p><p>데이터셋 크기에 의해 제한될 때, 즉 과적합 발생시 손실은 $L(D) \propto D^{−0.095}$로 스케일링될 것으로 예상된다. 이는 데이터 제한시 손실이 계산량에 따라 $L(D(C_{min})) \propto C_{min}^−{0.03}$으로 스케일링될 것을 의미한다. 그러나 $L(C_{min}) \propto C_{min}^{−0.050}$ 예측과 교차하게 되어 모순이 발생한다.</p><p>$L(D(C_{min}))$와 $L(C_{min})$의 교차점은 다음에서 발생한다.</p><p>$$ C^∗ \sim 10^4 \text{PF-Days} N^∗ \sim 10^{12} \text{parameters}, D^∗ \sim 10^{12} \text{tokens}, L^∗ \sim 1.7 \text{nats/token} $$</p><p>수치값은 매우 불확실하며, 법칙적인 적합에서의 지수의 정확한 값에 따라 크게 변할 수 있다. 가장 명확한 해석은, 계산과 모델 크기에서 많은 자릿수만큼 떨어진 이 지점에 도달하거나 그 이전에 scaling law가 붕괴한다는 것이다.</p><p>교차점이 더 깊은 의미를 가진다는 추측이 있다. 특별한 데이터 요구사항 없이 모델 크기를 $N^∗$ 이상으로 늘릴 수 없다면, $C_{min}^∗ 와 $N^∗$에 도달하면 자연어 데이터에서 신뢰할 수 있는 정보를 모두 추출했다는 것을 의미할 수 있다. 이 경우, $L^∗$은 자연어의 토큰당 엔트로피의 대략적인 추정치를 제공하며, 손실 추세는 $L^∗$ 에서 또는 그 이전에 안정화될 것으로 예상된다.</p><p>학습 데이터셋에 추가된 잡음을 고려하면 $L(C_{min})$의 함수 형태가 안정화되는 것을 추측할 수 있다. 예를 들어, 랜덤 토큰 문자열을 각 컨텍스트에 추가하여 손실을 상수만큼 증가시킬 수 있다. 잡음 바닥에서의 거리 $L - L_{noise}$는 더 의미있는 성능 지표가 될 수 있으며, 이 거리에서의 작은 감소는 큰 성능 향상을 나타낼 수 있다. 인공적인 잡음은 모든 추세에 동일한 영향을 미치므로, 안정화 이후에도 임계점 6.8은 변하지 않고 의미가 있을 수 있다.</p><hr><h2 id=related-work>Related Work</h2><p>Power law는 다양한 출처에서 나올 수 있다. 밀도 추정과 랜덤 포레스트 모델에서의 모델과 데이터셋 크기에 대한 Power-law scaling은 결과와 관련이 있을 수 있다. 이 모델들은 power-law exponent가 데이터의 관련 특징 수의 역수로 대략적으로 해석될 수 있다고 제안한다.</p><p>일부 초기 연구에서는 성능과 데이터셋 크기 간의 power-law scaling을 발견했고, 최근 연구는 모델 크기와 데이터 크기 사이의 스케일링도 조사하였다. 그러나 일부 연구에서는 모델 크기와 함께 데이터셋 크기의 super-linear scaling을 발견했지만, 이 논문은 sub-linear scaling을 발견하였다. 또한, power-law learning curve과 최적의 계산 할당에 대한 이 논문의 연구 결과와 일부 유사점이 있다. 최근의 연구에서는 다양한 데이터셋에 대한 데이터셋 크기와 모델 크기 모두를 확장하고 있다.</p><p>EfficientNet은 이미지 모델의 최적 성능을 위해 깊이와 너비를 지수적으로 확장하도록 주장하며, 이는 깊이에 따른 너비의 power-law scaling을 초래한다. 언어 모델에 대해 이 지수가 확장 시 대략 1이어야 한다는 것을 발견했으며, 언어 모델의 전체적인 규모에 비해 구조적인 hyperparameter의 정확성은 크게 중요하지 않다는 것을 발견하였다. 또한, 일부 연구에서는 데이터 예제당 계산을 고정하는 반면, 이 논문의 모델 크기와 학습 계산량 모두를 확장하는 것을 조사하였다.</p><p>overparameterized 모델에서의 일반화를 조사한 여러 연구들에서는 모델 크기가 데이터셋 크기에 도달하면 &ldquo;jamming transition"가 발생한다는 것을 발견하였다. 하지만 이러한 전환이 일어나지 않는 것을 발견하였고, 필요한 학습 데이터가 모델 크기에 대해 부분적으로 확장된다는 것을 확인하였다. 모델 크기의 확장, 특히 큰 너비는 스케일링 관계에 대해 생각하는 데 유용한 프레임워크를 제공할 수 있다. 또한, 노이즈가 있는 이차 모델을 사용하여 학습 곡선의 형태 등 최적화 결과를 설명할 수 있다.</p><hr><h2 id=discussion>Discussion</h2><p>언어 모델의 log-likelihood loss는 non-embedding parameter 수, 데이터셋 크기, 최적화된 학습 계산과 일관되게 스케일링되며, 이는 특정 수식에 요약되어 있다. 반면, 다수의 구조적 및 optimization hyperparameter에 대한 의존성은 매우 약하다. 이러한 스케일링은 power-law scaling이므로, 규모가 증가할수록 효과는 점점 감소한다.</p><p>parameter가 동시에 변할 때 손실이 특정 변수에 어떻게 의존하는지 정확하게 모델링할 수 있었다. 이를 통해 대형 언어 모델 학습시 계산 스케일링, 과적합의 크기, 조기 중단 단계, 데이터 요구 사항을 도출하였다. 이러한 스케일링 관계는 단순한 관찰을 넘어 예측 프레임워크를 제공하며, 이는 이상기체법칙과 유사하게 해석될 수 있다.</p><p>스케일링 관계는 maximum likelihood loss를 가진 다른 생성 모델링 작업, 예를 들어 이미지, 오디오, 비디오 모델 등에도 적용될 것으로 예상된다. 현재로서는 어떤 결과가 자연 언어 데이터의 구조에 의존하고 어떤 것이 보편적인지 확실하지 않다. &ldquo;thermodynamics"을 기반으로 하는 &ldquo;statistical mechanics&rdquo; 같은 이론적 프레임워크를 발견하는 것은 더욱 정확한 예측을 도출하고 scaling law의 한계를 체계적으로 이해하는 데 도움이 될 것이다.</p><p>자연어 분야에서는 손실의 지속적인 개선이 실제 언어 작업에 대한 개선으로 이어지는지 확인하는 것이 중요하다. &ldquo;more is different"라는 말처럼, 부드러운 양적 변화는 실질적인 질적 개선을 가릴 수 있다. 경제 성장이나 언어 모델 손실의 부드러운 개선 뒤에는 특정 기술 개발이나 능력의 질적 변화가 숨겨져 있을 수 있다.</p><p>이 논문의 연구 결과는 더 큰 모델이 계속해서 성능을 개선하며, 이전에 알려진 것보다 샘플 사용 효율이 높을 것이라는 강력한 추정을 제공한다. 이에 따라 모델 병렬화에 대한 추가 연구가 필요하며, 깊은 모델은 파이프라이닝을 활용한 학습, 넓은 네트워크는 병렬화를 통한 학습이 가능하다는 것을 확인하였다. 뿐만 아니라, 희소성 또는 분기를 활용하면 큰 네트워크의 빠른 학습이 가능하며, 네트워크를 학습하면서 확장하는 방법을 사용하면 전체 학습 과정에서 계산 효율성을 유지할 수 있다.</p><hr><h2 id=reference>Reference</h2><ul><li><a class=link href=https://arxiv.org/pdf/2001.08361.pdf target=_blank rel=noopener>Paper</a></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/nlp/>NLP</a>
<a href=/tags/llm/>LLM</a></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>관련 글</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/galactica/><div class=article-details><h2 class=article-title>Galactica</h2></div></a></article><article><a href=/p/bloom/><div class=article-details><h2 class=article-title>BLOOM</h2></div></a></article><article><a href=/p/helm/><div class=article-details><h2 class=article-title>HELM</h2></div></a></article><article><a href=/p/glm-130b/><div class=article-details><h2 class=article-title>GLM-130B</h2></div></a></article><article><a href=/p/flan-t5/palm/><div class=article-details><h2 class=article-title>Flan-T5/PaLM</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=KurtKim/kurtkim.github.io issue-term=pathname crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2024 K2H'log</section><section class=powerby><a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>로 만듦<br><a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>의 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.17.0>Stack</a></b> 테마 사용 중</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"}),MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}})</script></body></html>